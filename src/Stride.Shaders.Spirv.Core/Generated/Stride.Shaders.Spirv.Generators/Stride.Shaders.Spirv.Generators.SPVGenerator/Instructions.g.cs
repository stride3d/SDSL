using static Stride.Shaders.Spirv.Specification;
using CommunityToolkit.HighPerformance;
using CommunityToolkit.HighPerformance.Buffers;
using Stride.Shaders.Spirv.Core.Buffers;
using System.Numerics;

namespace Stride.Shaders.Spirv.Core;
public struct OpSDSLShader : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLShader()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLShader | (1 << 16);
    }

    public string ShaderName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLShader(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "shaderName")
                ShaderName = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpSDSLShader(string shaderName)
    {
        ShaderName = shaderName;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLShader, ..ShaderName.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLShader(OpDataIndex odi) => new(odi);
}

public struct OpSDSLShaderEnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLShaderEnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLShaderEnd | (1 << 16);
    }

    public OpSDSLShaderEnd(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpSDSLShaderEnd(OpDataIndex odi) => new(odi);
}

public struct OpSDSLMixinInherit : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixinInherit()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixinInherit | (1 << 16);
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixinInherit(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "shader")
                Shader = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSDSLMixinInherit(int shader)
    {
        Shader = shader;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixinInherit, Shader];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLMixinInherit(OpDataIndex odi) => new(odi);
}

public struct OpSDSLCompose : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLCompose()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLCompose | (1 << 16);
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLCompose(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "mixin")
                Mixin = o.ToLiteral<string>();
            else if (o.Name == "name")
                Name = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpSDSLCompose(string mixin, string name)
    {
        Mixin = mixin;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLCompose, ..Mixin.AsDisposableLiteralValue().Words, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLCompose(OpDataIndex odi) => new(odi);
}

public struct OpSDSLStage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLStage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLStage | (1 << 16);
    }

    public int StagedElement
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLStage(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "stagedElement")
                StagedElement = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSDSLStage(int stagedElement)
    {
        StagedElement = stagedElement;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLStage, StagedElement];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLStage(OpDataIndex odi) => new(odi);
}

public struct OpSDSLImportShader : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportShader()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportShader | (1 << 16);
    }

    public static implicit operator Id(OpSDSLImportShader inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSDSLImportShader inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string ShaderName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLImportShader(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "shaderName")
                ShaderName = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpSDSLImportShader(int resultId, string shaderName)
    {
        ResultId = resultId;
        ShaderName = shaderName;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportShader, ResultId, ..ShaderName.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLImportShader(OpDataIndex odi) => new(odi);
}

public struct OpSDSLImportFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportFunction | (1 << 16);
    }

    public static implicit operator Id(OpSDSLImportFunction inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSDSLImportFunction inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string FunctionName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLImportFunction(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "functionName")
                FunctionName = o.ToLiteral<string>();
            else if (o.Name == "shader")
                Shader = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSDSLImportFunction(int resultType, int resultId, string functionName, int shader)
    {
        ResultType = resultType;
        ResultId = resultId;
        FunctionName = functionName;
        Shader = shader;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportFunction, ResultType, ResultId, ..FunctionName.AsDisposableLiteralValue().Words, Shader];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLImportFunction(OpDataIndex odi) => new(odi);
}

public struct OpSDSLImportVariable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportVariable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportVariable | (1 << 16);
    }

    public static implicit operator Id(OpSDSLImportVariable inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSDSLImportVariable inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string VariableName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLImportVariable(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "variableName")
                VariableName = o.ToLiteral<string>();
            else if (o.Name == "shader")
                Shader = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSDSLImportVariable(int resultType, int resultId, string variableName, int shader)
    {
        ResultType = resultType;
        ResultId = resultId;
        VariableName = variableName;
        Shader = shader;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportVariable, ResultType, ResultId, ..VariableName.AsDisposableLiteralValue().Words, Shader];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLImportVariable(OpDataIndex odi) => new(odi);
}

public struct OpNop : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNop()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNop | (1 << 16);
    }

    public OpNop(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpNop(OpDataIndex odi) => new(odi);
}

public struct OpUndef : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUndef()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUndef | (1 << 16);
    }

    public static implicit operator Id(OpUndef inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUndef inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUndef(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUndef(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUndef, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUndef(OpDataIndex odi) => new(odi);
}

public struct OpSourceContinued : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSourceContinued()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSourceContinued | (1 << 16);
    }

    public string ContinuedSource
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSourceContinued(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "continuedSource")
                ContinuedSource = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpSourceContinued(string continuedSource)
    {
        ContinuedSource = continuedSource;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSourceContinued, ..ContinuedSource.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSourceContinued(OpDataIndex odi) => new(odi);
}

public struct OpSource : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSource()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSource | (1 << 16);
    }

    public SourceLanguage Sourcelanguage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Version
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? File
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string? Source
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSource(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "sourcelanguage")
                Sourcelanguage = o.ToEnum<SourceLanguage>();
            else if (o.Name == "version")
                Version = o.ToLiteral<int>();
            else if (o.Name == "file")
                if (o.Words.Length > 0)
                    File = o.ToLiteral<int?>();
                else if (o.Name == "source")
                    if (o.Words.Length > 0)
                        Source = o.ToLiteral<string?>();
        }

        DataIndex = index;
    }

    public OpSource(SourceLanguage sourcelanguage, int version, int? file, string? source)
    {
        Sourcelanguage = sourcelanguage;
        Version = version;
        File = file;
        Source = source;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSource, (int)Sourcelanguage, ..Version.AsDisposableLiteralValue().Words, ..File is null ? (Span<int>)[] : [File.Value], ..Source is null ? (Span<int>)[] : Source.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSource(OpDataIndex odi) => new(odi);
}

public struct OpSourceExtension : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSourceExtension()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSourceExtension | (1 << 16);
    }

    public string Extension
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSourceExtension(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "extension")
                Extension = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpSourceExtension(string extension)
    {
        Extension = extension;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSourceExtension, ..Extension.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSourceExtension(OpDataIndex odi) => new(odi);
}

public struct OpName : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpName()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpName | (1 << 16);
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpName(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "target")
                Target = o.ToLiteral<int>();
            else if (o.Name == "name")
                Name = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpName(int target, string name)
    {
        Target = target;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpName, Target, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpName(OpDataIndex odi) => new(odi);
}

public struct OpMemberName : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberName()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberName | (1 << 16);
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberName(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "type")
                Type = o.ToLiteral<int>();
            else if (o.Name == "member")
                Member = o.ToLiteral<int>();
            else if (o.Name == "name")
                Name = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpMemberName(int type, int member, string name)
    {
        Type = type;
        Member = member;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberName, Type, ..Member.AsDisposableLiteralValue().Words, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemberName(OpDataIndex odi) => new(odi);
}

public struct OpString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpString()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpString | (1 << 16);
    }

    public static implicit operator Id(OpString inst) => new Id(inst.ResultId);
    public static implicit operator int (OpString inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpString(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpString(int resultId, string value)
    {
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpString, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpString(OpDataIndex odi) => new(odi);
}

public struct OpLine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLine | (1 << 16);
    }

    public int File
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Line
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Column
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLine(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "file")
                File = o.ToLiteral<int>();
            else if (o.Name == "line")
                Line = o.ToLiteral<int>();
            else if (o.Name == "column")
                Column = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLine(int file, int line, int column)
    {
        File = file;
        Line = line;
        Column = column;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLine, File, ..Line.AsDisposableLiteralValue().Words, ..Column.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLine(OpDataIndex odi) => new(odi);
}

public struct OpExtension : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtension()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtension | (1 << 16);
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExtension(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "name")
                Name = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpExtension(string name)
    {
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtension, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExtension(OpDataIndex odi) => new(odi);
}

public struct OpExtInstImport : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInstImport()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInstImport | (1 << 16);
    }

    public static implicit operator Id(OpExtInstImport inst) => new Id(inst.ResultId);
    public static implicit operator int (OpExtInstImport inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExtInstImport(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "name")
                Name = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpExtInstImport(int resultId, string name)
    {
        ResultId = resultId;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInstImport, ResultId, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExtInstImport(OpDataIndex odi) => new(odi);
}

public struct OpExtInst : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInst()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public static implicit operator Id(OpExtInst inst) => new Id(inst.ResultId);
    public static implicit operator int (OpExtInst inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Instruction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExtInst(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "set")
                Set = o.ToLiteral<int>();
            else if (o.Name == "instruction")
                Instruction = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpExtInst(int resultType, int resultId, int set, int instruction, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Instruction = instruction;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExtInst(OpDataIndex odi) => new(odi);
}

public struct OpMemoryModel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryModel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryModel | (1 << 16);
    }

    public AddressingModel Addressingmodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryModel Memorymodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryModel(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "addressingmodel")
                Addressingmodel = o.ToEnum<AddressingModel>();
            else if (o.Name == "memorymodel")
                Memorymodel = o.ToEnum<MemoryModel>();
        }

        DataIndex = index;
    }

    public OpMemoryModel(AddressingModel addressingmodel, MemoryModel memorymodel)
    {
        Addressingmodel = addressingmodel;
        Memorymodel = memorymodel;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryModel, (int)Addressingmodel, (int)Memorymodel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemoryModel(OpDataIndex odi) => new(odi);
}

public struct OpEntryPoint : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEntryPoint()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEntryPoint | (1 << 16);
    }

    public ExecutionModel Executionmodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEntryPoint(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "executionmodel")
                Executionmodel = o.ToEnum<ExecutionModel>();
            else if (o.Name == "entryPoint")
                EntryPoint = o.ToLiteral<int>();
            else if (o.Name == "name")
                Name = o.ToLiteral<string>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpEntryPoint(ExecutionModel executionmodel, int entryPoint, string name, LiteralArray<int> values)
    {
        Executionmodel = executionmodel;
        EntryPoint = entryPoint;
        Name = name;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEntryPoint, (int)Executionmodel, EntryPoint, ..Name.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEntryPoint(OpDataIndex odi) => new(odi);
}

public struct OpExecutionMode : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecutionMode()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecutionMode | (1 << 16);
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ExecutionMode Mode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecutionMode(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "entryPoint")
                EntryPoint = o.ToLiteral<int>();
            else if (o.Name == "mode")
                Mode = o.ToEnum<ExecutionMode>();
        }

        DataIndex = index;
    }

    public OpExecutionMode(int entryPoint, ExecutionMode mode)
    {
        EntryPoint = entryPoint;
        Mode = mode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecutionMode, EntryPoint, (int)Mode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExecutionMode(OpDataIndex odi) => new(odi);
}

public struct OpCapability : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCapability()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCapability | (1 << 16);
    }

    public Capability Capability
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCapability(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "capability")
                Capability = o.ToEnum<Capability>();
        }

        DataIndex = index;
    }

    public OpCapability(Capability capability)
    {
        Capability = capability;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCapability, (int)Capability];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCapability(OpDataIndex odi) => new(odi);
}

public struct OpTypeVoid : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVoid()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVoid | (1 << 16);
    }

    public static implicit operator Id(OpTypeVoid inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeVoid inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeVoid(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeVoid(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVoid, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeVoid(OpDataIndex odi) => new(odi);
}

public struct OpTypeBool : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeBool()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeBool | (1 << 16);
    }

    public static implicit operator Id(OpTypeBool inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeBool inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeBool(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeBool(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeBool, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeBool(OpDataIndex odi) => new(odi);
}

public struct OpTypeInt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeInt()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeInt | (1 << 16);
    }

    public static implicit operator Id(OpTypeInt inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeInt inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Signedness
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeInt(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "width")
                Width = o.ToLiteral<int>();
            else if (o.Name == "signedness")
                Signedness = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeInt(int resultId, int width, int signedness)
    {
        ResultId = resultId;
        Width = width;
        Signedness = signedness;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeInt, ResultId, ..Width.AsDisposableLiteralValue().Words, ..Signedness.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeInt(OpDataIndex odi) => new(odi);
}

public struct OpTypeFloat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeFloat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeFloat | (1 << 16);
    }

    public static implicit operator Id(OpTypeFloat inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeFloat inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public FPEncoding? FloatingPointEncoding
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeFloat(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "width")
                Width = o.ToLiteral<int>();
            else if (o.Name == "floatingPointEncoding")
                if (o.Words.Length > 0)
                    FloatingPointEncoding = o.ToEnum<FPEncoding>();
        }

        DataIndex = index;
    }

    public OpTypeFloat(int resultId, int width, FPEncoding? floatingPointEncoding)
    {
        ResultId = resultId;
        Width = width;
        FloatingPointEncoding = floatingPointEncoding;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeFloat, ResultId, ..Width.AsDisposableLiteralValue().Words, ..FloatingPointEncoding is null ? (Span<int>)[] : [(int)FloatingPointEncoding.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeFloat(OpDataIndex odi) => new(odi);
}

public struct OpTypeVector : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVector()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVector | (1 << 16);
    }

    public static implicit operator Id(OpTypeVector inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeVector inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeVector(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "componentType")
                ComponentType = o.ToLiteral<int>();
            else if (o.Name == "componentCount")
                ComponentCount = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeVector(int resultId, int componentType, int componentCount)
    {
        ResultId = resultId;
        ComponentType = componentType;
        ComponentCount = componentCount;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVector, ResultId, ComponentType, ..ComponentCount.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeVector(OpDataIndex odi) => new(odi);
}

public struct OpTypeMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeMatrix | (1 << 16);
    }

    public static implicit operator Id(OpTypeMatrix inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeMatrix inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeMatrix(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "columnType")
                ColumnType = o.ToLiteral<int>();
            else if (o.Name == "columnCount")
                ColumnCount = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeMatrix(int resultId, int columnType, int columnCount)
    {
        ResultId = resultId;
        ColumnType = columnType;
        ColumnCount = columnCount;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeMatrix, ResultId, ColumnType, ..ColumnCount.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeMatrix(OpDataIndex odi) => new(odi);
}

public struct OpTypeImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeImage | (1 << 16);
    }

    public static implicit operator Id(OpTypeImage inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeImage inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Dim Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Depth
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arrayed
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MS
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampled
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageFormat Imageformat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier? Accessqualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeImage(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledType")
                SampledType = o.ToLiteral<int>();
            else if (o.Name == "dim")
                Dim = o.ToEnum<Dim>();
            else if (o.Name == "depth")
                Depth = o.ToLiteral<int>();
            else if (o.Name == "arrayed")
                Arrayed = o.ToLiteral<int>();
            else if (o.Name == "mS")
                MS = o.ToLiteral<int>();
            else if (o.Name == "sampled")
                Sampled = o.ToLiteral<int>();
            else if (o.Name == "imageformat")
                Imageformat = o.ToEnum<ImageFormat>();
            else if (o.Name == "accessqualifier")
                if (o.Words.Length > 0)
                    Accessqualifier = o.ToEnum<AccessQualifier>();
        }

        DataIndex = index;
    }

    public OpTypeImage(int resultId, int sampledType, Dim dim, int depth, int arrayed, int mS, int sampled, ImageFormat imageformat, AccessQualifier? accessqualifier)
    {
        ResultId = resultId;
        SampledType = sampledType;
        Dim = dim;
        Depth = depth;
        Arrayed = arrayed;
        MS = mS;
        Sampled = sampled;
        Imageformat = imageformat;
        Accessqualifier = accessqualifier;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeImage, ResultId, SampledType, (int)Dim, ..Depth.AsDisposableLiteralValue().Words, ..Arrayed.AsDisposableLiteralValue().Words, ..MS.AsDisposableLiteralValue().Words, ..Sampled.AsDisposableLiteralValue().Words, (int)Imageformat, ..Accessqualifier is null ? (Span<int>)[] : [(int)Accessqualifier.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeImage(OpDataIndex odi) => new(odi);
}

public struct OpTypeSampler : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeSampler()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeSampler | (1 << 16);
    }

    public static implicit operator Id(OpTypeSampler inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeSampler inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeSampler(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeSampler(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeSampler, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeSampler(OpDataIndex odi) => new(odi);
}

public struct OpTypeSampledImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeSampledImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeSampledImage | (1 << 16);
    }

    public static implicit operator Id(OpTypeSampledImage inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeSampledImage inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeSampledImage(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "imageType")
                ImageType = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeSampledImage(int resultId, int imageType)
    {
        ResultId = resultId;
        ImageType = imageType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeSampledImage, ResultId, ImageType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeSampledImage(OpDataIndex odi) => new(odi);
}

public struct OpTypeArray : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeArray()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeArray | (1 << 16);
    }

    public static implicit operator Id(OpTypeArray inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeArray inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ElementType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Length
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeArray(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "elementType")
                ElementType = o.ToLiteral<int>();
            else if (o.Name == "length")
                Length = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeArray(int resultId, int elementType, int length)
    {
        ResultId = resultId;
        ElementType = elementType;
        Length = length;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeArray, ResultId, ElementType, Length];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeArray(OpDataIndex odi) => new(odi);
}

public struct OpTypeRuntimeArray : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeRuntimeArray()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeRuntimeArray | (1 << 16);
    }

    public static implicit operator Id(OpTypeRuntimeArray inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeRuntimeArray inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ElementType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeRuntimeArray(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "elementType")
                ElementType = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeRuntimeArray(int resultId, int elementType)
    {
        ResultId = resultId;
        ElementType = elementType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeRuntimeArray, ResultId, ElementType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeRuntimeArray(OpDataIndex odi) => new(odi);
}

public struct OpTypeStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeStruct | (1 << 16);
    }

    public static implicit operator Id(OpTypeStruct inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeStruct inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeStruct(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTypeStruct(int resultId, LiteralArray<int> values)
    {
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeStruct, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeStruct(OpDataIndex odi) => new(odi);
}

public struct OpTypeOpaque : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeOpaque()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeOpaque | (1 << 16);
    }

    public static implicit operator Id(OpTypeOpaque inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeOpaque inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Thenameoftheopaquetype
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeOpaque(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "thenameoftheopaquetype")
                Thenameoftheopaquetype = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpTypeOpaque(int resultId, string thenameoftheopaquetype)
    {
        ResultId = resultId;
        Thenameoftheopaquetype = thenameoftheopaquetype;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeOpaque, ResultId, ..Thenameoftheopaquetype.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeOpaque(OpDataIndex odi) => new(odi);
}

public struct OpTypePointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePointer | (1 << 16);
    }

    public static implicit operator Id(OpTypePointer inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypePointer inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypePointer(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
            else if (o.Name == "type")
                Type = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypePointer(int resultId, StorageClass storageclass, int type)
    {
        ResultId = resultId;
        Storageclass = storageclass;
        Type = type;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePointer, ResultId, (int)Storageclass, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypePointer(OpDataIndex odi) => new(odi);
}

public struct OpTypeFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeFunction | (1 << 16);
    }

    public static implicit operator Id(OpTypeFunction inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeFunction inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReturnType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeFunction(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "returnType")
                ReturnType = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTypeFunction(int resultId, int returnType, LiteralArray<int> values)
    {
        ResultId = resultId;
        ReturnType = returnType;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeFunction, ResultId, ReturnType, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeFunction(OpDataIndex odi) => new(odi);
}

public struct OpTypeEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeEvent | (1 << 16);
    }

    public static implicit operator Id(OpTypeEvent inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeEvent inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeEvent(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeEvent(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeEvent, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeEvent(OpDataIndex odi) => new(odi);
}

public struct OpTypeDeviceEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeDeviceEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeDeviceEvent | (1 << 16);
    }

    public static implicit operator Id(OpTypeDeviceEvent inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeDeviceEvent inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeDeviceEvent(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeDeviceEvent(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeDeviceEvent, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeDeviceEvent(OpDataIndex odi) => new(odi);
}

public struct OpTypeReserveId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeReserveId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeReserveId | (1 << 16);
    }

    public static implicit operator Id(OpTypeReserveId inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeReserveId inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeReserveId(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeReserveId(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeReserveId, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeReserveId(OpDataIndex odi) => new(odi);
}

public struct OpTypeQueue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeQueue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeQueue | (1 << 16);
    }

    public static implicit operator Id(OpTypeQueue inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeQueue inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeQueue(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeQueue(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeQueue, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeQueue(OpDataIndex odi) => new(odi);
}

public struct OpTypePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePipe | (1 << 16);
    }

    public static implicit operator Id(OpTypePipe inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypePipe inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier Qualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypePipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "qualifier")
                Qualifier = o.ToEnum<AccessQualifier>();
        }

        DataIndex = index;
    }

    public OpTypePipe(int resultId, AccessQualifier qualifier)
    {
        ResultId = resultId;
        Qualifier = qualifier;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePipe, ResultId, (int)Qualifier];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypePipe(OpDataIndex odi) => new(odi);
}

public struct OpTypeForwardPointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeForwardPointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeForwardPointer | (1 << 16);
    }

    public int PointerType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeForwardPointer(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointerType")
                PointerType = o.ToLiteral<int>();
            else if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
        }

        DataIndex = index;
    }

    public OpTypeForwardPointer(int pointerType, StorageClass storageclass)
    {
        PointerType = pointerType;
        Storageclass = storageclass;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeForwardPointer, PointerType, (int)Storageclass];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeForwardPointer(OpDataIndex odi) => new(odi);
}

public struct OpConstantTrue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantTrue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantTrue | (1 << 16);
    }

    public static implicit operator Id(OpConstantTrue inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantTrue inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantTrue(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConstantTrue(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantTrue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantTrue(OpDataIndex odi) => new(odi);
}

public struct OpConstantFalse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantFalse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantFalse | (1 << 16);
    }

    public static implicit operator Id(OpConstantFalse inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantFalse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantFalse(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConstantFalse(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantFalse, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantFalse(OpDataIndex odi) => new(odi);
}

// resultType:IdResultType, resultId:IdResult, value:LiteralContextDependentNumber
public struct OpConstant<T> : IMemoryInstruction where T : struct, INumber<T>
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public T Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator Id(OpConstant<T> inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstant<T> inst) => inst.ResultId;
    public OpConstant(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "value")
                Value = o.ToLiteral<T>();
        }

        DataIndex = index;
    }

    public OpConstant(int resultType, int resultId, LiteralValue<T> value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstant, ResultType, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstant<T>(OpDataIndex odi) => new(odi);
}

public struct OpConstantComposite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantComposite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantComposite | (1 << 16);
    }

    public static implicit operator Id(OpConstantComposite inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantComposite inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantComposite(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpConstantComposite(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantComposite, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantComposite(OpDataIndex odi) => new(odi);
}

public struct OpConstantSampler : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantSampler()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantSampler | (1 << 16);
    }

    public static implicit operator Id(OpConstantSampler inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantSampler inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SamplerAddressingMode Sampleraddressingmode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SamplerFilterMode Samplerfiltermode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantSampler(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampleraddressingmode")
                Sampleraddressingmode = o.ToEnum<SamplerAddressingMode>();
            else if (o.Name == "param")
                Param = o.ToLiteral<int>();
            else if (o.Name == "samplerfiltermode")
                Samplerfiltermode = o.ToEnum<SamplerFilterMode>();
        }

        DataIndex = index;
    }

    public OpConstantSampler(int resultType, int resultId, SamplerAddressingMode sampleraddressingmode, int param, SamplerFilterMode samplerfiltermode)
    {
        ResultType = resultType;
        ResultId = resultId;
        Sampleraddressingmode = sampleraddressingmode;
        Param = param;
        Samplerfiltermode = samplerfiltermode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantSampler, ResultType, ResultId, (int)Sampleraddressingmode, ..Param.AsDisposableLiteralValue().Words, (int)Samplerfiltermode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantSampler(OpDataIndex odi) => new(odi);
}

public struct OpConstantNull : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantNull()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantNull | (1 << 16);
    }

    public static implicit operator Id(OpConstantNull inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantNull inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantNull(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConstantNull(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantNull, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantNull(OpDataIndex odi) => new(odi);
}

public struct OpSpecConstantTrue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantTrue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantTrue | (1 << 16);
    }

    public static implicit operator Id(OpSpecConstantTrue inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSpecConstantTrue inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantTrue(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSpecConstantTrue(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantTrue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSpecConstantTrue(OpDataIndex odi) => new(odi);
}

public struct OpSpecConstantFalse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantFalse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantFalse | (1 << 16);
    }

    public static implicit operator Id(OpSpecConstantFalse inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSpecConstantFalse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantFalse(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSpecConstantFalse(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantFalse, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSpecConstantFalse(OpDataIndex odi) => new(odi);
}

// resultType:IdResultType, resultId:IdResult, value:LiteralContextDependentNumber
public struct OpSpecConstant<T> : IMemoryInstruction where T : struct, INumber<T>
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public T Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator Id(OpSpecConstant<T> inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSpecConstant<T> inst) => inst.ResultId;
    public OpSpecConstant(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "value")
                Value = o.ToLiteral<T>();
        }

        DataIndex = index;
    }

    public OpSpecConstant(int resultType, int resultId, LiteralValue<T> value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstant, ResultType, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSpecConstant<T>(OpDataIndex odi) => new(odi);
}

public struct OpSpecConstantComposite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantComposite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantComposite | (1 << 16);
    }

    public static implicit operator Id(OpSpecConstantComposite inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSpecConstantComposite inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantComposite(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpSpecConstantComposite(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantComposite, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSpecConstantComposite(OpDataIndex odi) => new(odi);
}

public struct OpSpecConstantOp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantOp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantOp | (1 << 16);
    }

    public static implicit operator Id(OpSpecConstantOp inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSpecConstantOp inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Opcode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantOp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "opcode")
                Opcode = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSpecConstantOp(int resultType, int resultId, int opcode)
    {
        ResultType = resultType;
        ResultId = resultId;
        Opcode = opcode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantOp, ResultType, ResultId, ..Opcode.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSpecConstantOp(OpDataIndex odi) => new(odi);
}

public struct OpFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunction | (1 << 16);
    }

    public static implicit operator Id(OpFunction inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFunction inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public FunctionControlMask Functioncontrol
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FunctionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFunction(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "functioncontrol")
                Functioncontrol = o.ToEnum<FunctionControlMask>();
            else if (o.Name == "functionType")
                FunctionType = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFunction(int resultType, int resultId, FunctionControlMask functioncontrol, int functionType)
    {
        ResultType = resultType;
        ResultId = resultId;
        Functioncontrol = functioncontrol;
        FunctionType = functionType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunction, ResultType, ResultId, (int)Functioncontrol, FunctionType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFunction(OpDataIndex odi) => new(odi);
}

public struct OpFunctionParameter : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionParameter()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionParameter | (1 << 16);
    }

    public static implicit operator Id(OpFunctionParameter inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFunctionParameter inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFunctionParameter(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFunctionParameter(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionParameter, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFunctionParameter(OpDataIndex odi) => new(odi);
}

public struct OpFunctionEnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionEnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionEnd | (1 << 16);
    }

    public OpFunctionEnd(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpFunctionEnd(OpDataIndex odi) => new(odi);
}

public struct OpFunctionCall : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionCall()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionCall | (1 << 16);
    }

    public static implicit operator Id(OpFunctionCall inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFunctionCall inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Function
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFunctionCall(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "function")
                Function = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpFunctionCall(int resultType, int resultId, int function, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Function = function;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionCall, ResultType, ResultId, Function, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFunctionCall(OpDataIndex odi) => new(odi);
}

public struct OpVariable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVariable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVariable | (1 << 16);
    }

    public static implicit operator Id(OpVariable inst) => new Id(inst.ResultId);
    public static implicit operator int (OpVariable inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Initializer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpVariable(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
            else if (o.Name == "initializer")
                if (o.Words.Length > 0)
                    Initializer = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpVariable(int resultType, int resultId, StorageClass storageclass, int? initializer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        Initializer = initializer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVariable, ResultType, ResultId, (int)Storageclass, ..Initializer is null ? (Span<int>)[] : [Initializer.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVariable(OpDataIndex odi) => new(odi);
}

public struct OpImageTexelPointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageTexelPointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageTexelPointer | (1 << 16);
    }

    public static implicit operator Id(OpImageTexelPointer inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageTexelPointer inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageTexelPointer(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "sample")
                Sample = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageTexelPointer(int resultType, int resultId, int image, int coordinate, int sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageTexelPointer, ResultType, ResultId, Image, Coordinate, Sample];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageTexelPointer(OpDataIndex odi) => new(odi);
}

public struct OpLoad : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoad()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoad | (1 << 16);
    }

    public static implicit operator Id(OpLoad inst) => new Id(inst.ResultId);
    public static implicit operator int (OpLoad inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLoad(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memoryaccess")
                if (o.Words.Length > 0)
                    Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }

        DataIndex = index;
    }

    public OpLoad(int resultType, int resultId, int pointer, MemoryAccessMask? memoryaccess)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoad, ResultType, ResultId, Pointer, ..Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLoad(OpDataIndex odi) => new(odi);
}

public struct OpStore : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStore()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStore | (1 << 16);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpStore(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "objectId")
                ObjectId = o.ToLiteral<int>();
            else if (o.Name == "memoryaccess")
                if (o.Words.Length > 0)
                    Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }

        DataIndex = index;
    }

    public OpStore(int pointer, int objectId, MemoryAccessMask? memoryaccess)
    {
        Pointer = pointer;
        ObjectId = objectId;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStore, Pointer, ObjectId, ..Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpStore(OpDataIndex odi) => new(odi);
}

public struct OpAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAccessChain | (1 << 16);
    }

    public static implicit operator Id(OpAccessChain inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAccessChain inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAccessChain(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpAccessChain(int resultType, int resultId, int baseId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAccessChain, ResultType, ResultId, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAccessChain(OpDataIndex odi) => new(odi);
}

public struct OpInBoundsAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpInBoundsAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpInBoundsAccessChain | (1 << 16);
    }

    public static implicit operator Id(OpInBoundsAccessChain inst) => new Id(inst.ResultId);
    public static implicit operator int (OpInBoundsAccessChain inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpInBoundsAccessChain(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpInBoundsAccessChain(int resultType, int resultId, int baseId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpInBoundsAccessChain, ResultType, ResultId, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpInBoundsAccessChain(OpDataIndex odi) => new(odi);
}

public struct OpPtrAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrAccessChain | (1 << 16);
    }

    public static implicit operator Id(OpPtrAccessChain inst) => new Id(inst.ResultId);
    public static implicit operator int (OpPtrAccessChain inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpPtrAccessChain(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "element")
                Element = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpPtrAccessChain(int resultType, int resultId, int baseId, int element, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Element = element;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrAccessChain, ResultType, ResultId, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrAccessChain(OpDataIndex odi) => new(odi);
}

public struct OpArrayLength : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArrayLength()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArrayLength | (1 << 16);
    }

    public static implicit operator Id(OpArrayLength inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArrayLength inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Structure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arraymember
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArrayLength(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "structure")
                Structure = o.ToLiteral<int>();
            else if (o.Name == "arraymember")
                Arraymember = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArrayLength(int resultType, int resultId, int structure, int arraymember)
    {
        ResultType = resultType;
        ResultId = resultId;
        Structure = structure;
        Arraymember = arraymember;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArrayLength, ResultType, ResultId, Structure, ..Arraymember.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArrayLength(OpDataIndex odi) => new(odi);
}

public struct OpGenericPtrMemSemantics : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericPtrMemSemantics()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericPtrMemSemantics | (1 << 16);
    }

    public static implicit operator Id(OpGenericPtrMemSemantics inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGenericPtrMemSemantics inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGenericPtrMemSemantics(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGenericPtrMemSemantics(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericPtrMemSemantics, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGenericPtrMemSemantics(OpDataIndex odi) => new(odi);
}

public struct OpInBoundsPtrAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpInBoundsPtrAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpInBoundsPtrAccessChain | (1 << 16);
    }

    public static implicit operator Id(OpInBoundsPtrAccessChain inst) => new Id(inst.ResultId);
    public static implicit operator int (OpInBoundsPtrAccessChain inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpInBoundsPtrAccessChain(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "element")
                Element = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpInBoundsPtrAccessChain(int resultType, int resultId, int baseId, int element, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Element = element;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpInBoundsPtrAccessChain, ResultType, ResultId, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpInBoundsPtrAccessChain(OpDataIndex odi) => new(odi);
}

public struct OpDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? AdditionalInteger
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? AdditionalInteger2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorate(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "target")
                Target = o.ToLiteral<int>();
            else if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
            else if (o.Name == "additionalInteger")
                AdditionalInteger = o.ToLiteral<int?>();
            else if (o.Name == "additionalInteger2")
                AdditionalInteger2 = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpDecorate(int target, Decoration decoration, int? additionalInteger = null, int? additionalInteger2 = null)
    {
        Target = target;
        Decoration = decoration;
        AdditionalInteger = additionalInteger;
        AdditionalInteger2 = additionalInteger2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorate, Target, (int)Decoration, ..AdditionalInteger.AsDisposableLiteralValue().Words, ..AdditionalInteger2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDecorate(OpDataIndex odi) => new(odi);
}

public struct OpMemberDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int StructureType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? AdditionalInteger
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? AdditionalInteger2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberDecorate(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "structureType")
                StructureType = o.ToLiteral<int>();
            else if (o.Name == "member")
                Member = o.ToLiteral<int>();
            else if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
            else if (o.Name == "additionalInteger")
                AdditionalInteger = o.ToLiteral<int?>();
            else if (o.Name == "additionalInteger2")
                AdditionalInteger2 = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpMemberDecorate(int structureType, int member, Decoration decoration, int? additionalInteger = null, int? additionalInteger2 = null)
    {
        StructureType = structureType;
        Member = member;
        Decoration = decoration;
        AdditionalInteger = additionalInteger;
        AdditionalInteger2 = additionalInteger2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberDecorate, StructureType, ..Member.AsDisposableLiteralValue().Words, (int)Decoration, ..AdditionalInteger.AsDisposableLiteralValue().Words, ..AdditionalInteger2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemberDecorate(OpDataIndex odi) => new(odi);
}

public struct OpDecorationGroup : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorationGroup()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorationGroup | (1 << 16);
    }

    public static implicit operator Id(OpDecorationGroup inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDecorationGroup inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorationGroup(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDecorationGroup(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorationGroup, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDecorationGroup(OpDataIndex odi) => new(odi);
}

public struct OpGroupDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int DecorationGroup
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? AdditionalInteger
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? AdditionalInteger2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupDecorate(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "decorationGroup")
                DecorationGroup = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
            else if (o.Name == "additionalInteger")
                AdditionalInteger = o.ToLiteral<int?>();
            else if (o.Name == "additionalInteger2")
                AdditionalInteger2 = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupDecorate(int decorationGroup, LiteralArray<int> values, int? additionalInteger = null, int? additionalInteger2 = null)
    {
        DecorationGroup = decorationGroup;
        Values.Assign(values);
        AdditionalInteger = additionalInteger;
        AdditionalInteger2 = additionalInteger2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupDecorate, DecorationGroup, ..Values.Words, ..AdditionalInteger.AsDisposableLiteralValue().Words, ..AdditionalInteger2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupDecorate(OpDataIndex odi) => new(odi);
}

public struct OpGroupMemberDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int DecorationGroup
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? AdditionalInteger
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? AdditionalInteger2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupMemberDecorate(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "decorationGroup")
                DecorationGroup = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<(int, int)>();
            else if (o.Name == "additionalInteger")
                AdditionalInteger = o.ToLiteral<int?>();
            else if (o.Name == "additionalInteger2")
                AdditionalInteger2 = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupMemberDecorate(int decorationGroup, LiteralArray<(int, int)> values, int? additionalInteger = null, int? additionalInteger2 = null)
    {
        DecorationGroup = decorationGroup;
        Values.Assign(values);
        AdditionalInteger = additionalInteger;
        AdditionalInteger2 = additionalInteger2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupMemberDecorate, DecorationGroup, ..Values.Words, ..AdditionalInteger.AsDisposableLiteralValue().Words, ..AdditionalInteger2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupMemberDecorate(OpDataIndex odi) => new(odi);
}

public struct OpVectorExtractDynamic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorExtractDynamic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorExtractDynamic | (1 << 16);
    }

    public static implicit operator Id(OpVectorExtractDynamic inst) => new Id(inst.ResultId);
    public static implicit operator int (OpVectorExtractDynamic inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpVectorExtractDynamic(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector")
                Vector = o.ToLiteral<int>();
            else if (o.Name == "index")
                Index = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpVectorExtractDynamic(int resultType, int resultId, int vector, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorExtractDynamic, ResultType, ResultId, Vector, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorExtractDynamic(OpDataIndex odi) => new(odi);
}

public struct OpVectorInsertDynamic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorInsertDynamic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorInsertDynamic | (1 << 16);
    }

    public static implicit operator Id(OpVectorInsertDynamic inst) => new Id(inst.ResultId);
    public static implicit operator int (OpVectorInsertDynamic inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpVectorInsertDynamic(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector")
                Vector = o.ToLiteral<int>();
            else if (o.Name == "component")
                Component = o.ToLiteral<int>();
            else if (o.Name == "index")
                Index = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpVectorInsertDynamic(int resultType, int resultId, int vector, int component, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Component = component;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorInsertDynamic, ResultType, ResultId, Vector, Component, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorInsertDynamic(OpDataIndex odi) => new(odi);
}

public struct OpVectorShuffle : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorShuffle()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorShuffle | (1 << 16);
    }

    public static implicit operator Id(OpVectorShuffle inst) => new Id(inst.ResultId);
    public static implicit operator int (OpVectorShuffle inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpVectorShuffle(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpVectorShuffle(int resultType, int resultId, int vector1, int vector2, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorShuffle, ResultType, ResultId, Vector1, Vector2, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorShuffle(OpDataIndex odi) => new(odi);
}

public struct OpCompositeConstruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstruct | (1 << 16);
    }

    public static implicit operator Id(OpCompositeConstruct inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCompositeConstruct inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCompositeConstruct(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpCompositeConstruct(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstruct, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeConstruct(OpDataIndex odi) => new(odi);
}

public struct OpCompositeExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeExtract | (1 << 16);
    }

    public static implicit operator Id(OpCompositeExtract inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCompositeExtract inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Composite
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCompositeExtract(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "composite")
                Composite = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpCompositeExtract(int resultType, int resultId, int composite, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Composite = composite;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeExtract, ResultType, ResultId, Composite, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeExtract(OpDataIndex odi) => new(odi);
}

public struct OpCompositeInsert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeInsert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeInsert | (1 << 16);
    }

    public static implicit operator Id(OpCompositeInsert inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCompositeInsert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Composite
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCompositeInsert(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "objectId")
                ObjectId = o.ToLiteral<int>();
            else if (o.Name == "composite")
                Composite = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpCompositeInsert(int resultType, int resultId, int objectId, int composite, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        ObjectId = objectId;
        Composite = composite;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeInsert, ResultType, ResultId, ObjectId, Composite, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeInsert(OpDataIndex odi) => new(odi);
}

public struct OpCopyObject : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCopyObject()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCopyObject | (1 << 16);
    }

    public static implicit operator Id(OpCopyObject inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCopyObject inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCopyObject(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCopyObject(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCopyObject, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCopyObject(OpDataIndex odi) => new(odi);
}

public struct OpTranspose : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTranspose()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTranspose | (1 << 16);
    }

    public static implicit operator Id(OpTranspose inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTranspose inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTranspose(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "matrix")
                Matrix = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTranspose(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTranspose, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTranspose(OpDataIndex odi) => new(odi);
}

public struct OpSampledImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSampledImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSampledImage | (1 << 16);
    }

    public static implicit operator Id(OpSampledImage inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSampledImage inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampler
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSampledImage(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "sampler")
                Sampler = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSampledImage(int resultType, int resultId, int image, int sampler)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Sampler = sampler;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSampledImage, ResultType, ResultId, Image, Sampler];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSampledImage(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleImplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleImplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleImplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleExplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleExplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleExplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleExplicitLod, ResultType, ResultId, SampledImage, Coordinate, (int)Imageoperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleDrefImplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleDrefImplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleDrefImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleDrefImplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleDrefImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleDrefExplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleDrefExplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleDrefExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleDrefExplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, (int)Imageoperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleDrefExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleProjImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjImplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleProjImplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleProjImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleProjImplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleProjImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleProjImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleProjExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjExplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleProjExplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleProjExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleProjExplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleProjExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjExplicitLod, ResultType, ResultId, SampledImage, Coordinate, (int)Imageoperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleProjExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleProjDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjDrefImplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleProjDrefImplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleProjDrefImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleProjDrefImplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleProjDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleProjDrefImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleProjDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjDrefExplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleProjDrefExplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleProjDrefExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleProjDrefExplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleProjDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, (int)Imageoperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleProjDrefExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageFetch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageFetch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageFetch | (1 << 16);
    }

    public static implicit operator Id(OpImageFetch inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageFetch inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageFetch(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageFetch(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageFetch, ResultType, ResultId, Image, Coordinate, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageFetch(OpDataIndex odi) => new(odi);
}

public struct OpImageGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageGather | (1 << 16);
    }

    public static implicit operator Id(OpImageGather inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageGather inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageGather(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "component")
                Component = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageGather(int resultType, int resultId, int sampledImage, int coordinate, int component, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Component = component;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageGather, ResultType, ResultId, SampledImage, Coordinate, Component, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageGather(OpDataIndex odi) => new(odi);
}

public struct OpImageDrefGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageDrefGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageDrefGather | (1 << 16);
    }

    public static implicit operator Id(OpImageDrefGather inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageDrefGather inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageDrefGather(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageDrefGather(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageDrefGather, ResultType, ResultId, SampledImage, Coordinate, Dref, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageDrefGather(OpDataIndex odi) => new(odi);
}

public struct OpImageRead : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageRead()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageRead | (1 << 16);
    }

    public static implicit operator Id(OpImageRead inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageRead inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageRead(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageRead(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageRead, ResultType, ResultId, Image, Coordinate, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageRead(OpDataIndex odi) => new(odi);
}

public struct OpImageWrite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageWrite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageWrite | (1 << 16);
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageWrite(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "texel")
                Texel = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageWrite(int image, int coordinate, int texel, ImageOperandsMask? imageoperands)
    {
        Image = image;
        Coordinate = coordinate;
        Texel = texel;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageWrite, Image, Coordinate, Texel, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageWrite(OpDataIndex odi) => new(odi);
}

public struct OpImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImage | (1 << 16);
    }

    public static implicit operator Id(OpImage inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImage inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImage(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImage(int resultType, int resultId, int sampledImage)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImage, ResultType, ResultId, SampledImage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImage(OpDataIndex odi) => new(odi);
}

public struct OpImageQueryFormat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryFormat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryFormat | (1 << 16);
    }

    public static implicit operator Id(OpImageQueryFormat inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageQueryFormat inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageQueryFormat(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageQueryFormat(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryFormat, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQueryFormat(OpDataIndex odi) => new(odi);
}

public struct OpImageQueryOrder : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryOrder()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryOrder | (1 << 16);
    }

    public static implicit operator Id(OpImageQueryOrder inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageQueryOrder inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageQueryOrder(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageQueryOrder(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryOrder, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQueryOrder(OpDataIndex odi) => new(odi);
}

public struct OpImageQuerySizeLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySizeLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySizeLod | (1 << 16);
    }

    public static implicit operator Id(OpImageQuerySizeLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageQuerySizeLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LevelofDetail
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageQuerySizeLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "levelofDetail")
                LevelofDetail = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageQuerySizeLod(int resultType, int resultId, int image, int levelofDetail)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        LevelofDetail = levelofDetail;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySizeLod, ResultType, ResultId, Image, LevelofDetail];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQuerySizeLod(OpDataIndex odi) => new(odi);
}

public struct OpImageQuerySize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySize | (1 << 16);
    }

    public static implicit operator Id(OpImageQuerySize inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageQuerySize inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageQuerySize(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageQuerySize(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySize, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQuerySize(OpDataIndex odi) => new(odi);
}

public struct OpImageQueryLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryLod | (1 << 16);
    }

    public static implicit operator Id(OpImageQueryLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageQueryLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageQueryLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageQueryLod(int resultType, int resultId, int sampledImage, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryLod, ResultType, ResultId, SampledImage, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQueryLod(OpDataIndex odi) => new(odi);
}

public struct OpImageQueryLevels : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryLevels()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryLevels | (1 << 16);
    }

    public static implicit operator Id(OpImageQueryLevels inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageQueryLevels inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageQueryLevels(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageQueryLevels(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryLevels, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQueryLevels(OpDataIndex odi) => new(odi);
}

public struct OpImageQuerySamples : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySamples()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySamples | (1 << 16);
    }

    public static implicit operator Id(OpImageQuerySamples inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageQuerySamples inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageQuerySamples(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageQuerySamples(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySamples, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQuerySamples(OpDataIndex odi) => new(odi);
}

public struct OpConvertFToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToU | (1 << 16);
    }

    public static implicit operator Id(OpConvertFToU inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertFToU inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertFToU(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "floatValue")
                FloatValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertFToU(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToU, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertFToU(OpDataIndex odi) => new(odi);
}

public struct OpConvertFToS : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToS()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToS | (1 << 16);
    }

    public static implicit operator Id(OpConvertFToS inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertFToS inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertFToS(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "floatValue")
                FloatValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertFToS(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToS, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertFToS(OpDataIndex odi) => new(odi);
}

public struct OpConvertSToF : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSToF()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSToF | (1 << 16);
    }

    public static implicit operator Id(OpConvertSToF inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertSToF inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertSToF(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "signedValue")
                SignedValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertSToF(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSToF, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertSToF(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToF : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToF()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToF | (1 << 16);
    }

    public static implicit operator Id(OpConvertUToF inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertUToF inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertUToF(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "unsignedValue")
                UnsignedValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertUToF(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToF, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToF(OpDataIndex odi) => new(odi);
}

public struct OpUConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUConvert | (1 << 16);
    }

    public static implicit operator Id(OpUConvert inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUConvert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUConvert(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "unsignedValue")
                UnsignedValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUConvert(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUConvert, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUConvert(OpDataIndex odi) => new(odi);
}

public struct OpSConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSConvert | (1 << 16);
    }

    public static implicit operator Id(OpSConvert inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSConvert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSConvert(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "signedValue")
                SignedValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSConvert(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSConvert, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSConvert(OpDataIndex odi) => new(odi);
}

public struct OpFConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFConvert | (1 << 16);
    }

    public static implicit operator Id(OpFConvert inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFConvert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFConvert(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "floatValue")
                FloatValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFConvert(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFConvert, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFConvert(OpDataIndex odi) => new(odi);
}

public struct OpQuantizeToF16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpQuantizeToF16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpQuantizeToF16 | (1 << 16);
    }

    public static implicit operator Id(OpQuantizeToF16 inst) => new Id(inst.ResultId);
    public static implicit operator int (OpQuantizeToF16 inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpQuantizeToF16(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpQuantizeToF16(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpQuantizeToF16, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpQuantizeToF16(OpDataIndex odi) => new(odi);
}

public struct OpConvertPtrToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertPtrToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertPtrToU | (1 << 16);
    }

    public static implicit operator Id(OpConvertPtrToU inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertPtrToU inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertPtrToU(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertPtrToU(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertPtrToU, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertPtrToU(OpDataIndex odi) => new(odi);
}

public struct OpSatConvertSToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSatConvertSToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSatConvertSToU | (1 << 16);
    }

    public static implicit operator Id(OpSatConvertSToU inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSatConvertSToU inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSatConvertSToU(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "signedValue")
                SignedValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSatConvertSToU(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSatConvertSToU, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSatConvertSToU(OpDataIndex odi) => new(odi);
}

public struct OpSatConvertUToS : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSatConvertUToS()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSatConvertUToS | (1 << 16);
    }

    public static implicit operator Id(OpSatConvertUToS inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSatConvertUToS inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSatConvertUToS(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "unsignedValue")
                UnsignedValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSatConvertUToS(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSatConvertUToS, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSatConvertUToS(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToPtr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToPtr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToPtr | (1 << 16);
    }

    public static implicit operator Id(OpConvertUToPtr inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertUToPtr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntegerValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertUToPtr(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "integerValue")
                IntegerValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertUToPtr(int resultType, int resultId, int integerValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        IntegerValue = integerValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToPtr, ResultType, ResultId, IntegerValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToPtr(OpDataIndex odi) => new(odi);
}

public struct OpPtrCastToGeneric : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrCastToGeneric()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrCastToGeneric | (1 << 16);
    }

    public static implicit operator Id(OpPtrCastToGeneric inst) => new Id(inst.ResultId);
    public static implicit operator int (OpPtrCastToGeneric inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpPtrCastToGeneric(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpPtrCastToGeneric(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrCastToGeneric, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrCastToGeneric(OpDataIndex odi) => new(odi);
}

public struct OpGenericCastToPtr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericCastToPtr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericCastToPtr | (1 << 16);
    }

    public static implicit operator Id(OpGenericCastToPtr inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGenericCastToPtr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGenericCastToPtr(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGenericCastToPtr(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericCastToPtr, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGenericCastToPtr(OpDataIndex odi) => new(odi);
}

public struct OpGenericCastToPtrExplicit : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericCastToPtrExplicit()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericCastToPtrExplicit | (1 << 16);
    }

    public static implicit operator Id(OpGenericCastToPtrExplicit inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGenericCastToPtrExplicit inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGenericCastToPtrExplicit(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "storage")
                Storage = o.ToEnum<StorageClass>();
        }

        DataIndex = index;
    }

    public OpGenericCastToPtrExplicit(int resultType, int resultId, int pointer, StorageClass storage)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Storage = storage;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericCastToPtrExplicit, ResultType, ResultId, Pointer, (int)Storage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGenericCastToPtrExplicit(OpDataIndex odi) => new(odi);
}

public struct OpBitcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitcast | (1 << 16);
    }

    public static implicit operator Id(OpBitcast inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitcast inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitcast(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitcast(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitcast, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitcast(OpDataIndex odi) => new(odi);
}

public struct OpSNegate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSNegate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSNegate | (1 << 16);
    }

    public static implicit operator Id(OpSNegate inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSNegate inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSNegate(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSNegate(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSNegate, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSNegate(OpDataIndex odi) => new(odi);
}

public struct OpFNegate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFNegate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFNegate | (1 << 16);
    }

    public static implicit operator Id(OpFNegate inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFNegate inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFNegate(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFNegate(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFNegate, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFNegate(OpDataIndex odi) => new(odi);
}

public struct OpIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAdd | (1 << 16);
    }

    public static implicit operator Id(OpIAdd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIAdd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIAdd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAdd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAdd(OpDataIndex odi) => new(odi);
}

public struct OpFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFAdd | (1 << 16);
    }

    public static implicit operator Id(OpFAdd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFAdd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFAdd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFAdd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFAdd(OpDataIndex odi) => new(odi);
}

public struct OpISub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISub | (1 << 16);
    }

    public static implicit operator Id(OpISub inst) => new Id(inst.ResultId);
    public static implicit operator int (OpISub inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpISub(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpISub(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISub, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpISub(OpDataIndex odi) => new(odi);
}

public struct OpFSub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFSub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFSub | (1 << 16);
    }

    public static implicit operator Id(OpFSub inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFSub inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFSub(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFSub(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFSub, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFSub(OpDataIndex odi) => new(odi);
}

public struct OpIMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIMul | (1 << 16);
    }

    public static implicit operator Id(OpIMul inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIMul inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIMul(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIMul(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIMul, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIMul(OpDataIndex odi) => new(odi);
}

public struct OpFMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFMul | (1 << 16);
    }

    public static implicit operator Id(OpFMul inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFMul inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFMul(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFMul(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFMul, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFMul(OpDataIndex odi) => new(odi);
}

public struct OpUDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDiv | (1 << 16);
    }

    public static implicit operator Id(OpUDiv inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUDiv inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUDiv(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUDiv(OpDataIndex odi) => new(odi);
}

public struct OpSDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDiv | (1 << 16);
    }

    public static implicit operator Id(OpSDiv inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSDiv inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDiv(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDiv(OpDataIndex odi) => new(odi);
}

public struct OpFDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFDiv | (1 << 16);
    }

    public static implicit operator Id(OpFDiv inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFDiv inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFDiv(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFDiv(OpDataIndex odi) => new(odi);
}

public struct OpUMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMod | (1 << 16);
    }

    public static implicit operator Id(OpUMod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUMod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUMod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUMod(OpDataIndex odi) => new(odi);
}

public struct OpSRem : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSRem()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSRem | (1 << 16);
    }

    public static implicit operator Id(OpSRem inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSRem inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSRem(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSRem(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSRem, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSRem(OpDataIndex odi) => new(odi);
}

public struct OpSMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSMod | (1 << 16);
    }

    public static implicit operator Id(OpSMod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSMod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSMod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSMod(OpDataIndex odi) => new(odi);
}

public struct OpFRem : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFRem()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFRem | (1 << 16);
    }

    public static implicit operator Id(OpFRem inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFRem inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFRem(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFRem(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFRem, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFRem(OpDataIndex odi) => new(odi);
}

public struct OpFMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFMod | (1 << 16);
    }

    public static implicit operator Id(OpFMod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFMod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFMod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFMod(OpDataIndex odi) => new(odi);
}

public struct OpVectorTimesScalar : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorTimesScalar()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorTimesScalar | (1 << 16);
    }

    public static implicit operator Id(OpVectorTimesScalar inst) => new Id(inst.ResultId);
    public static implicit operator int (OpVectorTimesScalar inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scalar
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpVectorTimesScalar(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector")
                Vector = o.ToLiteral<int>();
            else if (o.Name == "scalar")
                Scalar = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpVectorTimesScalar(int resultType, int resultId, int vector, int scalar)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Scalar = scalar;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorTimesScalar, ResultType, ResultId, Vector, Scalar];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorTimesScalar(OpDataIndex odi) => new(odi);
}

public struct OpMatrixTimesScalar : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesScalar()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesScalar | (1 << 16);
    }

    public static implicit operator Id(OpMatrixTimesScalar inst) => new Id(inst.ResultId);
    public static implicit operator int (OpMatrixTimesScalar inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scalar
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMatrixTimesScalar(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "matrix")
                Matrix = o.ToLiteral<int>();
            else if (o.Name == "scalar")
                Scalar = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpMatrixTimesScalar(int resultType, int resultId, int matrix, int scalar)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Scalar = scalar;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesScalar, ResultType, ResultId, Matrix, Scalar];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMatrixTimesScalar(OpDataIndex odi) => new(odi);
}

public struct OpVectorTimesMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorTimesMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorTimesMatrix | (1 << 16);
    }

    public static implicit operator Id(OpVectorTimesMatrix inst) => new Id(inst.ResultId);
    public static implicit operator int (OpVectorTimesMatrix inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpVectorTimesMatrix(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector")
                Vector = o.ToLiteral<int>();
            else if (o.Name == "matrix")
                Matrix = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpVectorTimesMatrix(int resultType, int resultId, int vector, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Matrix = matrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorTimesMatrix, ResultType, ResultId, Vector, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorTimesMatrix(OpDataIndex odi) => new(odi);
}

public struct OpMatrixTimesVector : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesVector()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesVector | (1 << 16);
    }

    public static implicit operator Id(OpMatrixTimesVector inst) => new Id(inst.ResultId);
    public static implicit operator int (OpMatrixTimesVector inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMatrixTimesVector(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "matrix")
                Matrix = o.ToLiteral<int>();
            else if (o.Name == "vector")
                Vector = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpMatrixTimesVector(int resultType, int resultId, int matrix, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Vector = vector;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesVector, ResultType, ResultId, Matrix, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMatrixTimesVector(OpDataIndex odi) => new(odi);
}

public struct OpMatrixTimesMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesMatrix | (1 << 16);
    }

    public static implicit operator Id(OpMatrixTimesMatrix inst) => new Id(inst.ResultId);
    public static implicit operator int (OpMatrixTimesMatrix inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftMatrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RightMatrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMatrixTimesMatrix(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "leftMatrix")
                LeftMatrix = o.ToLiteral<int>();
            else if (o.Name == "rightMatrix")
                RightMatrix = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpMatrixTimesMatrix(int resultType, int resultId, int leftMatrix, int rightMatrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        LeftMatrix = leftMatrix;
        RightMatrix = rightMatrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesMatrix, ResultType, ResultId, LeftMatrix, RightMatrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMatrixTimesMatrix(OpDataIndex odi) => new(odi);
}

public struct OpOuterProduct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpOuterProduct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpOuterProduct | (1 << 16);
    }

    public static implicit operator Id(OpOuterProduct inst) => new Id(inst.ResultId);
    public static implicit operator int (OpOuterProduct inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpOuterProduct(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpOuterProduct(int resultType, int resultId, int vector1, int vector2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpOuterProduct, ResultType, ResultId, Vector1, Vector2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpOuterProduct(OpDataIndex odi) => new(odi);
}

public struct OpDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDot | (1 << 16);
    }

    public static implicit operator Id(OpDot inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDot(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDot(int resultType, int resultId, int vector1, int vector2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDot, ResultType, ResultId, Vector1, Vector2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDot(OpDataIndex odi) => new(odi);
}

public struct OpIAddCarry : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAddCarry()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAddCarry | (1 << 16);
    }

    public static implicit operator Id(OpIAddCarry inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIAddCarry inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIAddCarry(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIAddCarry(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAddCarry, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAddCarry(OpDataIndex odi) => new(odi);
}

public struct OpISubBorrow : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISubBorrow()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISubBorrow | (1 << 16);
    }

    public static implicit operator Id(OpISubBorrow inst) => new Id(inst.ResultId);
    public static implicit operator int (OpISubBorrow inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpISubBorrow(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpISubBorrow(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISubBorrow, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpISubBorrow(OpDataIndex odi) => new(odi);
}

public struct OpUMulExtended : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMulExtended()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMulExtended | (1 << 16);
    }

    public static implicit operator Id(OpUMulExtended inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUMulExtended inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUMulExtended(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUMulExtended(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMulExtended, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUMulExtended(OpDataIndex odi) => new(odi);
}

public struct OpSMulExtended : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSMulExtended()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSMulExtended | (1 << 16);
    }

    public static implicit operator Id(OpSMulExtended inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSMulExtended inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSMulExtended(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSMulExtended(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSMulExtended, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSMulExtended(OpDataIndex odi) => new(odi);
}

public struct OpAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAny | (1 << 16);
    }

    public static implicit operator Id(OpAny inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAny inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAny(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector")
                Vector = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAny(int resultType, int resultId, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAny, ResultType, ResultId, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAny(OpDataIndex odi) => new(odi);
}

public struct OpAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAll | (1 << 16);
    }

    public static implicit operator Id(OpAll inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAll inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAll(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector")
                Vector = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAll(int resultType, int resultId, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAll, ResultType, ResultId, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAll(OpDataIndex odi) => new(odi);
}

public struct OpIsNan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNan | (1 << 16);
    }

    public static implicit operator Id(OpIsNan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIsNan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIsNan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIsNan(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNan, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsNan(OpDataIndex odi) => new(odi);
}

public struct OpIsInf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsInf()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsInf | (1 << 16);
    }

    public static implicit operator Id(OpIsInf inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIsInf inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIsInf(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIsInf(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsInf, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsInf(OpDataIndex odi) => new(odi);
}

public struct OpIsFinite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsFinite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsFinite | (1 << 16);
    }

    public static implicit operator Id(OpIsFinite inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIsFinite inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIsFinite(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIsFinite(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsFinite, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsFinite(OpDataIndex odi) => new(odi);
}

public struct OpIsNormal : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNormal()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNormal | (1 << 16);
    }

    public static implicit operator Id(OpIsNormal inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIsNormal inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIsNormal(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIsNormal(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNormal, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsNormal(OpDataIndex odi) => new(odi);
}

public struct OpSignBitSet : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSignBitSet()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSignBitSet | (1 << 16);
    }

    public static implicit operator Id(OpSignBitSet inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSignBitSet inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSignBitSet(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSignBitSet(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSignBitSet, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSignBitSet(OpDataIndex odi) => new(odi);
}

public struct OpLessOrGreater : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLessOrGreater()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLessOrGreater | (1 << 16);
    }

    public static implicit operator Id(OpLessOrGreater inst) => new Id(inst.ResultId);
    public static implicit operator int (OpLessOrGreater inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLessOrGreater(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
            else if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLessOrGreater(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLessOrGreater, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLessOrGreater(OpDataIndex odi) => new(odi);
}

public struct OpOrdered : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpOrdered()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpOrdered | (1 << 16);
    }

    public static implicit operator Id(OpOrdered inst) => new Id(inst.ResultId);
    public static implicit operator int (OpOrdered inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpOrdered(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
            else if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpOrdered(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpOrdered, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpOrdered(OpDataIndex odi) => new(odi);
}

public struct OpUnordered : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnordered()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUnordered | (1 << 16);
    }

    public static implicit operator Id(OpUnordered inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUnordered inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUnordered(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
            else if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUnordered(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUnordered, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUnordered(OpDataIndex odi) => new(odi);
}

public struct OpLogicalEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalEqual | (1 << 16);
    }

    public static implicit operator Id(OpLogicalEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpLogicalEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLogicalEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLogicalEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalEqual(OpDataIndex odi) => new(odi);
}

public struct OpLogicalNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalNotEqual | (1 << 16);
    }

    public static implicit operator Id(OpLogicalNotEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpLogicalNotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLogicalNotEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLogicalNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalNotEqual(OpDataIndex odi) => new(odi);
}

public struct OpLogicalOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalOr | (1 << 16);
    }

    public static implicit operator Id(OpLogicalOr inst) => new Id(inst.ResultId);
    public static implicit operator int (OpLogicalOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLogicalOr(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLogicalOr(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalOr, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalOr(OpDataIndex odi) => new(odi);
}

public struct OpLogicalAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalAnd | (1 << 16);
    }

    public static implicit operator Id(OpLogicalAnd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpLogicalAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLogicalAnd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLogicalAnd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalAnd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalAnd(OpDataIndex odi) => new(odi);
}

public struct OpLogicalNot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalNot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalNot | (1 << 16);
    }

    public static implicit operator Id(OpLogicalNot inst) => new Id(inst.ResultId);
    public static implicit operator int (OpLogicalNot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLogicalNot(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLogicalNot(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalNot, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalNot(OpDataIndex odi) => new(odi);
}

public struct OpSelect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSelect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSelect | (1 << 16);
    }

    public static implicit operator Id(OpSelect inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSelect inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Object1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Object2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSelect(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "condition")
                Condition = o.ToLiteral<int>();
            else if (o.Name == "object1")
                Object1 = o.ToLiteral<int>();
            else if (o.Name == "object2")
                Object2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSelect(int resultType, int resultId, int condition, int object1, int object2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Condition = condition;
        Object1 = object1;
        Object2 = object2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSelect, ResultType, ResultId, Condition, Object1, Object2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSelect(OpDataIndex odi) => new(odi);
}

public struct OpIEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIEqual | (1 << 16);
    }

    public static implicit operator Id(OpIEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIEqual(OpDataIndex odi) => new(odi);
}

public struct OpINotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpINotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpINotEqual | (1 << 16);
    }

    public static implicit operator Id(OpINotEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpINotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpINotEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpINotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpINotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpINotEqual(OpDataIndex odi) => new(odi);
}

public struct OpUGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUGreaterThan | (1 << 16);
    }

    public static implicit operator Id(OpUGreaterThan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUGreaterThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUGreaterThan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUGreaterThan(OpDataIndex odi) => new(odi);
}

public struct OpSGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSGreaterThan | (1 << 16);
    }

    public static implicit operator Id(OpSGreaterThan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSGreaterThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSGreaterThan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSGreaterThan(OpDataIndex odi) => new(odi);
}

public struct OpUGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUGreaterThanEqual | (1 << 16);
    }

    public static implicit operator Id(OpUGreaterThanEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUGreaterThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUGreaterThanEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpSGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSGreaterThanEqual | (1 << 16);
    }

    public static implicit operator Id(OpSGreaterThanEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSGreaterThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSGreaterThanEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpULessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpULessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpULessThan | (1 << 16);
    }

    public static implicit operator Id(OpULessThan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpULessThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpULessThan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpULessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpULessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpULessThan(OpDataIndex odi) => new(odi);
}

public struct OpSLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSLessThan | (1 << 16);
    }

    public static implicit operator Id(OpSLessThan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSLessThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSLessThan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSLessThan(OpDataIndex odi) => new(odi);
}

public struct OpULessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpULessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpULessThanEqual | (1 << 16);
    }

    public static implicit operator Id(OpULessThanEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpULessThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpULessThanEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpULessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpULessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpULessThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpSLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSLessThanEqual | (1 << 16);
    }

    public static implicit operator Id(OpSLessThanEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSLessThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSLessThanEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSLessThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpFOrdEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdEqual | (1 << 16);
    }

    public static implicit operator Id(OpFOrdEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFOrdEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFOrdEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFOrdEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdEqual(OpDataIndex odi) => new(odi);
}

public struct OpFUnordEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordEqual | (1 << 16);
    }

    public static implicit operator Id(OpFUnordEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFUnordEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFUnordEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFUnordEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordEqual(OpDataIndex odi) => new(odi);
}

public struct OpFOrdNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdNotEqual | (1 << 16);
    }

    public static implicit operator Id(OpFOrdNotEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFOrdNotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFOrdNotEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFOrdNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdNotEqual(OpDataIndex odi) => new(odi);
}

public struct OpFUnordNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordNotEqual | (1 << 16);
    }

    public static implicit operator Id(OpFUnordNotEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFUnordNotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFUnordNotEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFUnordNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordNotEqual(OpDataIndex odi) => new(odi);
}

public struct OpFOrdLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdLessThan | (1 << 16);
    }

    public static implicit operator Id(OpFOrdLessThan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFOrdLessThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFOrdLessThan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFOrdLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdLessThan(OpDataIndex odi) => new(odi);
}

public struct OpFUnordLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordLessThan | (1 << 16);
    }

    public static implicit operator Id(OpFUnordLessThan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFUnordLessThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFUnordLessThan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFUnordLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordLessThan(OpDataIndex odi) => new(odi);
}

public struct OpFOrdGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdGreaterThan | (1 << 16);
    }

    public static implicit operator Id(OpFOrdGreaterThan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFOrdGreaterThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFOrdGreaterThan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFOrdGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdGreaterThan(OpDataIndex odi) => new(odi);
}

public struct OpFUnordGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordGreaterThan | (1 << 16);
    }

    public static implicit operator Id(OpFUnordGreaterThan inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFUnordGreaterThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFUnordGreaterThan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFUnordGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordGreaterThan(OpDataIndex odi) => new(odi);
}

public struct OpFOrdLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdLessThanEqual | (1 << 16);
    }

    public static implicit operator Id(OpFOrdLessThanEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFOrdLessThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFOrdLessThanEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFOrdLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdLessThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpFUnordLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordLessThanEqual | (1 << 16);
    }

    public static implicit operator Id(OpFUnordLessThanEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFUnordLessThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFUnordLessThanEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFUnordLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordLessThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpFOrdGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdGreaterThanEqual | (1 << 16);
    }

    public static implicit operator Id(OpFOrdGreaterThanEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFOrdGreaterThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFOrdGreaterThanEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFOrdGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpFUnordGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordGreaterThanEqual | (1 << 16);
    }

    public static implicit operator Id(OpFUnordGreaterThanEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFUnordGreaterThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFUnordGreaterThanEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFUnordGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpShiftRightLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftRightLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftRightLogical | (1 << 16);
    }

    public static implicit operator Id(OpShiftRightLogical inst) => new Id(inst.ResultId);
    public static implicit operator int (OpShiftRightLogical inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpShiftRightLogical(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "shift")
                Shift = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpShiftRightLogical(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftRightLogical, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpShiftRightLogical(OpDataIndex odi) => new(odi);
}

public struct OpShiftRightArithmetic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftRightArithmetic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftRightArithmetic | (1 << 16);
    }

    public static implicit operator Id(OpShiftRightArithmetic inst) => new Id(inst.ResultId);
    public static implicit operator int (OpShiftRightArithmetic inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpShiftRightArithmetic(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "shift")
                Shift = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpShiftRightArithmetic(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftRightArithmetic, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpShiftRightArithmetic(OpDataIndex odi) => new(odi);
}

public struct OpShiftLeftLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftLeftLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftLeftLogical | (1 << 16);
    }

    public static implicit operator Id(OpShiftLeftLogical inst) => new Id(inst.ResultId);
    public static implicit operator int (OpShiftLeftLogical inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpShiftLeftLogical(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "shift")
                Shift = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpShiftLeftLogical(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftLeftLogical, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpShiftLeftLogical(OpDataIndex odi) => new(odi);
}

public struct OpBitwiseOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseOr | (1 << 16);
    }

    public static implicit operator Id(OpBitwiseOr inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitwiseOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitwiseOr(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitwiseOr(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseOr, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitwiseOr(OpDataIndex odi) => new(odi);
}

public struct OpBitwiseXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseXor | (1 << 16);
    }

    public static implicit operator Id(OpBitwiseXor inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitwiseXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitwiseXor(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitwiseXor(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseXor, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitwiseXor(OpDataIndex odi) => new(odi);
}

public struct OpBitwiseAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseAnd | (1 << 16);
    }

    public static implicit operator Id(OpBitwiseAnd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitwiseAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitwiseAnd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitwiseAnd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseAnd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitwiseAnd(OpDataIndex odi) => new(odi);
}

public struct OpNot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNot | (1 << 16);
    }

    public static implicit operator Id(OpNot inst) => new Id(inst.ResultId);
    public static implicit operator int (OpNot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpNot(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpNot(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNot, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpNot(OpDataIndex odi) => new(odi);
}

public struct OpBitFieldInsert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldInsert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldInsert | (1 << 16);
    }

    public static implicit operator Id(OpBitFieldInsert inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitFieldInsert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Insert
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitFieldInsert(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "insert")
                Insert = o.ToLiteral<int>();
            else if (o.Name == "offset")
                Offset = o.ToLiteral<int>();
            else if (o.Name == "count")
                Count = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitFieldInsert(int resultType, int resultId, int baseId, int insert, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Insert = insert;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldInsert, ResultType, ResultId, BaseId, Insert, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitFieldInsert(OpDataIndex odi) => new(odi);
}

public struct OpBitFieldSExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldSExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldSExtract | (1 << 16);
    }

    public static implicit operator Id(OpBitFieldSExtract inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitFieldSExtract inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitFieldSExtract(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "offset")
                Offset = o.ToLiteral<int>();
            else if (o.Name == "count")
                Count = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitFieldSExtract(int resultType, int resultId, int baseId, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldSExtract, ResultType, ResultId, BaseId, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitFieldSExtract(OpDataIndex odi) => new(odi);
}

public struct OpBitFieldUExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldUExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldUExtract | (1 << 16);
    }

    public static implicit operator Id(OpBitFieldUExtract inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitFieldUExtract inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitFieldUExtract(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "offset")
                Offset = o.ToLiteral<int>();
            else if (o.Name == "count")
                Count = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitFieldUExtract(int resultType, int resultId, int baseId, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldUExtract, ResultType, ResultId, BaseId, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitFieldUExtract(OpDataIndex odi) => new(odi);
}

public struct OpBitReverse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitReverse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitReverse | (1 << 16);
    }

    public static implicit operator Id(OpBitReverse inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitReverse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitReverse(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitReverse(int resultType, int resultId, int baseId)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitReverse, ResultType, ResultId, BaseId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitReverse(OpDataIndex odi) => new(odi);
}

public struct OpBitCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitCount | (1 << 16);
    }

    public static implicit operator Id(OpBitCount inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBitCount inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBitCount(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBitCount(int resultType, int resultId, int baseId)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitCount, ResultType, ResultId, BaseId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitCount(OpDataIndex odi) => new(odi);
}

public struct OpDPdx : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdx()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdx | (1 << 16);
    }

    public static implicit operator Id(OpDPdx inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDPdx inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDPdx(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDPdx(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdx, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdx(OpDataIndex odi) => new(odi);
}

public struct OpDPdy : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdy()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdy | (1 << 16);
    }

    public static implicit operator Id(OpDPdy inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDPdy inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDPdy(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDPdy(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdy, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdy(OpDataIndex odi) => new(odi);
}

public struct OpFwidth : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidth()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidth | (1 << 16);
    }

    public static implicit operator Id(OpFwidth inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFwidth inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFwidth(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFwidth(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidth, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFwidth(OpDataIndex odi) => new(odi);
}

public struct OpDPdxFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdxFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdxFine | (1 << 16);
    }

    public static implicit operator Id(OpDPdxFine inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDPdxFine inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDPdxFine(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDPdxFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdxFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdxFine(OpDataIndex odi) => new(odi);
}

public struct OpDPdyFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdyFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdyFine | (1 << 16);
    }

    public static implicit operator Id(OpDPdyFine inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDPdyFine inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDPdyFine(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDPdyFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdyFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdyFine(OpDataIndex odi) => new(odi);
}

public struct OpFwidthFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidthFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidthFine | (1 << 16);
    }

    public static implicit operator Id(OpFwidthFine inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFwidthFine inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFwidthFine(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFwidthFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidthFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFwidthFine(OpDataIndex odi) => new(odi);
}

public struct OpDPdxCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdxCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdxCoarse | (1 << 16);
    }

    public static implicit operator Id(OpDPdxCoarse inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDPdxCoarse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDPdxCoarse(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDPdxCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdxCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdxCoarse(OpDataIndex odi) => new(odi);
}

public struct OpDPdyCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdyCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdyCoarse | (1 << 16);
    }

    public static implicit operator Id(OpDPdyCoarse inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDPdyCoarse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDPdyCoarse(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDPdyCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdyCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdyCoarse(OpDataIndex odi) => new(odi);
}

public struct OpFwidthCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidthCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidthCoarse | (1 << 16);
    }

    public static implicit operator Id(OpFwidthCoarse inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFwidthCoarse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFwidthCoarse(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFwidthCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidthCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFwidthCoarse(OpDataIndex odi) => new(odi);
}

public struct OpEmitVertex : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitVertex()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitVertex | (1 << 16);
    }

    public OpEmitVertex(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpEmitVertex(OpDataIndex odi) => new(odi);
}

public struct OpEndPrimitive : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndPrimitive()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndPrimitive | (1 << 16);
    }

    public OpEndPrimitive(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpEndPrimitive(OpDataIndex odi) => new(odi);
}

public struct OpEmitStreamVertex : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitStreamVertex()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitStreamVertex | (1 << 16);
    }

    public int Stream
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEmitStreamVertex(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "stream")
                Stream = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpEmitStreamVertex(int stream)
    {
        Stream = stream;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEmitStreamVertex, Stream];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEmitStreamVertex(OpDataIndex odi) => new(odi);
}

public struct OpEndStreamPrimitive : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndStreamPrimitive()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndStreamPrimitive | (1 << 16);
    }

    public int Stream
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEndStreamPrimitive(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "stream")
                Stream = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpEndStreamPrimitive(int stream)
    {
        Stream = stream;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEndStreamPrimitive, Stream];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEndStreamPrimitive(OpDataIndex odi) => new(odi);
}

public struct OpControlBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrier | (1 << 16);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrier(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpControlBarrier(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrier, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpControlBarrier(OpDataIndex odi) => new(odi);
}

public struct OpMemoryBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryBarrier | (1 << 16);
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryBarrier(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpMemoryBarrier(int memory, int semantics)
    {
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryBarrier, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemoryBarrier(OpDataIndex odi) => new(odi);
}

public struct OpAtomicLoad : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicLoad()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicLoad | (1 << 16);
    }

    public static implicit operator Id(OpAtomicLoad inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicLoad inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicLoad(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicLoad(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicLoad, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicLoad(OpDataIndex odi) => new(odi);
}

public struct OpAtomicStore : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicStore()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicStore | (1 << 16);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicStore(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicStore(int pointer, int memory, int semantics, int value)
    {
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicStore, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicStore(OpDataIndex odi) => new(odi);
}

public struct OpAtomicExchange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicExchange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicExchange | (1 << 16);
    }

    public static implicit operator Id(OpAtomicExchange inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicExchange inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicExchange(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicExchange(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicExchange, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicExchange(OpDataIndex odi) => new(odi);
}

public struct OpAtomicCompareExchange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicCompareExchange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicCompareExchange | (1 << 16);
    }

    public static implicit operator Id(OpAtomicCompareExchange inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicCompareExchange inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Equal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Unequal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Comparator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicCompareExchange(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "equal")
                Equal = o.ToLiteral<int>();
            else if (o.Name == "unequal")
                Unequal = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "comparator")
                Comparator = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicCompareExchange(int resultType, int resultId, int pointer, int memory, int equal, int unequal, int value, int comparator)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Equal = equal;
        Unequal = unequal;
        Value = value;
        Comparator = comparator;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicCompareExchange, ResultType, ResultId, Pointer, Memory, Equal, Unequal, Value, Comparator];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicCompareExchange(OpDataIndex odi) => new(odi);
}

public struct OpAtomicCompareExchangeWeak : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicCompareExchangeWeak()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicCompareExchangeWeak | (1 << 16);
    }

    public static implicit operator Id(OpAtomicCompareExchangeWeak inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicCompareExchangeWeak inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Equal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Unequal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Comparator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicCompareExchangeWeak(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "equal")
                Equal = o.ToLiteral<int>();
            else if (o.Name == "unequal")
                Unequal = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "comparator")
                Comparator = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicCompareExchangeWeak(int resultType, int resultId, int pointer, int memory, int equal, int unequal, int value, int comparator)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Equal = equal;
        Unequal = unequal;
        Value = value;
        Comparator = comparator;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicCompareExchangeWeak, ResultType, ResultId, Pointer, Memory, Equal, Unequal, Value, Comparator];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicCompareExchangeWeak(OpDataIndex odi) => new(odi);
}

public struct OpAtomicIIncrement : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIIncrement()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIIncrement | (1 << 16);
    }

    public static implicit operator Id(OpAtomicIIncrement inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicIIncrement inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicIIncrement(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicIIncrement(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIIncrement, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicIIncrement(OpDataIndex odi) => new(odi);
}

public struct OpAtomicIDecrement : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIDecrement()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIDecrement | (1 << 16);
    }

    public static implicit operator Id(OpAtomicIDecrement inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicIDecrement inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicIDecrement(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicIDecrement(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIDecrement, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicIDecrement(OpDataIndex odi) => new(odi);
}

public struct OpAtomicIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIAdd | (1 << 16);
    }

    public static implicit operator Id(OpAtomicIAdd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicIAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicIAdd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicIAdd(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIAdd, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicIAdd(OpDataIndex odi) => new(odi);
}

public struct OpAtomicISub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicISub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicISub | (1 << 16);
    }

    public static implicit operator Id(OpAtomicISub inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicISub inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicISub(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicISub(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicISub, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicISub(OpDataIndex odi) => new(odi);
}

public struct OpAtomicSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicSMin | (1 << 16);
    }

    public static implicit operator Id(OpAtomicSMin inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicSMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicSMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicSMin(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicSMin, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicSMin(OpDataIndex odi) => new(odi);
}

public struct OpAtomicUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicUMin | (1 << 16);
    }

    public static implicit operator Id(OpAtomicUMin inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicUMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicUMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicUMin(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicUMin, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicUMin(OpDataIndex odi) => new(odi);
}

public struct OpAtomicSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicSMax | (1 << 16);
    }

    public static implicit operator Id(OpAtomicSMax inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicSMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicSMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicSMax(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicSMax, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicSMax(OpDataIndex odi) => new(odi);
}

public struct OpAtomicUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicUMax | (1 << 16);
    }

    public static implicit operator Id(OpAtomicUMax inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicUMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicUMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicUMax(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicUMax, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicUMax(OpDataIndex odi) => new(odi);
}

public struct OpAtomicAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicAnd | (1 << 16);
    }

    public static implicit operator Id(OpAtomicAnd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicAnd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicAnd(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicAnd, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicAnd(OpDataIndex odi) => new(odi);
}

public struct OpAtomicOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicOr | (1 << 16);
    }

    public static implicit operator Id(OpAtomicOr inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicOr(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicOr(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicOr, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicOr(OpDataIndex odi) => new(odi);
}

public struct OpAtomicXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicXor | (1 << 16);
    }

    public static implicit operator Id(OpAtomicXor inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicXor(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicXor(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicXor, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicXor(OpDataIndex odi) => new(odi);
}

public struct OpPhi : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPhi()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPhi | (1 << 16);
    }

    public static implicit operator Id(OpPhi inst) => new Id(inst.ResultId);
    public static implicit operator int (OpPhi inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpPhi(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<(int, int)>();
        }

        DataIndex = index;
    }

    public OpPhi(int resultType, int resultId, LiteralArray<(int, int)> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPhi, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPhi(OpDataIndex odi) => new(odi);
}

public struct OpLoopMerge : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoopMerge()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoopMerge | (1 << 16);
    }

    public int MergeBlock
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ContinueTarget
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LoopControlMask Loopcontrol
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLoopMerge(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "mergeBlock")
                MergeBlock = o.ToLiteral<int>();
            else if (o.Name == "continueTarget")
                ContinueTarget = o.ToLiteral<int>();
            else if (o.Name == "loopcontrol")
                Loopcontrol = o.ToEnum<LoopControlMask>();
        }

        DataIndex = index;
    }

    public OpLoopMerge(int mergeBlock, int continueTarget, LoopControlMask loopcontrol)
    {
        MergeBlock = mergeBlock;
        ContinueTarget = continueTarget;
        Loopcontrol = loopcontrol;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoopMerge, MergeBlock, ContinueTarget, (int)Loopcontrol];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLoopMerge(OpDataIndex odi) => new(odi);
}

public struct OpSelectionMerge : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSelectionMerge()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSelectionMerge | (1 << 16);
    }

    public int MergeBlock
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SelectionControlMask Selectioncontrol
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSelectionMerge(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "mergeBlock")
                MergeBlock = o.ToLiteral<int>();
            else if (o.Name == "selectioncontrol")
                Selectioncontrol = o.ToEnum<SelectionControlMask>();
        }

        DataIndex = index;
    }

    public OpSelectionMerge(int mergeBlock, SelectionControlMask selectioncontrol)
    {
        MergeBlock = mergeBlock;
        Selectioncontrol = selectioncontrol;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSelectionMerge, MergeBlock, (int)Selectioncontrol];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSelectionMerge(OpDataIndex odi) => new(odi);
}

public struct OpLabel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLabel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLabel | (1 << 16);
    }

    public static implicit operator Id(OpLabel inst) => new Id(inst.ResultId);
    public static implicit operator int (OpLabel inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLabel(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLabel(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLabel, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLabel(OpDataIndex odi) => new(odi);
}

public struct OpBranch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBranch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBranch | (1 << 16);
    }

    public int TargetLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBranch(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "targetLabel")
                TargetLabel = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBranch(int targetLabel)
    {
        TargetLabel = targetLabel;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBranch, TargetLabel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBranch(OpDataIndex odi) => new(odi);
}

public struct OpBranchConditional : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBranchConditional()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBranchConditional | (1 << 16);
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TrueLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FalseLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBranchConditional(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "condition")
                Condition = o.ToLiteral<int>();
            else if (o.Name == "trueLabel")
                TrueLabel = o.ToLiteral<int>();
            else if (o.Name == "falseLabel")
                FalseLabel = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpBranchConditional(int condition, int trueLabel, int falseLabel, LiteralArray<int> values)
    {
        Condition = condition;
        TrueLabel = trueLabel;
        FalseLabel = falseLabel;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBranchConditional, Condition, TrueLabel, FalseLabel, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBranchConditional(OpDataIndex odi) => new(odi);
}

public struct OpSwitch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSwitch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSwitch | (1 << 16);
    }

    public int Selector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DefaultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSwitch(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "selector")
                Selector = o.ToLiteral<int>();
            else if (o.Name == "defaultId")
                DefaultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<(int, int)>();
        }

        DataIndex = index;
    }

    public OpSwitch(int selector, int defaultId, LiteralArray<(int, int)> values)
    {
        Selector = selector;
        DefaultId = defaultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSwitch, Selector, DefaultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSwitch(OpDataIndex odi) => new(odi);
}

public struct OpKill : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpKill()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpKill | (1 << 16);
    }

    public OpKill(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpKill(OpDataIndex odi) => new(odi);
}

public struct OpReturn : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReturn()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReturn | (1 << 16);
    }

    public OpReturn(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpReturn(OpDataIndex odi) => new(odi);
}

public struct OpReturnValue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReturnValue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReturnValue | (1 << 16);
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReturnValue(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReturnValue(int value)
    {
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReturnValue, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReturnValue(OpDataIndex odi) => new(odi);
}

public struct OpUnreachable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnreachable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUnreachable | (1 << 16);
    }

    public OpUnreachable(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpUnreachable(OpDataIndex odi) => new(odi);
}

public struct OpLifetimeStart : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLifetimeStart()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLifetimeStart | (1 << 16);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Size
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLifetimeStart(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "size")
                Size = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLifetimeStart(int pointer, int size)
    {
        Pointer = pointer;
        Size = size;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLifetimeStart, Pointer, ..Size.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLifetimeStart(OpDataIndex odi) => new(odi);
}

public struct OpLifetimeStop : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLifetimeStop()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLifetimeStop | (1 << 16);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Size
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLifetimeStop(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "size")
                Size = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpLifetimeStop(int pointer, int size)
    {
        Pointer = pointer;
        Size = size;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLifetimeStop, Pointer, ..Size.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLifetimeStop(OpDataIndex odi) => new(odi);
}

public struct OpGroupAsyncCopy : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAsyncCopy()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAsyncCopy | (1 << 16);
    }

    public static implicit operator Id(OpGroupAsyncCopy inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupAsyncCopy inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Destination
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Source
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumElements
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupAsyncCopy(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "destination")
                Destination = o.ToLiteral<int>();
            else if (o.Name == "source")
                Source = o.ToLiteral<int>();
            else if (o.Name == "numElements")
                NumElements = o.ToLiteral<int>();
            else if (o.Name == "stride")
                Stride = o.ToLiteral<int>();
            else if (o.Name == "eventId")
                EventId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupAsyncCopy(int resultType, int resultId, int execution, int destination, int source, int numElements, int stride, int eventId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Destination = destination;
        Source = source;
        NumElements = numElements;
        Stride = stride;
        EventId = eventId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAsyncCopy, ResultType, ResultId, Execution, Destination, Source, NumElements, Stride, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupAsyncCopy(OpDataIndex odi) => new(odi);
}

public struct OpGroupWaitEvents : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupWaitEvents()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupWaitEvents | (1 << 16);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventsList
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupWaitEvents(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "numEvents")
                NumEvents = o.ToLiteral<int>();
            else if (o.Name == "eventsList")
                EventsList = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupWaitEvents(int execution, int numEvents, int eventsList)
    {
        Execution = execution;
        NumEvents = numEvents;
        EventsList = eventsList;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupWaitEvents, Execution, NumEvents, EventsList];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupWaitEvents(OpDataIndex odi) => new(odi);
}

public struct OpGroupAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAll | (1 << 16);
    }

    public static implicit operator Id(OpGroupAll inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupAll inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupAll(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupAll(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAll, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupAll(OpDataIndex odi) => new(odi);
}

public struct OpGroupAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAny | (1 << 16);
    }

    public static implicit operator Id(OpGroupAny inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupAny inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupAny(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupAny(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAny, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupAny(OpDataIndex odi) => new(odi);
}

public struct OpGroupBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBroadcast | (1 << 16);
    }

    public static implicit operator Id(OpGroupBroadcast inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupBroadcast inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LocalId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupBroadcast(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "localId")
                LocalId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupBroadcast(int resultType, int resultId, int execution, int value, int localId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        LocalId = localId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBroadcast, ResultType, ResultId, Execution, Value, LocalId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupBroadcast(OpDataIndex odi) => new(odi);
}

public struct OpGroupIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIAdd | (1 << 16);
    }

    public static implicit operator Id(OpGroupIAdd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupIAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupIAdd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupIAdd(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIAdd, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupIAdd(OpDataIndex odi) => new(odi);
}

public struct OpGroupFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFAdd | (1 << 16);
    }

    public static implicit operator Id(OpGroupFAdd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupFAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupFAdd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupFAdd(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFAdd, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFAdd(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMin | (1 << 16);
    }

    public static implicit operator Id(OpGroupFMin inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupFMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupFMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupFMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMin | (1 << 16);
    }

    public static implicit operator Id(OpGroupUMin inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupUMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupUMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupUMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupUMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMin | (1 << 16);
    }

    public static implicit operator Id(OpGroupSMin inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupSMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupSMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupSMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupSMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMax | (1 << 16);
    }

    public static implicit operator Id(OpGroupFMax inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupFMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupFMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupFMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMax | (1 << 16);
    }

    public static implicit operator Id(OpGroupUMax inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupUMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupUMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupUMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupUMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMax | (1 << 16);
    }

    public static implicit operator Id(OpGroupSMax inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupSMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupSMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupSMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupSMax(OpDataIndex odi) => new(odi);
}

public struct OpReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadPipe | (1 << 16);
    }

    public static implicit operator Id(OpReadPipe inst) => new Id(inst.ResultId);
    public static implicit operator int (OpReadPipe inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReadPipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReadPipe(int resultType, int resultId, int pipe, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadPipe, ResultType, ResultId, Pipe, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReadPipe(OpDataIndex odi) => new(odi);
}

public struct OpWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePipe | (1 << 16);
    }

    public static implicit operator Id(OpWritePipe inst) => new Id(inst.ResultId);
    public static implicit operator int (OpWritePipe inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpWritePipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpWritePipe(int resultType, int resultId, int pipe, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePipe, ResultType, ResultId, Pipe, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpWritePipe(OpDataIndex odi) => new(odi);
}

public struct OpReservedReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReservedReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReservedReadPipe | (1 << 16);
    }

    public static implicit operator Id(OpReservedReadPipe inst) => new Id(inst.ResultId);
    public static implicit operator int (OpReservedReadPipe inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReservedReadPipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "reserveId")
                ReserveId = o.ToLiteral<int>();
            else if (o.Name == "index")
                Index = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReservedReadPipe(int resultType, int resultId, int pipe, int reserveId, int index, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        ReserveId = reserveId;
        Index = index;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReservedReadPipe, ResultType, ResultId, Pipe, ReserveId, Index, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReservedReadPipe(OpDataIndex odi) => new(odi);
}

public struct OpReservedWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReservedWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReservedWritePipe | (1 << 16);
    }

    public static implicit operator Id(OpReservedWritePipe inst) => new Id(inst.ResultId);
    public static implicit operator int (OpReservedWritePipe inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReservedWritePipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "reserveId")
                ReserveId = o.ToLiteral<int>();
            else if (o.Name == "index")
                Index = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReservedWritePipe(int resultType, int resultId, int pipe, int reserveId, int index, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        ReserveId = reserveId;
        Index = index;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReservedWritePipe, ResultType, ResultId, Pipe, ReserveId, Index, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReservedWritePipe(OpDataIndex odi) => new(odi);
}

public struct OpReserveReadPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReserveReadPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReserveReadPipePackets | (1 << 16);
    }

    public static implicit operator Id(OpReserveReadPipePackets inst) => new Id(inst.ResultId);
    public static implicit operator int (OpReserveReadPipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReserveReadPipePackets(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "numPackets")
                NumPackets = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReserveReadPipePackets(int resultType, int resultId, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReserveReadPipePackets, ResultType, ResultId, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReserveReadPipePackets(OpDataIndex odi) => new(odi);
}

public struct OpReserveWritePipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReserveWritePipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReserveWritePipePackets | (1 << 16);
    }

    public static implicit operator Id(OpReserveWritePipePackets inst) => new Id(inst.ResultId);
    public static implicit operator int (OpReserveWritePipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReserveWritePipePackets(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "numPackets")
                NumPackets = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReserveWritePipePackets(int resultType, int resultId, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReserveWritePipePackets, ResultType, ResultId, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReserveWritePipePackets(OpDataIndex odi) => new(odi);
}

public struct OpCommitReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCommitReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCommitReadPipe | (1 << 16);
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCommitReadPipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "reserveId")
                ReserveId = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCommitReadPipe(int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCommitReadPipe, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCommitReadPipe(OpDataIndex odi) => new(odi);
}

public struct OpCommitWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCommitWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCommitWritePipe | (1 << 16);
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCommitWritePipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "reserveId")
                ReserveId = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCommitWritePipe(int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCommitWritePipe, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCommitWritePipe(OpDataIndex odi) => new(odi);
}

public struct OpIsValidReserveId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsValidReserveId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsValidReserveId | (1 << 16);
    }

    public static implicit operator Id(OpIsValidReserveId inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIsValidReserveId inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIsValidReserveId(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "reserveId")
                ReserveId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIsValidReserveId(int resultType, int resultId, int reserveId)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReserveId = reserveId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsValidReserveId, ResultType, ResultId, ReserveId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsValidReserveId(OpDataIndex odi) => new(odi);
}

public struct OpGetNumPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetNumPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetNumPipePackets | (1 << 16);
    }

    public static implicit operator Id(OpGetNumPipePackets inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetNumPipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetNumPipePackets(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetNumPipePackets(int resultType, int resultId, int pipe, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetNumPipePackets, ResultType, ResultId, Pipe, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetNumPipePackets(OpDataIndex odi) => new(odi);
}

public struct OpGetMaxPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetMaxPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetMaxPipePackets | (1 << 16);
    }

    public static implicit operator Id(OpGetMaxPipePackets inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetMaxPipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetMaxPipePackets(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetMaxPipePackets(int resultType, int resultId, int pipe, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetMaxPipePackets, ResultType, ResultId, Pipe, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetMaxPipePackets(OpDataIndex odi) => new(odi);
}

public struct OpGroupReserveReadPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupReserveReadPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupReserveReadPipePackets | (1 << 16);
    }

    public static implicit operator Id(OpGroupReserveReadPipePackets inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupReserveReadPipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupReserveReadPipePackets(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "numPackets")
                NumPackets = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupReserveReadPipePackets(int resultType, int resultId, int execution, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupReserveReadPipePackets, ResultType, ResultId, Execution, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupReserveReadPipePackets(OpDataIndex odi) => new(odi);
}

public struct OpGroupReserveWritePipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupReserveWritePipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupReserveWritePipePackets | (1 << 16);
    }

    public static implicit operator Id(OpGroupReserveWritePipePackets inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupReserveWritePipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupReserveWritePipePackets(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "numPackets")
                NumPackets = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupReserveWritePipePackets(int resultType, int resultId, int execution, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupReserveWritePipePackets, ResultType, ResultId, Execution, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupReserveWritePipePackets(OpDataIndex odi) => new(odi);
}

public struct OpGroupCommitReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupCommitReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupCommitReadPipe | (1 << 16);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupCommitReadPipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "reserveId")
                ReserveId = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupCommitReadPipe(int execution, int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Execution = execution;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupCommitReadPipe, Execution, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupCommitReadPipe(OpDataIndex odi) => new(odi);
}

public struct OpGroupCommitWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupCommitWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupCommitWritePipe | (1 << 16);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupCommitWritePipe(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "pipe")
                Pipe = o.ToLiteral<int>();
            else if (o.Name == "reserveId")
                ReserveId = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupCommitWritePipe(int execution, int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Execution = execution;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupCommitWritePipe, Execution, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupCommitWritePipe(OpDataIndex odi) => new(odi);
}

public struct OpEnqueueMarker : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueMarker()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueMarker | (1 << 16);
    }

    public static implicit operator Id(OpEnqueueMarker inst) => new Id(inst.ResultId);
    public static implicit operator int (OpEnqueueMarker inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Queue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int WaitEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RetEvent
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEnqueueMarker(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "queue")
                Queue = o.ToLiteral<int>();
            else if (o.Name == "numEvents")
                NumEvents = o.ToLiteral<int>();
            else if (o.Name == "waitEvents")
                WaitEvents = o.ToLiteral<int>();
            else if (o.Name == "retEvent")
                RetEvent = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpEnqueueMarker(int resultType, int resultId, int queue, int numEvents, int waitEvents, int retEvent)
    {
        ResultType = resultType;
        ResultId = resultId;
        Queue = queue;
        NumEvents = numEvents;
        WaitEvents = waitEvents;
        RetEvent = retEvent;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueMarker, ResultType, ResultId, Queue, NumEvents, WaitEvents, RetEvent];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEnqueueMarker(OpDataIndex odi) => new(odi);
}

public struct OpEnqueueKernel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueKernel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueKernel | (1 << 16);
    }

    public static implicit operator Id(OpEnqueueKernel inst) => new Id(inst.ResultId);
    public static implicit operator int (OpEnqueueKernel inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Queue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int WaitEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RetEvent
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEnqueueKernel(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "queue")
                Queue = o.ToLiteral<int>();
            else if (o.Name == "flags")
                Flags = o.ToLiteral<int>();
            else if (o.Name == "nDRange")
                NDRange = o.ToLiteral<int>();
            else if (o.Name == "numEvents")
                NumEvents = o.ToLiteral<int>();
            else if (o.Name == "waitEvents")
                WaitEvents = o.ToLiteral<int>();
            else if (o.Name == "retEvent")
                RetEvent = o.ToLiteral<int>();
            else if (o.Name == "invoke")
                Invoke = o.ToLiteral<int>();
            else if (o.Name == "param")
                Param = o.ToLiteral<int>();
            else if (o.Name == "paramSize")
                ParamSize = o.ToLiteral<int>();
            else if (o.Name == "paramAlign")
                ParamAlign = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpEnqueueKernel(int resultType, int resultId, int queue, int flags, int nDRange, int numEvents, int waitEvents, int retEvent, int invoke, int param, int paramSize, int paramAlign, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Queue = queue;
        Flags = flags;
        NDRange = nDRange;
        NumEvents = numEvents;
        WaitEvents = waitEvents;
        RetEvent = retEvent;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueKernel, ResultType, ResultId, Queue, Flags, NDRange, NumEvents, WaitEvents, RetEvent, Invoke, Param, ParamSize, ParamAlign, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEnqueueKernel(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelNDrangeSubGroupCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelNDrangeSubGroupCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelNDrangeSubGroupCount | (1 << 16);
    }

    public static implicit operator Id(OpGetKernelNDrangeSubGroupCount inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetKernelNDrangeSubGroupCount inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetKernelNDrangeSubGroupCount(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "nDRange")
                NDRange = o.ToLiteral<int>();
            else if (o.Name == "invoke")
                Invoke = o.ToLiteral<int>();
            else if (o.Name == "param")
                Param = o.ToLiteral<int>();
            else if (o.Name == "paramSize")
                ParamSize = o.ToLiteral<int>();
            else if (o.Name == "paramAlign")
                ParamAlign = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetKernelNDrangeSubGroupCount(int resultType, int resultId, int nDRange, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        NDRange = nDRange;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelNDrangeSubGroupCount, ResultType, ResultId, NDRange, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelNDrangeSubGroupCount(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelNDrangeMaxSubGroupSize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelNDrangeMaxSubGroupSize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelNDrangeMaxSubGroupSize | (1 << 16);
    }

    public static implicit operator Id(OpGetKernelNDrangeMaxSubGroupSize inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetKernelNDrangeMaxSubGroupSize inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetKernelNDrangeMaxSubGroupSize(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "nDRange")
                NDRange = o.ToLiteral<int>();
            else if (o.Name == "invoke")
                Invoke = o.ToLiteral<int>();
            else if (o.Name == "param")
                Param = o.ToLiteral<int>();
            else if (o.Name == "paramSize")
                ParamSize = o.ToLiteral<int>();
            else if (o.Name == "paramAlign")
                ParamAlign = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetKernelNDrangeMaxSubGroupSize(int resultType, int resultId, int nDRange, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        NDRange = nDRange;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelNDrangeMaxSubGroupSize, ResultType, ResultId, NDRange, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelNDrangeMaxSubGroupSize(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelWorkGroupSize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelWorkGroupSize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelWorkGroupSize | (1 << 16);
    }

    public static implicit operator Id(OpGetKernelWorkGroupSize inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetKernelWorkGroupSize inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetKernelWorkGroupSize(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "invoke")
                Invoke = o.ToLiteral<int>();
            else if (o.Name == "param")
                Param = o.ToLiteral<int>();
            else if (o.Name == "paramSize")
                ParamSize = o.ToLiteral<int>();
            else if (o.Name == "paramAlign")
                ParamAlign = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetKernelWorkGroupSize(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelWorkGroupSize, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelWorkGroupSize(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelPreferredWorkGroupSizeMultiple : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelPreferredWorkGroupSizeMultiple | (1 << 16);
    }

    public static implicit operator Id(OpGetKernelPreferredWorkGroupSizeMultiple inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetKernelPreferredWorkGroupSizeMultiple inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "invoke")
                Invoke = o.ToLiteral<int>();
            else if (o.Name == "param")
                Param = o.ToLiteral<int>();
            else if (o.Name == "paramSize")
                ParamSize = o.ToLiteral<int>();
            else if (o.Name == "paramAlign")
                ParamAlign = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelPreferredWorkGroupSizeMultiple, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelPreferredWorkGroupSizeMultiple(OpDataIndex odi) => new(odi);
}

public struct OpRetainEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRetainEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRetainEvent | (1 << 16);
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRetainEvent(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "eventId")
                EventId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRetainEvent(int eventId)
    {
        EventId = eventId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRetainEvent, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRetainEvent(OpDataIndex odi) => new(odi);
}

public struct OpReleaseEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReleaseEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReleaseEvent | (1 << 16);
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReleaseEvent(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "eventId")
                EventId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReleaseEvent(int eventId)
    {
        EventId = eventId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReleaseEvent, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReleaseEvent(OpDataIndex odi) => new(odi);
}

public struct OpCreateUserEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateUserEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateUserEvent | (1 << 16);
    }

    public static implicit operator Id(OpCreateUserEvent inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCreateUserEvent inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCreateUserEvent(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCreateUserEvent(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateUserEvent, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCreateUserEvent(OpDataIndex odi) => new(odi);
}

public struct OpIsValidEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsValidEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsValidEvent | (1 << 16);
    }

    public static implicit operator Id(OpIsValidEvent inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIsValidEvent inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIsValidEvent(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "eventId")
                EventId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIsValidEvent(int resultType, int resultId, int eventId)
    {
        ResultType = resultType;
        ResultId = resultId;
        EventId = eventId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsValidEvent, ResultType, ResultId, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsValidEvent(OpDataIndex odi) => new(odi);
}

public struct OpSetUserEventStatus : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSetUserEventStatus()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSetUserEventStatus | (1 << 16);
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Status
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSetUserEventStatus(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "eventId")
                EventId = o.ToLiteral<int>();
            else if (o.Name == "status")
                Status = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSetUserEventStatus(int eventId, int status)
    {
        EventId = eventId;
        Status = status;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSetUserEventStatus, EventId, Status];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSetUserEventStatus(OpDataIndex odi) => new(odi);
}

public struct OpCaptureEventProfilingInfo : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCaptureEventProfilingInfo()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCaptureEventProfilingInfo | (1 << 16);
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ProfilingInfo
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCaptureEventProfilingInfo(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "eventId")
                EventId = o.ToLiteral<int>();
            else if (o.Name == "profilingInfo")
                ProfilingInfo = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCaptureEventProfilingInfo(int eventId, int profilingInfo, int value)
    {
        EventId = eventId;
        ProfilingInfo = profilingInfo;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCaptureEventProfilingInfo, EventId, ProfilingInfo, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCaptureEventProfilingInfo(OpDataIndex odi) => new(odi);
}

public struct OpGetDefaultQueue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetDefaultQueue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetDefaultQueue | (1 << 16);
    }

    public static implicit operator Id(OpGetDefaultQueue inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetDefaultQueue inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetDefaultQueue(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetDefaultQueue(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetDefaultQueue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetDefaultQueue(OpDataIndex odi) => new(odi);
}

public struct OpBuildNDRange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBuildNDRange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBuildNDRange | (1 << 16);
    }

    public static implicit operator Id(OpBuildNDRange inst) => new Id(inst.ResultId);
    public static implicit operator int (OpBuildNDRange inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GlobalWorkSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LocalWorkSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GlobalWorkOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBuildNDRange(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "globalWorkSize")
                GlobalWorkSize = o.ToLiteral<int>();
            else if (o.Name == "localWorkSize")
                LocalWorkSize = o.ToLiteral<int>();
            else if (o.Name == "globalWorkOffset")
                GlobalWorkOffset = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpBuildNDRange(int resultType, int resultId, int globalWorkSize, int localWorkSize, int globalWorkOffset)
    {
        ResultType = resultType;
        ResultId = resultId;
        GlobalWorkSize = globalWorkSize;
        LocalWorkSize = localWorkSize;
        GlobalWorkOffset = globalWorkOffset;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBuildNDRange, ResultType, ResultId, GlobalWorkSize, LocalWorkSize, GlobalWorkOffset];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBuildNDRange(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleImplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseSampleImplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleImplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseSampleImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleExplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseSampleExplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleExplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseSampleExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleExplicitLod, ResultType, ResultId, SampledImage, Coordinate, (int)Imageoperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleDrefImplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseSampleDrefImplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleDrefImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleDrefImplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseSampleDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleDrefImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleDrefExplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseSampleDrefExplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleDrefExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleDrefExplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseSampleDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, (int)Imageoperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleDrefExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleProjImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjImplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseSampleProjImplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleProjImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleProjImplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseSampleProjImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleProjImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleProjExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjExplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseSampleProjExplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleProjExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleProjExplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseSampleProjExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjExplicitLod, ResultType, ResultId, SampledImage, Coordinate, (int)Imageoperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleProjExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleProjDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjDrefImplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseSampleProjDrefImplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleProjDrefImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleProjDrefImplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseSampleProjDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleProjDrefImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleProjDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjDrefExplicitLod | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseSampleProjDrefExplicitLod inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleProjDrefExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleProjDrefExplicitLod(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseSampleProjDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, (int)Imageoperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleProjDrefExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseFetch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseFetch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseFetch | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseFetch inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseFetch inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseFetch(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseFetch(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseFetch, ResultType, ResultId, Image, Coordinate, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseFetch(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseGather | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseGather inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseGather inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseGather(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "component")
                Component = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseGather(int resultType, int resultId, int sampledImage, int coordinate, int component, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Component = component;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseGather, ResultType, ResultId, SampledImage, Coordinate, Component, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseGather(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseDrefGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseDrefGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseDrefGather | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseDrefGather inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseDrefGather inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseDrefGather(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "dref")
                Dref = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseDrefGather(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseDrefGather, ResultType, ResultId, SampledImage, Coordinate, Dref, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseDrefGather(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseTexelsResident : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseTexelsResident()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseTexelsResident | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseTexelsResident inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseTexelsResident inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResidentCode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseTexelsResident(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "residentCode")
                ResidentCode = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageSparseTexelsResident(int resultType, int resultId, int residentCode)
    {
        ResultType = resultType;
        ResultId = resultId;
        ResidentCode = residentCode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseTexelsResident, ResultType, ResultId, ResidentCode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseTexelsResident(OpDataIndex odi) => new(odi);
}

public struct OpNoLine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNoLine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNoLine | (1 << 16);
    }

    public OpNoLine(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpNoLine(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFlagTestAndSet : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFlagTestAndSet()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFlagTestAndSet | (1 << 16);
    }

    public static implicit operator Id(OpAtomicFlagTestAndSet inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicFlagTestAndSet inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicFlagTestAndSet(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicFlagTestAndSet(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFlagTestAndSet, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFlagTestAndSet(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFlagClear : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFlagClear()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFlagClear | (1 << 16);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicFlagClear(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicFlagClear(int pointer, int memory, int semantics)
    {
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFlagClear, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFlagClear(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseRead : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseRead()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseRead | (1 << 16);
    }

    public static implicit operator Id(OpImageSparseRead inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSparseRead inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSparseRead(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSparseRead(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseRead, ResultType, ResultId, Image, Coordinate, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseRead(OpDataIndex odi) => new(odi);
}

public struct OpSizeOf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSizeOf()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSizeOf | (1 << 16);
    }

    public static implicit operator Id(OpSizeOf inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSizeOf inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSizeOf(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSizeOf(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSizeOf, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSizeOf(OpDataIndex odi) => new(odi);
}

public struct OpTypePipeStorage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePipeStorage | (1 << 16);
    }

    public static implicit operator Id(OpTypePipeStorage inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypePipeStorage inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypePipeStorage(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypePipeStorage(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePipeStorage, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypePipeStorage(OpDataIndex odi) => new(odi);
}

public struct OpConstantPipeStorage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantPipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantPipeStorage | (1 << 16);
    }

    public static implicit operator Id(OpConstantPipeStorage inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantPipeStorage inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Capacity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantPipeStorage(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
            else if (o.Name == "capacity")
                Capacity = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConstantPipeStorage(int resultType, int resultId, int packetSize, int packetAlignment, int capacity)
    {
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        Capacity = capacity;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantPipeStorage, ResultType, ResultId, ..PacketSize.AsDisposableLiteralValue().Words, ..PacketAlignment.AsDisposableLiteralValue().Words, ..Capacity.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantPipeStorage(OpDataIndex odi) => new(odi);
}

public struct OpCreatePipeFromPipeStorage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreatePipeFromPipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreatePipeFromPipeStorage | (1 << 16);
    }

    public static implicit operator Id(OpCreatePipeFromPipeStorage inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCreatePipeFromPipeStorage inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PipeStorage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCreatePipeFromPipeStorage(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pipeStorage")
                PipeStorage = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCreatePipeFromPipeStorage(int resultType, int resultId, int pipeStorage)
    {
        ResultType = resultType;
        ResultId = resultId;
        PipeStorage = pipeStorage;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreatePipeFromPipeStorage, ResultType, ResultId, PipeStorage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCreatePipeFromPipeStorage(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelLocalSizeForSubgroupCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelLocalSizeForSubgroupCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelLocalSizeForSubgroupCount | (1 << 16);
    }

    public static implicit operator Id(OpGetKernelLocalSizeForSubgroupCount inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetKernelLocalSizeForSubgroupCount inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SubgroupCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetKernelLocalSizeForSubgroupCount(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "subgroupCount")
                SubgroupCount = o.ToLiteral<int>();
            else if (o.Name == "invoke")
                Invoke = o.ToLiteral<int>();
            else if (o.Name == "param")
                Param = o.ToLiteral<int>();
            else if (o.Name == "paramSize")
                ParamSize = o.ToLiteral<int>();
            else if (o.Name == "paramAlign")
                ParamAlign = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetKernelLocalSizeForSubgroupCount(int resultType, int resultId, int subgroupCount, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        SubgroupCount = subgroupCount;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelLocalSizeForSubgroupCount, ResultType, ResultId, SubgroupCount, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelLocalSizeForSubgroupCount(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelMaxNumSubgroups : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelMaxNumSubgroups()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelMaxNumSubgroups | (1 << 16);
    }

    public static implicit operator Id(OpGetKernelMaxNumSubgroups inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGetKernelMaxNumSubgroups inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGetKernelMaxNumSubgroups(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "invoke")
                Invoke = o.ToLiteral<int>();
            else if (o.Name == "param")
                Param = o.ToLiteral<int>();
            else if (o.Name == "paramSize")
                ParamSize = o.ToLiteral<int>();
            else if (o.Name == "paramAlign")
                ParamAlign = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGetKernelMaxNumSubgroups(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelMaxNumSubgroups, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelMaxNumSubgroups(OpDataIndex odi) => new(odi);
}

public struct OpTypeNamedBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeNamedBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeNamedBarrier | (1 << 16);
    }

    public static implicit operator Id(OpTypeNamedBarrier inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeNamedBarrier inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeNamedBarrier(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeNamedBarrier(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeNamedBarrier, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeNamedBarrier(OpDataIndex odi) => new(odi);
}

public struct OpNamedBarrierInitialize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNamedBarrierInitialize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNamedBarrierInitialize | (1 << 16);
    }

    public static implicit operator Id(OpNamedBarrierInitialize inst) => new Id(inst.ResultId);
    public static implicit operator int (OpNamedBarrierInitialize inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SubgroupCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpNamedBarrierInitialize(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "subgroupCount")
                SubgroupCount = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpNamedBarrierInitialize(int resultType, int resultId, int subgroupCount)
    {
        ResultType = resultType;
        ResultId = resultId;
        SubgroupCount = subgroupCount;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNamedBarrierInitialize, ResultType, ResultId, SubgroupCount];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpNamedBarrierInitialize(OpDataIndex odi) => new(odi);
}

public struct OpMemoryNamedBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryNamedBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryNamedBarrier | (1 << 16);
    }

    public int NamedBarrier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryNamedBarrier(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "namedBarrier")
                NamedBarrier = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpMemoryNamedBarrier(int namedBarrier, int memory, int semantics)
    {
        NamedBarrier = namedBarrier;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryNamedBarrier, NamedBarrier, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemoryNamedBarrier(OpDataIndex odi) => new(odi);
}

public struct OpModuleProcessed : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpModuleProcessed()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpModuleProcessed | (1 << 16);
    }

    public string Process
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpModuleProcessed(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "process")
                Process = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpModuleProcessed(string process)
    {
        Process = process;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpModuleProcessed, ..Process.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpModuleProcessed(OpDataIndex odi) => new(odi);
}

public struct OpExecutionModeId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecutionModeId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecutionModeId | (1 << 16);
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ExecutionMode Mode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecutionModeId(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "entryPoint")
                EntryPoint = o.ToLiteral<int>();
            else if (o.Name == "mode")
                Mode = o.ToEnum<ExecutionMode>();
        }

        DataIndex = index;
    }

    public OpExecutionModeId(int entryPoint, ExecutionMode mode)
    {
        EntryPoint = entryPoint;
        Mode = mode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecutionModeId, EntryPoint, (int)Mode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExecutionModeId(OpDataIndex odi) => new(odi);
}

public struct OpDecorateId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AdditionalId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorateId(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "target")
                Target = o.ToLiteral<int>();
            else if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
            else if (o.Name == "additionalId")
                AdditionalId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpDecorateId(int target, Decoration decoration, int additionalId)
    {
        Target = target;
        Decoration = decoration;
        AdditionalId = additionalId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorateId, Target, (int)Decoration, ..AdditionalId.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDecorateId(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformElect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformElect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformElect | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformElect inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformElect inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformElect(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformElect(int resultType, int resultId, int execution)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformElect, ResultType, ResultId, Execution];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformElect(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAll | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformAll inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformAll inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformAll(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformAll(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAll, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformAll(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAny | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformAny inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformAny inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformAny(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformAny(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAny, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformAny(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformAllEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAllEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAllEqual | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformAllEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformAllEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformAllEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformAllEqual(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAllEqual, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformAllEqual(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBroadcast | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBroadcast inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBroadcast inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Id
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBroadcast(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "id")
                Id = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBroadcast(int resultType, int resultId, int execution, int value, int id)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Id = id;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBroadcast, ResultType, ResultId, Execution, Value, Id];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBroadcast(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBroadcastFirst : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBroadcastFirst()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBroadcastFirst | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBroadcastFirst inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBroadcastFirst inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBroadcastFirst(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBroadcastFirst(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBroadcastFirst, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBroadcastFirst(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallot | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBallot inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallot(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBallot(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallot, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallot(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformInverseBallot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformInverseBallot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformInverseBallot | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformInverseBallot inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformInverseBallot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformInverseBallot(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformInverseBallot(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformInverseBallot, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformInverseBallot(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallotBitExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotBitExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotBitExtract | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBallotBitExtract inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallotBitExtract inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallotBitExtract(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "index")
                Index = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBallotBitExtract(int resultType, int resultId, int execution, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotBitExtract, ResultType, ResultId, Execution, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallotBitExtract(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallotBitCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotBitCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotBitCount | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBallotBitCount inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallotBitCount inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallotBitCount(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBallotBitCount(int resultType, int resultId, int execution, GroupOperation operation, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotBitCount, ResultType, ResultId, Execution, (int)Operation, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallotBitCount(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallotFindLSB : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotFindLSB()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotFindLSB | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBallotFindLSB inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallotFindLSB inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallotFindLSB(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBallotFindLSB(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotFindLSB, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallotFindLSB(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallotFindMSB : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotFindMSB()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotFindMSB | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBallotFindMSB inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallotFindMSB inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallotFindMSB(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBallotFindMSB(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotFindMSB, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallotFindMSB(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformShuffle : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffle()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffle | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformShuffle inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformShuffle inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Id
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformShuffle(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "id")
                Id = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformShuffle(int resultType, int resultId, int execution, int value, int id)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Id = id;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffle, ResultType, ResultId, Execution, Value, Id];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformShuffle(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformShuffleXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleXor | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformShuffleXor inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformShuffleXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformShuffleXor(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "mask")
                Mask = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformShuffleXor(int resultType, int resultId, int execution, int value, int mask)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Mask = mask;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleXor, ResultType, ResultId, Execution, Value, Mask];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformShuffleXor(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformShuffleUp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleUp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleUp | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformShuffleUp inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformShuffleUp inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformShuffleUp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "delta")
                Delta = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformShuffleUp(int resultType, int resultId, int execution, int value, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleUp, ResultType, ResultId, Execution, Value, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformShuffleUp(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformShuffleDown : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleDown()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleDown | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformShuffleDown inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformShuffleDown inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformShuffleDown(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "delta")
                Delta = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformShuffleDown(int resultType, int resultId, int execution, int value, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleDown, ResultType, ResultId, Execution, Value, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformShuffleDown(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformIAdd | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformIAdd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformIAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformIAdd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformIAdd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformIAdd, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformIAdd(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFAdd | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformFAdd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformFAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformFAdd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformFAdd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFAdd, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformFAdd(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformIMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformIMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformIMul | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformIMul inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformIMul inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformIMul(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformIMul(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformIMul, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformIMul(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformFMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMul | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformFMul inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformFMul inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformFMul(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformFMul(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMul, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformFMul(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformSMin | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformSMin inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformSMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformSMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformSMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformSMin, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformSMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformUMin | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformUMin inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformUMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformUMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformUMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformUMin, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformUMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMin | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformFMin inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformFMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformFMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformFMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMin, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformFMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformSMax | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformSMax inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformSMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformSMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformSMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformSMax, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformSMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformUMax | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformUMax inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformUMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformUMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformUMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformUMax, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformUMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMax | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformFMax inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformFMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformFMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformFMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMax, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformFMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBitwiseAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseAnd | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBitwiseAnd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBitwiseAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBitwiseAnd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBitwiseAnd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseAnd, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseAnd(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBitwiseOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseOr | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBitwiseOr inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBitwiseOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBitwiseOr(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBitwiseOr(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseOr, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseOr(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBitwiseXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseXor | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformBitwiseXor inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBitwiseXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBitwiseXor(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformBitwiseXor(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseXor, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseXor(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformLogicalAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalAnd | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformLogicalAnd inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformLogicalAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformLogicalAnd(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformLogicalAnd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalAnd, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformLogicalAnd(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformLogicalOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalOr | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformLogicalOr inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformLogicalOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformLogicalOr(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformLogicalOr(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalOr, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformLogicalOr(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformLogicalXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalXor | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformLogicalXor inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformLogicalXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformLogicalXor(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformLogicalXor(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalXor, ResultType, ResultId, Execution, (int)Operation, Value, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformLogicalXor(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformQuadBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadBroadcast | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformQuadBroadcast inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformQuadBroadcast inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformQuadBroadcast(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "index")
                Index = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformQuadBroadcast(int resultType, int resultId, int execution, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadBroadcast, ResultType, ResultId, Execution, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformQuadBroadcast(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformQuadSwap : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadSwap()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadSwap | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformQuadSwap inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformQuadSwap inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformQuadSwap(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformQuadSwap(int resultType, int resultId, int execution, int value, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadSwap, ResultType, ResultId, Execution, Value, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformQuadSwap(OpDataIndex odi) => new(odi);
}

public struct OpCopyLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCopyLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCopyLogical | (1 << 16);
    }

    public static implicit operator Id(OpCopyLogical inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCopyLogical inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCopyLogical(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCopyLogical(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCopyLogical, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCopyLogical(OpDataIndex odi) => new(odi);
}

public struct OpPtrEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrEqual | (1 << 16);
    }

    public static implicit operator Id(OpPtrEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpPtrEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpPtrEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpPtrEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrEqual(OpDataIndex odi) => new(odi);
}

public struct OpPtrNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrNotEqual | (1 << 16);
    }

    public static implicit operator Id(OpPtrNotEqual inst) => new Id(inst.ResultId);
    public static implicit operator int (OpPtrNotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpPtrNotEqual(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpPtrNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrNotEqual(OpDataIndex odi) => new(odi);
}

public struct OpPtrDiff : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrDiff()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrDiff | (1 << 16);
    }

    public static implicit operator Id(OpPtrDiff inst) => new Id(inst.ResultId);
    public static implicit operator int (OpPtrDiff inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpPtrDiff(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpPtrDiff(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrDiff, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrDiff(OpDataIndex odi) => new(odi);
}

public struct OpColorAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpColorAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpColorAttachmentReadEXT | (1 << 16);
    }

    public static implicit operator Id(OpColorAttachmentReadEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpColorAttachmentReadEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Attachment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpColorAttachmentReadEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "attachment")
                Attachment = o.ToLiteral<int>();
            else if (o.Name == "sample")
                if (o.Words.Length > 0)
                    Sample = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpColorAttachmentReadEXT(int resultType, int resultId, int attachment, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Attachment = attachment;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpColorAttachmentReadEXT, ResultType, ResultId, Attachment, ..Sample is null ? (Span<int>)[] : [Sample.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpColorAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public struct OpDepthAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDepthAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDepthAttachmentReadEXT | (1 << 16);
    }

    public static implicit operator Id(OpDepthAttachmentReadEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpDepthAttachmentReadEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDepthAttachmentReadEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sample")
                if (o.Words.Length > 0)
                    Sample = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpDepthAttachmentReadEXT(int resultType, int resultId, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDepthAttachmentReadEXT, ResultType, ResultId, ..Sample is null ? (Span<int>)[] : [Sample.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDepthAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public struct OpStencilAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStencilAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStencilAttachmentReadEXT | (1 << 16);
    }

    public static implicit operator Id(OpStencilAttachmentReadEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpStencilAttachmentReadEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpStencilAttachmentReadEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sample")
                if (o.Words.Length > 0)
                    Sample = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpStencilAttachmentReadEXT(int resultType, int resultId, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStencilAttachmentReadEXT, ResultType, ResultId, ..Sample is null ? (Span<int>)[] : [Sample.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpStencilAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public struct OpTerminateInvocation : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateInvocation()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateInvocation | (1 << 16);
    }

    public OpTerminateInvocation(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpTerminateInvocation(OpDataIndex odi) => new(odi);
}

public struct OpTypeUntypedPointerKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeUntypedPointerKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeUntypedPointerKHR | (1 << 16);
    }

    public static implicit operator Id(OpTypeUntypedPointerKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeUntypedPointerKHR inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeUntypedPointerKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
        }

        DataIndex = index;
    }

    public OpTypeUntypedPointerKHR(int resultId, StorageClass storageclass)
    {
        ResultId = resultId;
        Storageclass = storageclass;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeUntypedPointerKHR, ResultId, (int)Storageclass];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeUntypedPointerKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedVariableKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedVariableKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedVariableKHR | (1 << 16);
    }

    public static implicit operator Id(OpUntypedVariableKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUntypedVariableKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? DataType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Initializer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedVariableKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
            else if (o.Name == "dataType")
                if (o.Words.Length > 0)
                    DataType = o.ToLiteral<int?>();
                else if (o.Name == "initializer")
                    if (o.Words.Length > 0)
                        Initializer = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpUntypedVariableKHR(int resultType, int resultId, StorageClass storageclass, int? dataType, int? initializer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        DataType = dataType;
        Initializer = initializer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedVariableKHR, ResultType, ResultId, (int)Storageclass, ..DataType is null ? (Span<int>)[] : [DataType.Value], ..Initializer is null ? (Span<int>)[] : [Initializer.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedVariableKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedAccessChainKHR | (1 << 16);
    }

    public static implicit operator Id(OpUntypedAccessChainKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUntypedAccessChainKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedAccessChainKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseType")
                BaseType = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpUntypedAccessChainKHR(int resultType, int resultId, int baseType, int baseId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedAccessChainKHR, ResultType, ResultId, BaseType, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedAccessChainKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedInBoundsAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedInBoundsAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedInBoundsAccessChainKHR | (1 << 16);
    }

    public static implicit operator Id(OpUntypedInBoundsAccessChainKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUntypedInBoundsAccessChainKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedInBoundsAccessChainKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseType")
                BaseType = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpUntypedInBoundsAccessChainKHR(int resultType, int resultId, int baseType, int baseId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedInBoundsAccessChainKHR, ResultType, ResultId, BaseType, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedInBoundsAccessChainKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupBallotKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBallotKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBallotKHR | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupBallotKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupBallotKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupBallotKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupBallotKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBallotKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupBallotKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupFirstInvocationKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupFirstInvocationKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupFirstInvocationKHR | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupFirstInvocationKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupFirstInvocationKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupFirstInvocationKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupFirstInvocationKHR(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupFirstInvocationKHR, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupFirstInvocationKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedPtrAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedPtrAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedPtrAccessChainKHR | (1 << 16);
    }

    public static implicit operator Id(OpUntypedPtrAccessChainKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUntypedPtrAccessChainKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedPtrAccessChainKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseType")
                BaseType = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "element")
                Element = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpUntypedPtrAccessChainKHR(int resultType, int resultId, int baseType, int baseId, int element, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Element = element;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedPtrAccessChainKHR, ResultType, ResultId, BaseType, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedPtrAccessChainKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedInBoundsPtrAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedInBoundsPtrAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedInBoundsPtrAccessChainKHR | (1 << 16);
    }

    public static implicit operator Id(OpUntypedInBoundsPtrAccessChainKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUntypedInBoundsPtrAccessChainKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedInBoundsPtrAccessChainKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseType")
                BaseType = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "element")
                Element = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpUntypedInBoundsPtrAccessChainKHR(int resultType, int resultId, int baseType, int baseId, int element, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Element = element;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedInBoundsPtrAccessChainKHR, ResultType, ResultId, BaseType, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedInBoundsPtrAccessChainKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedArrayLengthKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedArrayLengthKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedArrayLengthKHR | (1 << 16);
    }

    public static implicit operator Id(OpUntypedArrayLengthKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUntypedArrayLengthKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Structure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arraymember
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedArrayLengthKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "structure")
                Structure = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "arraymember")
                Arraymember = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUntypedArrayLengthKHR(int resultType, int resultId, int structure, int pointer, int arraymember)
    {
        ResultType = resultType;
        ResultId = resultId;
        Structure = structure;
        Pointer = pointer;
        Arraymember = arraymember;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedArrayLengthKHR, ResultType, ResultId, Structure, Pointer, ..Arraymember.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedArrayLengthKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedPrefetchKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedPrefetchKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedPrefetchKHR | (1 << 16);
    }

    public int PointerType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumBytes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? RW
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Locality
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? CacheType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedPrefetchKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointerType")
                PointerType = o.ToLiteral<int>();
            else if (o.Name == "numBytes")
                NumBytes = o.ToLiteral<int>();
            else if (o.Name == "rW")
                if (o.Words.Length > 0)
                    RW = o.ToLiteral<int?>();
                else if (o.Name == "locality")
                    if (o.Words.Length > 0)
                        Locality = o.ToLiteral<int?>();
                    else if (o.Name == "cacheType")
                        if (o.Words.Length > 0)
                            CacheType = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpUntypedPrefetchKHR(int pointerType, int numBytes, int? rW, int? locality, int? cacheType)
    {
        PointerType = pointerType;
        NumBytes = numBytes;
        RW = rW;
        Locality = locality;
        CacheType = cacheType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedPrefetchKHR, PointerType, NumBytes, ..RW is null ? (Span<int>)[] : [RW.Value], ..Locality is null ? (Span<int>)[] : [Locality.Value], ..CacheType is null ? (Span<int>)[] : [CacheType.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedPrefetchKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAllKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAllKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAllKHR | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAllKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAllKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAllKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAllKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAllKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAllKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAnyKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAnyKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAnyKHR | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAnyKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAnyKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAnyKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAnyKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAnyKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAnyKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAllEqualKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAllEqualKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAllEqualKHR | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAllEqualKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAllEqualKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAllEqualKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAllEqualKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAllEqualKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAllEqualKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformRotateKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformRotateKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformRotateKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformRotateKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformRotateKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformRotateKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "delta")
                Delta = o.ToLiteral<int>();
            else if (o.Name == "clusterSize")
                if (o.Words.Length > 0)
                    ClusterSize = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformRotateKHR(int resultType, int resultId, int execution, int value, int delta, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformRotateKHR, ResultType, ResultId, Execution, Value, Delta, ..ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformRotateKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupReadInvocationKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupReadInvocationKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupReadInvocationKHR | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupReadInvocationKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupReadInvocationKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupReadInvocationKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "index")
                Index = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupReadInvocationKHR(int resultType, int resultId, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupReadInvocationKHR, ResultType, ResultId, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupReadInvocationKHR(OpDataIndex odi) => new(odi);
}

public struct OpExtInstWithForwardRefsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInstWithForwardRefsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInstWithForwardRefsKHR | (1 << 16);
    }

    public static implicit operator Id(OpExtInstWithForwardRefsKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpExtInstWithForwardRefsKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Instruction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExtInstWithForwardRefsKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "set")
                Set = o.ToLiteral<int>();
            else if (o.Name == "instruction")
                Instruction = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpExtInstWithForwardRefsKHR(int resultType, int resultId, int set, int instruction, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Instruction = instruction;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInstWithForwardRefsKHR, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExtInstWithForwardRefsKHR(OpDataIndex odi) => new(odi);
}

public struct OpTraceRayKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceRayKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceRayKHR | (1 << 16);
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceRayKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "accel")
                Accel = o.ToLiteral<int>();
            else if (o.Name == "rayFlags")
                RayFlags = o.ToLiteral<int>();
            else if (o.Name == "cullMask")
                CullMask = o.ToLiteral<int>();
            else if (o.Name == "sBTOffset")
                SBTOffset = o.ToLiteral<int>();
            else if (o.Name == "sBTStride")
                SBTStride = o.ToLiteral<int>();
            else if (o.Name == "missIndex")
                MissIndex = o.ToLiteral<int>();
            else if (o.Name == "rayOrigin")
                RayOrigin = o.ToLiteral<int>();
            else if (o.Name == "rayTmin")
                RayTmin = o.ToLiteral<int>();
            else if (o.Name == "rayDirection")
                RayDirection = o.ToLiteral<int>();
            else if (o.Name == "rayTmax")
                RayTmax = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTraceRayKHR(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int payload)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceRayKHR, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTraceRayKHR(OpDataIndex odi) => new(odi);
}

public struct OpExecuteCallableKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecuteCallableKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecuteCallableKHR | (1 << 16);
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CallableData
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecuteCallableKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "sBTIndex")
                SBTIndex = o.ToLiteral<int>();
            else if (o.Name == "callableData")
                CallableData = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpExecuteCallableKHR(int sBTIndex, int callableData)
    {
        SBTIndex = sBTIndex;
        CallableData = callableData;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecuteCallableKHR, SBTIndex, CallableData];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExecuteCallableKHR(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToAccelerationStructureKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToAccelerationStructureKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToAccelerationStructureKHR | (1 << 16);
    }

    public static implicit operator Id(OpConvertUToAccelerationStructureKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertUToAccelerationStructureKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertUToAccelerationStructureKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "accel")
                Accel = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertUToAccelerationStructureKHR(int resultType, int resultId, int accel)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToAccelerationStructureKHR, ResultType, ResultId, Accel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToAccelerationStructureKHR(OpDataIndex odi) => new(odi);
}

public struct OpIgnoreIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIgnoreIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIgnoreIntersectionKHR | (1 << 16);
    }

    public OpIgnoreIntersectionKHR(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpIgnoreIntersectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpTerminateRayKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateRayKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateRayKHR | (1 << 16);
    }

    public OpTerminateRayKHR(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpTerminateRayKHR(OpDataIndex odi) => new(odi);
}

public struct OpSDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDot | (1 << 16);
    }

    public static implicit operator Id(OpSDot inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSDot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDot(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
            else if (o.Name == "packedVectorFormat")
                if (o.Words.Length > 0)
                    PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }

        DataIndex = index;
    }

    public OpSDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDot, ResultType, ResultId, Vector1, Vector2, ..PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDot(OpDataIndex odi) => new(odi);
}

public struct OpUDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDot | (1 << 16);
    }

    public static implicit operator Id(OpUDot inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUDot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUDot(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
            else if (o.Name == "packedVectorFormat")
                if (o.Words.Length > 0)
                    PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }

        DataIndex = index;
    }

    public OpUDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDot, ResultType, ResultId, Vector1, Vector2, ..PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUDot(OpDataIndex odi) => new(odi);
}

public struct OpSUDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSUDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSUDot | (1 << 16);
    }

    public static implicit operator Id(OpSUDot inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSUDot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSUDot(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
            else if (o.Name == "packedVectorFormat")
                if (o.Words.Length > 0)
                    PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }

        DataIndex = index;
    }

    public OpSUDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSUDot, ResultType, ResultId, Vector1, Vector2, ..PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSUDot(OpDataIndex odi) => new(odi);
}

public struct OpSDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDotAccSat | (1 << 16);
    }

    public static implicit operator Id(OpSDotAccSat inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSDotAccSat inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDotAccSat(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
            else if (o.Name == "accumulator")
                Accumulator = o.ToLiteral<int>();
            else if (o.Name == "packedVectorFormat")
                if (o.Words.Length > 0)
                    PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }

        DataIndex = index;
    }

    public OpSDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDotAccSat(OpDataIndex odi) => new(odi);
}

public struct OpUDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDotAccSat | (1 << 16);
    }

    public static implicit operator Id(OpUDotAccSat inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUDotAccSat inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUDotAccSat(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
            else if (o.Name == "accumulator")
                Accumulator = o.ToLiteral<int>();
            else if (o.Name == "packedVectorFormat")
                if (o.Words.Length > 0)
                    PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }

        DataIndex = index;
    }

    public OpUDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUDotAccSat(OpDataIndex odi) => new(odi);
}

public struct OpSUDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSUDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSUDotAccSat | (1 << 16);
    }

    public static implicit operator Id(OpSUDotAccSat inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSUDotAccSat inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSUDotAccSat(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "vector1")
                Vector1 = o.ToLiteral<int>();
            else if (o.Name == "vector2")
                Vector2 = o.ToLiteral<int>();
            else if (o.Name == "accumulator")
                Accumulator = o.ToLiteral<int>();
            else if (o.Name == "packedVectorFormat")
                if (o.Words.Length > 0)
                    PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }

        DataIndex = index;
    }

    public OpSUDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSUDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSUDotAccSat(OpDataIndex odi) => new(odi);
}

public struct OpTypeCooperativeMatrixKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeCooperativeMatrixKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeCooperativeMatrixKHR | (1 << 16);
    }

    public static implicit operator Id(OpTypeCooperativeMatrixKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeCooperativeMatrixKHR inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scope
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Rows
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Columns
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Use
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeCooperativeMatrixKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "componentType")
                ComponentType = o.ToLiteral<int>();
            else if (o.Name == "scope")
                Scope = o.ToLiteral<int>();
            else if (o.Name == "rows")
                Rows = o.ToLiteral<int>();
            else if (o.Name == "columns")
                Columns = o.ToLiteral<int>();
            else if (o.Name == "use")
                Use = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeCooperativeMatrixKHR(int resultId, int componentType, int scope, int rows, int columns, int use)
    {
        ResultId = resultId;
        ComponentType = componentType;
        Scope = scope;
        Rows = rows;
        Columns = columns;
        Use = use;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeCooperativeMatrixKHR, ResultId, ComponentType, Scope, Rows, Columns, Use];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeCooperativeMatrixKHR(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLoadKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLoadKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLoadKHR | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixLoadKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLoadKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MemoryLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? MemoryOperand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLoadKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memoryLayout")
                MemoryLayout = o.ToLiteral<int>();
            else if (o.Name == "stride")
                if (o.Words.Length > 0)
                    Stride = o.ToLiteral<int?>();
                else if (o.Name == "memoryOperand")
                    if (o.Words.Length > 0)
                        MemoryOperand = o.ToEnum<MemoryAccessMask>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixLoadKHR(int resultType, int resultId, int pointer, int memoryLayout, int? stride, MemoryAccessMask? memoryOperand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        MemoryLayout = memoryLayout;
        Stride = stride;
        MemoryOperand = memoryOperand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLoadKHR, ResultType, ResultId, Pointer, MemoryLayout, ..Stride is null ? (Span<int>)[] : [Stride.Value], ..MemoryOperand is null ? (Span<int>)[] : [(int)MemoryOperand.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLoadKHR(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixStoreKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixStoreKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixStoreKHR | (1 << 16);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MemoryLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? MemoryOperand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "objectId")
                ObjectId = o.ToLiteral<int>();
            else if (o.Name == "memoryLayout")
                MemoryLayout = o.ToLiteral<int>();
            else if (o.Name == "stride")
                if (o.Words.Length > 0)
                    Stride = o.ToLiteral<int?>();
                else if (o.Name == "memoryOperand")
                    if (o.Words.Length > 0)
                        MemoryOperand = o.ToEnum<MemoryAccessMask>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixStoreKHR(int pointer, int objectId, int memoryLayout, int? stride, MemoryAccessMask? memoryOperand)
    {
        Pointer = pointer;
        ObjectId = objectId;
        MemoryLayout = memoryLayout;
        Stride = stride;
        MemoryOperand = memoryOperand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixStoreKHR, Pointer, ObjectId, MemoryLayout, ..Stride is null ? (Span<int>)[] : [Stride.Value], ..MemoryOperand is null ? (Span<int>)[] : [(int)MemoryOperand.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixStoreKHR(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixMulAddKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixMulAddKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixMulAddKHR | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixMulAddKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixMulAddKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public CooperativeMatrixOperandsMask? CooperativeMatrixOperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixMulAddKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "c")
                C = o.ToLiteral<int>();
            else if (o.Name == "cooperativeMatrixOperands")
                if (o.Words.Length > 0)
                    CooperativeMatrixOperands = o.ToEnum<CooperativeMatrixOperandsMask>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixMulAddKHR(int resultType, int resultId, int a, int b, int c, CooperativeMatrixOperandsMask? cooperativeMatrixOperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        B = b;
        C = c;
        CooperativeMatrixOperands = cooperativeMatrixOperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixMulAddKHR, ResultType, ResultId, A, B, C, ..CooperativeMatrixOperands is null ? (Span<int>)[] : [(int)CooperativeMatrixOperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixMulAddKHR(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLengthKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLengthKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLengthKHR | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixLengthKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLengthKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLengthKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "type")
                Type = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixLengthKHR(int resultType, int resultId, int type)
    {
        ResultType = resultType;
        ResultId = resultId;
        Type = type;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLengthKHR, ResultType, ResultId, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLengthKHR(OpDataIndex odi) => new(odi);
}

public struct OpConstantCompositeReplicateEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantCompositeReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantCompositeReplicateEXT | (1 << 16);
    }

    public static implicit operator Id(OpConstantCompositeReplicateEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantCompositeReplicateEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantCompositeReplicateEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConstantCompositeReplicateEXT(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantCompositeReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantCompositeReplicateEXT(OpDataIndex odi) => new(odi);
}

public struct OpSpecConstantCompositeReplicateEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantCompositeReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantCompositeReplicateEXT | (1 << 16);
    }

    public static implicit operator Id(OpSpecConstantCompositeReplicateEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSpecConstantCompositeReplicateEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantCompositeReplicateEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSpecConstantCompositeReplicateEXT(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantCompositeReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSpecConstantCompositeReplicateEXT(OpDataIndex odi) => new(odi);
}

public struct OpCompositeConstructReplicateEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstructReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstructReplicateEXT | (1 << 16);
    }

    public static implicit operator Id(OpCompositeConstructReplicateEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCompositeConstructReplicateEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCompositeConstructReplicateEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCompositeConstructReplicateEXT(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstructReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeConstructReplicateEXT(OpDataIndex odi) => new(odi);
}

public struct OpTypeRayQueryKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeRayQueryKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeRayQueryKHR | (1 << 16);
    }

    public static implicit operator Id(OpTypeRayQueryKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeRayQueryKHR inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeRayQueryKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeRayQueryKHR(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeRayQueryKHR, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeRayQueryKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryInitializeKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryInitializeKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryInitializeKHR | (1 << 16);
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryInitializeKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "accel")
                Accel = o.ToLiteral<int>();
            else if (o.Name == "rayFlags")
                RayFlags = o.ToLiteral<int>();
            else if (o.Name == "cullMask")
                CullMask = o.ToLiteral<int>();
            else if (o.Name == "rayOrigin")
                RayOrigin = o.ToLiteral<int>();
            else if (o.Name == "rayTMin")
                RayTMin = o.ToLiteral<int>();
            else if (o.Name == "rayDirection")
                RayDirection = o.ToLiteral<int>();
            else if (o.Name == "rayTMax")
                RayTMax = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryInitializeKHR(int rayQuery, int accel, int rayFlags, int cullMask, int rayOrigin, int rayTMin, int rayDirection, int rayTMax)
    {
        RayQuery = rayQuery;
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        RayOrigin = rayOrigin;
        RayTMin = rayTMin;
        RayDirection = rayDirection;
        RayTMax = rayTMax;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryInitializeKHR, RayQuery, Accel, RayFlags, CullMask, RayOrigin, RayTMin, RayDirection, RayTMax];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryInitializeKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryTerminateKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryTerminateKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryTerminateKHR | (1 << 16);
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryTerminateKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryTerminateKHR(int rayQuery)
    {
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryTerminateKHR, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryTerminateKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGenerateIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGenerateIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGenerateIntersectionKHR | (1 << 16);
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitT
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGenerateIntersectionKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "hitT")
                HitT = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGenerateIntersectionKHR(int rayQuery, int hitT)
    {
        RayQuery = rayQuery;
        HitT = hitT;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGenerateIntersectionKHR, RayQuery, HitT];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGenerateIntersectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryConfirmIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryConfirmIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryConfirmIntersectionKHR | (1 << 16);
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryConfirmIntersectionKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryConfirmIntersectionKHR(int rayQuery)
    {
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryConfirmIntersectionKHR, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryConfirmIntersectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryProceedKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryProceedKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryProceedKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryProceedKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryProceedKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryProceedKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryProceedKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryProceedKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryProceedKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionTypeKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTypeKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTypeKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionTypeKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionTypeKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionTypeKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionTypeKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTypeKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTypeKHR(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleWeightedQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleWeightedQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleWeightedQCOM | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleWeightedQCOM inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleWeightedQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texture
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Weights
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleWeightedQCOM(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "texture")
                Texture = o.ToLiteral<int>();
            else if (o.Name == "coordinates")
                Coordinates = o.ToLiteral<int>();
            else if (o.Name == "weights")
                Weights = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageSampleWeightedQCOM(int resultType, int resultId, int texture, int coordinates, int weights)
    {
        ResultType = resultType;
        ResultId = resultId;
        Texture = texture;
        Coordinates = coordinates;
        Weights = weights;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleWeightedQCOM, ResultType, ResultId, Texture, Coordinates, Weights];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleWeightedQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBoxFilterQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBoxFilterQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBoxFilterQCOM | (1 << 16);
    }

    public static implicit operator Id(OpImageBoxFilterQCOM inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageBoxFilterQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texture
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BoxSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageBoxFilterQCOM(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "texture")
                Texture = o.ToLiteral<int>();
            else if (o.Name == "coordinates")
                Coordinates = o.ToLiteral<int>();
            else if (o.Name == "boxSize")
                BoxSize = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageBoxFilterQCOM(int resultType, int resultId, int texture, int coordinates, int boxSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Texture = texture;
        Coordinates = coordinates;
        BoxSize = boxSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBoxFilterQCOM, ResultType, ResultId, Texture, Coordinates, BoxSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBoxFilterQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchSSDQCOM | (1 << 16);
    }

    public static implicit operator Id(OpImageBlockMatchSSDQCOM inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchSSDQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Reference
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchSSDQCOM(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "target")
                Target = o.ToLiteral<int>();
            else if (o.Name == "targetCoordinates")
                TargetCoordinates = o.ToLiteral<int>();
            else if (o.Name == "reference")
                Reference = o.ToLiteral<int>();
            else if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.ToLiteral<int>();
            else if (o.Name == "blockSize")
                BlockSize = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageBlockMatchSSDQCOM(int resultType, int resultId, int target, int targetCoordinates, int reference, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        TargetCoordinates = targetCoordinates;
        Reference = reference;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchSSDQCOM, ResultType, ResultId, Target, TargetCoordinates, Reference, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchSSDQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchSADQCOM | (1 << 16);
    }

    public static implicit operator Id(OpImageBlockMatchSADQCOM inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchSADQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Reference
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchSADQCOM(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "target")
                Target = o.ToLiteral<int>();
            else if (o.Name == "targetCoordinates")
                TargetCoordinates = o.ToLiteral<int>();
            else if (o.Name == "reference")
                Reference = o.ToLiteral<int>();
            else if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.ToLiteral<int>();
            else if (o.Name == "blockSize")
                BlockSize = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageBlockMatchSADQCOM(int resultType, int resultId, int target, int targetCoordinates, int reference, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        TargetCoordinates = targetCoordinates;
        Reference = reference;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchSADQCOM, ResultType, ResultId, Target, TargetCoordinates, Reference, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchSADQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchWindowSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchWindowSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchWindowSSDQCOM | (1 << 16);
    }

    public static implicit operator Id(OpImageBlockMatchWindowSSDQCOM inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchWindowSSDQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchWindowSSDQCOM(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "targetSampledImage")
                TargetSampledImage = o.ToLiteral<int>();
            else if (o.Name == "targetCoordinates")
                TargetCoordinates = o.ToLiteral<int>();
            else if (o.Name == "referenceSampledImage")
                ReferenceSampledImage = o.ToLiteral<int>();
            else if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.ToLiteral<int>();
            else if (o.Name == "blockSize")
                BlockSize = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageBlockMatchWindowSSDQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchWindowSSDQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchWindowSSDQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchWindowSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchWindowSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchWindowSADQCOM | (1 << 16);
    }

    public static implicit operator Id(OpImageBlockMatchWindowSADQCOM inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchWindowSADQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchWindowSADQCOM(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "targetSampledImage")
                TargetSampledImage = o.ToLiteral<int>();
            else if (o.Name == "targetCoordinates")
                TargetCoordinates = o.ToLiteral<int>();
            else if (o.Name == "referenceSampledImage")
                ReferenceSampledImage = o.ToLiteral<int>();
            else if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.ToLiteral<int>();
            else if (o.Name == "blockSize")
                BlockSize = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageBlockMatchWindowSADQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchWindowSADQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchWindowSADQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchGatherSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchGatherSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchGatherSSDQCOM | (1 << 16);
    }

    public static implicit operator Id(OpImageBlockMatchGatherSSDQCOM inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchGatherSSDQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchGatherSSDQCOM(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "targetSampledImage")
                TargetSampledImage = o.ToLiteral<int>();
            else if (o.Name == "targetCoordinates")
                TargetCoordinates = o.ToLiteral<int>();
            else if (o.Name == "referenceSampledImage")
                ReferenceSampledImage = o.ToLiteral<int>();
            else if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.ToLiteral<int>();
            else if (o.Name == "blockSize")
                BlockSize = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageBlockMatchGatherSSDQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchGatherSSDQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchGatherSSDQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchGatherSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchGatherSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchGatherSADQCOM | (1 << 16);
    }

    public static implicit operator Id(OpImageBlockMatchGatherSADQCOM inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchGatherSADQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchGatherSADQCOM(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "targetSampledImage")
                TargetSampledImage = o.ToLiteral<int>();
            else if (o.Name == "targetCoordinates")
                TargetCoordinates = o.ToLiteral<int>();
            else if (o.Name == "referenceSampledImage")
                ReferenceSampledImage = o.ToLiteral<int>();
            else if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.ToLiteral<int>();
            else if (o.Name == "blockSize")
                BlockSize = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpImageBlockMatchGatherSADQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchGatherSADQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchGatherSADQCOM(OpDataIndex odi) => new(odi);
}

public struct OpGroupIAddNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIAddNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIAddNonUniformAMD | (1 << 16);
    }

    public static implicit operator Id(OpGroupIAddNonUniformAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupIAddNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupIAddNonUniformAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupIAddNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIAddNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupIAddNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupFAddNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFAddNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFAddNonUniformAMD | (1 << 16);
    }

    public static implicit operator Id(OpGroupFAddNonUniformAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupFAddNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupFAddNonUniformAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupFAddNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFAddNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFAddNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMinNonUniformAMD | (1 << 16);
    }

    public static implicit operator Id(OpGroupFMinNonUniformAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupFMinNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupFMinNonUniformAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupFMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupUMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMinNonUniformAMD | (1 << 16);
    }

    public static implicit operator Id(OpGroupUMinNonUniformAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupUMinNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupUMinNonUniformAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupUMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupUMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupSMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMinNonUniformAMD | (1 << 16);
    }

    public static implicit operator Id(OpGroupSMinNonUniformAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupSMinNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupSMinNonUniformAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupSMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupSMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMaxNonUniformAMD | (1 << 16);
    }

    public static implicit operator Id(OpGroupFMaxNonUniformAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupFMaxNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupFMaxNonUniformAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupFMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupUMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMaxNonUniformAMD | (1 << 16);
    }

    public static implicit operator Id(OpGroupUMaxNonUniformAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupUMaxNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupUMaxNonUniformAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupUMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupUMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupSMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMaxNonUniformAMD | (1 << 16);
    }

    public static implicit operator Id(OpGroupSMaxNonUniformAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupSMaxNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupSMaxNonUniformAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupSMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupSMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpFragmentMaskFetchAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFragmentMaskFetchAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFragmentMaskFetchAMD | (1 << 16);
    }

    public static implicit operator Id(OpFragmentMaskFetchAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFragmentMaskFetchAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFragmentMaskFetchAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFragmentMaskFetchAMD(int resultType, int resultId, int image, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFragmentMaskFetchAMD, ResultType, ResultId, Image, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFragmentMaskFetchAMD(OpDataIndex odi) => new(odi);
}

public struct OpFragmentFetchAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFragmentFetchAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFragmentFetchAMD | (1 << 16);
    }

    public static implicit operator Id(OpFragmentFetchAMD inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFragmentFetchAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FragmentIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFragmentFetchAMD(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "fragmentIndex")
                FragmentIndex = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFragmentFetchAMD(int resultType, int resultId, int image, int coordinate, int fragmentIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        FragmentIndex = fragmentIndex;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFragmentFetchAMD, ResultType, ResultId, Image, Coordinate, FragmentIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFragmentFetchAMD(OpDataIndex odi) => new(odi);
}

public struct OpReadClockKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadClockKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadClockKHR | (1 << 16);
    }

    public static implicit operator Id(OpReadClockKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpReadClockKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scope
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReadClockKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "scope")
                Scope = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReadClockKHR(int resultType, int resultId, int scope)
    {
        ResultType = resultType;
        ResultId = resultId;
        Scope = scope;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadClockKHR, ResultType, ResultId, Scope];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReadClockKHR(OpDataIndex odi) => new(odi);
}

public struct OpAllocateNodePayloadsAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAllocateNodePayloadsAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAllocateNodePayloadsAMDX | (1 << 16);
    }

    public static implicit operator Id(OpAllocateNodePayloadsAMDX inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAllocateNodePayloadsAMDX inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Visibility
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NodeIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAllocateNodePayloadsAMDX(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "visibility")
                Visibility = o.ToLiteral<int>();
            else if (o.Name == "payloadCount")
                PayloadCount = o.ToLiteral<int>();
            else if (o.Name == "nodeIndex")
                NodeIndex = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAllocateNodePayloadsAMDX(int resultType, int resultId, int visibility, int payloadCount, int nodeIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        Visibility = visibility;
        PayloadCount = payloadCount;
        NodeIndex = nodeIndex;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAllocateNodePayloadsAMDX, ResultType, ResultId, Visibility, PayloadCount, NodeIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAllocateNodePayloadsAMDX(OpDataIndex odi) => new(odi);
}

public struct OpEnqueueNodePayloadsAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueNodePayloadsAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueNodePayloadsAMDX | (1 << 16);
    }

    public int PayloadArray
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEnqueueNodePayloadsAMDX(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "payloadArray")
                PayloadArray = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpEnqueueNodePayloadsAMDX(int payloadArray)
    {
        PayloadArray = payloadArray;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueNodePayloadsAMDX, PayloadArray];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEnqueueNodePayloadsAMDX(OpDataIndex odi) => new(odi);
}

public struct OpTypeNodePayloadArrayAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeNodePayloadArrayAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeNodePayloadArrayAMDX | (1 << 16);
    }

    public static implicit operator Id(OpTypeNodePayloadArrayAMDX inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeNodePayloadArrayAMDX inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeNodePayloadArrayAMDX(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payloadType")
                PayloadType = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeNodePayloadArrayAMDX(int resultId, int payloadType)
    {
        ResultId = resultId;
        PayloadType = payloadType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeNodePayloadArrayAMDX, ResultId, PayloadType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeNodePayloadArrayAMDX(OpDataIndex odi) => new(odi);
}

public struct OpFinishWritingNodePayloadAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFinishWritingNodePayloadAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFinishWritingNodePayloadAMDX | (1 << 16);
    }

    public static implicit operator Id(OpFinishWritingNodePayloadAMDX inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFinishWritingNodePayloadAMDX inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFinishWritingNodePayloadAMDX(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFinishWritingNodePayloadAMDX(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFinishWritingNodePayloadAMDX, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFinishWritingNodePayloadAMDX(OpDataIndex odi) => new(odi);
}

public struct OpNodePayloadArrayLengthAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNodePayloadArrayLengthAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNodePayloadArrayLengthAMDX | (1 << 16);
    }

    public static implicit operator Id(OpNodePayloadArrayLengthAMDX inst) => new Id(inst.ResultId);
    public static implicit operator int (OpNodePayloadArrayLengthAMDX inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadArray
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpNodePayloadArrayLengthAMDX(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payloadArray")
                PayloadArray = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpNodePayloadArrayLengthAMDX(int resultType, int resultId, int payloadArray)
    {
        ResultType = resultType;
        ResultId = resultId;
        PayloadArray = payloadArray;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNodePayloadArrayLengthAMDX, ResultType, ResultId, PayloadArray];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpNodePayloadArrayLengthAMDX(OpDataIndex odi) => new(odi);
}

public struct OpIsNodePayloadValidAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNodePayloadValidAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNodePayloadValidAMDX | (1 << 16);
    }

    public static implicit operator Id(OpIsNodePayloadValidAMDX inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIsNodePayloadValidAMDX inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NodeIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIsNodePayloadValidAMDX(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payloadType")
                PayloadType = o.ToLiteral<int>();
            else if (o.Name == "nodeIndex")
                NodeIndex = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIsNodePayloadValidAMDX(int resultType, int resultId, int payloadType, int nodeIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        PayloadType = payloadType;
        NodeIndex = nodeIndex;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNodePayloadValidAMDX, ResultType, ResultId, PayloadType, NodeIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsNodePayloadValidAMDX(OpDataIndex odi) => new(odi);
}

public struct OpConstantStringAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantStringAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantStringAMDX | (1 << 16);
    }

    public static implicit operator Id(OpConstantStringAMDX inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantStringAMDX inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string LiteralString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantStringAMDX(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "literalString")
                LiteralString = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpConstantStringAMDX(int resultId, string literalString)
    {
        ResultId = resultId;
        LiteralString = literalString;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantStringAMDX, ResultId, ..LiteralString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantStringAMDX(OpDataIndex odi) => new(odi);
}

public struct OpSpecConstantStringAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantStringAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantStringAMDX | (1 << 16);
    }

    public static implicit operator Id(OpSpecConstantStringAMDX inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSpecConstantStringAMDX inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string LiteralString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantStringAMDX(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "literalString")
                LiteralString = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpSpecConstantStringAMDX(int resultId, string literalString)
    {
        ResultId = resultId;
        LiteralString = literalString;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantStringAMDX, ResultId, ..LiteralString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSpecConstantStringAMDX(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformQuadAllKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadAllKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadAllKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformQuadAllKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformQuadAllKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformQuadAllKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformQuadAllKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadAllKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformQuadAllKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformQuadAnyKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadAnyKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadAnyKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformQuadAnyKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformQuadAnyKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformQuadAnyKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "predicate")
                Predicate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformQuadAnyKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadAnyKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformQuadAnyKHR(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordHitMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitMotionNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitMotionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "accelerationStructure")
                AccelerationStructure = o.ToLiteral<int>();
            else if (o.Name == "instanceId")
                InstanceId = o.ToLiteral<int>();
            else if (o.Name == "primitiveId")
                PrimitiveId = o.ToLiteral<int>();
            else if (o.Name == "geometryIndex")
                GeometryIndex = o.ToLiteral<int>();
            else if (o.Name == "hitKind")
                HitKind = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordOffset")
                SBTRecordOffset = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordStride")
                SBTRecordStride = o.ToLiteral<int>();
            else if (o.Name == "origin")
                Origin = o.ToLiteral<int>();
            else if (o.Name == "tMin")
                TMin = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "tMax")
                TMax = o.ToLiteral<int>();
            else if (o.Name == "currentTime")
                CurrentTime = o.ToLiteral<int>();
            else if (o.Name == "hitObjectAttributes")
                HitObjectAttributes = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectRecordHitMotionNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordOffset, int sBTRecordStride, int origin, int tMin, int direction, int tMax, int currentTime, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitMotionNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordOffset, SBTRecordStride, Origin, TMin, Direction, TMax, CurrentTime, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordHitMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordHitWithIndexMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitWithIndexMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitWithIndexMotionNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitWithIndexMotionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "accelerationStructure")
                AccelerationStructure = o.ToLiteral<int>();
            else if (o.Name == "instanceId")
                InstanceId = o.ToLiteral<int>();
            else if (o.Name == "primitiveId")
                PrimitiveId = o.ToLiteral<int>();
            else if (o.Name == "geometryIndex")
                GeometryIndex = o.ToLiteral<int>();
            else if (o.Name == "hitKind")
                HitKind = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordIndex")
                SBTRecordIndex = o.ToLiteral<int>();
            else if (o.Name == "origin")
                Origin = o.ToLiteral<int>();
            else if (o.Name == "tMin")
                TMin = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "tMax")
                TMax = o.ToLiteral<int>();
            else if (o.Name == "currentTime")
                CurrentTime = o.ToLiteral<int>();
            else if (o.Name == "hitObjectAttributes")
                HitObjectAttributes = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectRecordHitWithIndexMotionNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordIndex, int origin, int tMin, int direction, int tMax, int currentTime, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordIndex = sBTRecordIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitWithIndexMotionNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordIndex, Origin, TMin, Direction, TMax, CurrentTime, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordHitWithIndexMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordMissMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordMissMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordMissMotionNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordMissMotionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "sBTIndex")
                SBTIndex = o.ToLiteral<int>();
            else if (o.Name == "origin")
                Origin = o.ToLiteral<int>();
            else if (o.Name == "tMin")
                TMin = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "tMax")
                TMax = o.ToLiteral<int>();
            else if (o.Name == "currentTime")
                CurrentTime = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectRecordMissMotionNV(int hitObject, int sBTIndex, int origin, int tMin, int direction, int tMax, int currentTime)
    {
        HitObject = hitObject;
        SBTIndex = sBTIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordMissMotionNV, HitObject, SBTIndex, Origin, TMin, Direction, TMax, CurrentTime];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordMissMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetWorldToObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldToObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldToObjectNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetWorldToObjectNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetWorldToObjectNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetWorldToObjectNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetWorldToObjectNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldToObjectNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetWorldToObjectNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetObjectToWorldNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectToWorldNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectToWorldNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetObjectToWorldNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetObjectToWorldNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetObjectToWorldNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetObjectToWorldNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectToWorldNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetObjectToWorldNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetObjectRayDirectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectRayDirectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectRayDirectionNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetObjectRayDirectionNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetObjectRayDirectionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetObjectRayDirectionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetObjectRayDirectionNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectRayDirectionNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetObjectRayDirectionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetObjectRayOriginNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectRayOriginNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectRayOriginNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetObjectRayOriginNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetObjectRayOriginNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetObjectRayOriginNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetObjectRayOriginNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectRayOriginNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetObjectRayOriginNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectTraceRayMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectTraceRayMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectTraceRayMotionNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Cullmask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectTraceRayMotionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "accelerationStructure")
                AccelerationStructure = o.ToLiteral<int>();
            else if (o.Name == "rayFlags")
                RayFlags = o.ToLiteral<int>();
            else if (o.Name == "cullmask")
                Cullmask = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordOffset")
                SBTRecordOffset = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordStride")
                SBTRecordStride = o.ToLiteral<int>();
            else if (o.Name == "missIndex")
                MissIndex = o.ToLiteral<int>();
            else if (o.Name == "origin")
                Origin = o.ToLiteral<int>();
            else if (o.Name == "tMin")
                TMin = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "tMax")
                TMax = o.ToLiteral<int>();
            else if (o.Name == "time")
                Time = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectTraceRayMotionNV(int hitObject, int accelerationStructure, int rayFlags, int cullmask, int sBTRecordOffset, int sBTRecordStride, int missIndex, int origin, int tMin, int direction, int tMax, int time, int payload)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        RayFlags = rayFlags;
        Cullmask = cullmask;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        MissIndex = missIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        Time = time;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectTraceRayMotionNV, HitObject, AccelerationStructure, RayFlags, Cullmask, SBTRecordOffset, SBTRecordStride, MissIndex, Origin, TMin, Direction, TMax, Time, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectTraceRayMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetShaderRecordBufferHandleNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetShaderRecordBufferHandleNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetShaderRecordBufferHandleNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetShaderRecordBufferHandleNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetShaderRecordBufferHandleNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetShaderRecordBufferHandleNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetShaderRecordBufferHandleNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetShaderRecordBufferHandleNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetShaderRecordBufferHandleNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetShaderBindingTableRecordIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetShaderBindingTableRecordIndexNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetShaderBindingTableRecordIndexNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetShaderBindingTableRecordIndexNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetShaderBindingTableRecordIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetShaderBindingTableRecordIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordEmptyNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordEmptyNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordEmptyNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordEmptyNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectRecordEmptyNV(int hitObject)
    {
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordEmptyNV, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordEmptyNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectTraceRayNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectTraceRayNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectTraceRayNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Cullmask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectTraceRayNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "accelerationStructure")
                AccelerationStructure = o.ToLiteral<int>();
            else if (o.Name == "rayFlags")
                RayFlags = o.ToLiteral<int>();
            else if (o.Name == "cullmask")
                Cullmask = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordOffset")
                SBTRecordOffset = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordStride")
                SBTRecordStride = o.ToLiteral<int>();
            else if (o.Name == "missIndex")
                MissIndex = o.ToLiteral<int>();
            else if (o.Name == "origin")
                Origin = o.ToLiteral<int>();
            else if (o.Name == "tMin")
                TMin = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "tMax")
                TMax = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectTraceRayNV(int hitObject, int accelerationStructure, int rayFlags, int cullmask, int sBTRecordOffset, int sBTRecordStride, int missIndex, int origin, int tMin, int direction, int tMax, int payload)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        RayFlags = rayFlags;
        Cullmask = cullmask;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        MissIndex = missIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectTraceRayNV, HitObject, AccelerationStructure, RayFlags, Cullmask, SBTRecordOffset, SBTRecordStride, MissIndex, Origin, TMin, Direction, TMax, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectTraceRayNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordHitNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "accelerationStructure")
                AccelerationStructure = o.ToLiteral<int>();
            else if (o.Name == "instanceId")
                InstanceId = o.ToLiteral<int>();
            else if (o.Name == "primitiveId")
                PrimitiveId = o.ToLiteral<int>();
            else if (o.Name == "geometryIndex")
                GeometryIndex = o.ToLiteral<int>();
            else if (o.Name == "hitKind")
                HitKind = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordOffset")
                SBTRecordOffset = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordStride")
                SBTRecordStride = o.ToLiteral<int>();
            else if (o.Name == "origin")
                Origin = o.ToLiteral<int>();
            else if (o.Name == "tMin")
                TMin = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "tMax")
                TMax = o.ToLiteral<int>();
            else if (o.Name == "hitObjectAttributes")
                HitObjectAttributes = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectRecordHitNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordOffset, int sBTRecordStride, int origin, int tMin, int direction, int tMax, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordOffset, SBTRecordStride, Origin, TMin, Direction, TMax, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordHitNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordHitWithIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitWithIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitWithIndexNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitWithIndexNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "accelerationStructure")
                AccelerationStructure = o.ToLiteral<int>();
            else if (o.Name == "instanceId")
                InstanceId = o.ToLiteral<int>();
            else if (o.Name == "primitiveId")
                PrimitiveId = o.ToLiteral<int>();
            else if (o.Name == "geometryIndex")
                GeometryIndex = o.ToLiteral<int>();
            else if (o.Name == "hitKind")
                HitKind = o.ToLiteral<int>();
            else if (o.Name == "sBTRecordIndex")
                SBTRecordIndex = o.ToLiteral<int>();
            else if (o.Name == "origin")
                Origin = o.ToLiteral<int>();
            else if (o.Name == "tMin")
                TMin = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "tMax")
                TMax = o.ToLiteral<int>();
            else if (o.Name == "hitObjectAttributes")
                HitObjectAttributes = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectRecordHitWithIndexNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordIndex, int origin, int tMin, int direction, int tMax, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordIndex = sBTRecordIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitWithIndexNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordIndex, Origin, TMin, Direction, TMax, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordHitWithIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordMissNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordMissNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordMissNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordMissNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "sBTIndex")
                SBTIndex = o.ToLiteral<int>();
            else if (o.Name == "origin")
                Origin = o.ToLiteral<int>();
            else if (o.Name == "tMin")
                TMin = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "tMax")
                TMax = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectRecordMissNV(int hitObject, int sBTIndex, int origin, int tMin, int direction, int tMax)
    {
        HitObject = hitObject;
        SBTIndex = sBTIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordMissNV, HitObject, SBTIndex, Origin, TMin, Direction, TMax];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordMissNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectExecuteShaderNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectExecuteShaderNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectExecuteShaderNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectExecuteShaderNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectExecuteShaderNV(int hitObject, int payload)
    {
        HitObject = hitObject;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectExecuteShaderNV, HitObject, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectExecuteShaderNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetCurrentTimeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetCurrentTimeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetCurrentTimeNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetCurrentTimeNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetCurrentTimeNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetCurrentTimeNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetCurrentTimeNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetCurrentTimeNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetCurrentTimeNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetAttributesNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetAttributesNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetAttributesNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttribute
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetAttributesNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "hitObjectAttribute")
                HitObjectAttribute = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetAttributesNV(int hitObject, int hitObjectAttribute)
    {
        HitObject = hitObject;
        HitObjectAttribute = hitObjectAttribute;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetAttributesNV, HitObject, HitObjectAttribute];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetAttributesNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetHitKindNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetHitKindNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetHitKindNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetHitKindNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetHitKindNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetHitKindNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetHitKindNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetHitKindNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetHitKindNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetPrimitiveIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetPrimitiveIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetPrimitiveIndexNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetPrimitiveIndexNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetPrimitiveIndexNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetPrimitiveIndexNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetPrimitiveIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetPrimitiveIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetPrimitiveIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetGeometryIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetGeometryIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetGeometryIndexNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetGeometryIndexNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetGeometryIndexNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetGeometryIndexNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetGeometryIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetGeometryIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetGeometryIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetInstanceIdNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetInstanceIdNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetInstanceIdNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetInstanceIdNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetInstanceIdNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetInstanceIdNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetInstanceIdNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetInstanceIdNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetInstanceIdNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetInstanceCustomIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetInstanceCustomIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetInstanceCustomIndexNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetInstanceCustomIndexNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetInstanceCustomIndexNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetInstanceCustomIndexNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetInstanceCustomIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetInstanceCustomIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetInstanceCustomIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetWorldRayDirectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldRayDirectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldRayDirectionNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetWorldRayDirectionNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetWorldRayDirectionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetWorldRayDirectionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetWorldRayDirectionNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldRayDirectionNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetWorldRayDirectionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetWorldRayOriginNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldRayOriginNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldRayOriginNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetWorldRayOriginNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetWorldRayOriginNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetWorldRayOriginNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetWorldRayOriginNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldRayOriginNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetWorldRayOriginNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetRayTMaxNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetRayTMaxNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetRayTMaxNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetRayTMaxNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetRayTMaxNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetRayTMaxNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetRayTMaxNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetRayTMaxNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetRayTMaxNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetRayTMinNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetRayTMinNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetRayTMinNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectGetRayTMinNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectGetRayTMinNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetRayTMinNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectGetRayTMinNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetRayTMinNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetRayTMinNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectIsEmptyNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsEmptyNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsEmptyNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectIsEmptyNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectIsEmptyNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectIsEmptyNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectIsEmptyNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsEmptyNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectIsEmptyNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectIsHitNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsHitNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsHitNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectIsHitNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectIsHitNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectIsHitNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectIsHitNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsHitNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectIsHitNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectIsMissNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsMissNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsMissNV | (1 << 16);
    }

    public static implicit operator Id(OpHitObjectIsMissNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpHitObjectIsMissNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectIsMissNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpHitObjectIsMissNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsMissNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectIsMissNV(OpDataIndex odi) => new(odi);
}

public struct OpReorderThreadWithHitObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReorderThreadWithHitObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReorderThreadWithHitObjectNV | (1 << 16);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Hint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Bits
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReorderThreadWithHitObjectNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hitObject")
                HitObject = o.ToLiteral<int>();
            else if (o.Name == "hint")
                if (o.Words.Length > 0)
                    Hint = o.ToLiteral<int?>();
                else if (o.Name == "bits")
                    if (o.Words.Length > 0)
                        Bits = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpReorderThreadWithHitObjectNV(int hitObject, int? hint, int? bits)
    {
        HitObject = hitObject;
        Hint = hint;
        Bits = bits;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReorderThreadWithHitObjectNV, HitObject, ..Hint is null ? (Span<int>)[] : [Hint.Value], ..Bits is null ? (Span<int>)[] : [Bits.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReorderThreadWithHitObjectNV(OpDataIndex odi) => new(odi);
}

public struct OpReorderThreadWithHintNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReorderThreadWithHintNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReorderThreadWithHintNV | (1 << 16);
    }

    public int Hint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Bits
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReorderThreadWithHintNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "hint")
                Hint = o.ToLiteral<int>();
            else if (o.Name == "bits")
                Bits = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReorderThreadWithHintNV(int hint, int bits)
    {
        Hint = hint;
        Bits = bits;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReorderThreadWithHintNV, Hint, Bits];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReorderThreadWithHintNV(OpDataIndex odi) => new(odi);
}

public struct OpTypeHitObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeHitObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeHitObjectNV | (1 << 16);
    }

    public static implicit operator Id(OpTypeHitObjectNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeHitObjectNV inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeHitObjectNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeHitObjectNV(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeHitObjectNV, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeHitObjectNV(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleFootprintNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleFootprintNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleFootprintNV | (1 << 16);
    }

    public static implicit operator Id(OpImageSampleFootprintNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpImageSampleFootprintNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Granularity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coarse
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageSampleFootprintNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sampledImage")
                SampledImage = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "granularity")
                Granularity = o.ToLiteral<int>();
            else if (o.Name == "coarse")
                Coarse = o.ToLiteral<int>();
            else if (o.Name == "imageoperands")
                if (o.Words.Length > 0)
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
        }

        DataIndex = index;
    }

    public OpImageSampleFootprintNV(int resultType, int resultId, int sampledImage, int coordinate, int granularity, int coarse, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Granularity = granularity;
        Coarse = coarse;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleFootprintNV, ResultType, ResultId, SampledImage, Coordinate, Granularity, Coarse, ..Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleFootprintNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixConvertNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixConvertNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixConvertNV | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixConvertNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixConvertNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixConvertNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "matrix")
                Matrix = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixConvertNV(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixConvertNV, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixConvertNV(OpDataIndex odi) => new(odi);
}

public struct OpEmitMeshTasksEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitMeshTasksEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitMeshTasksEXT | (1 << 16);
    }

    public int GroupCountX
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GroupCountY
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GroupCountZ
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEmitMeshTasksEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "groupCountX")
                GroupCountX = o.ToLiteral<int>();
            else if (o.Name == "groupCountY")
                GroupCountY = o.ToLiteral<int>();
            else if (o.Name == "groupCountZ")
                GroupCountZ = o.ToLiteral<int>();
            else if (o.Name == "payload")
                if (o.Words.Length > 0)
                    Payload = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpEmitMeshTasksEXT(int groupCountX, int groupCountY, int groupCountZ, int? payload)
    {
        GroupCountX = groupCountX;
        GroupCountY = groupCountY;
        GroupCountZ = groupCountZ;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEmitMeshTasksEXT, GroupCountX, GroupCountY, GroupCountZ, ..Payload is null ? (Span<int>)[] : [Payload.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEmitMeshTasksEXT(OpDataIndex odi) => new(odi);
}

public struct OpSetMeshOutputsEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSetMeshOutputsEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSetMeshOutputsEXT | (1 << 16);
    }

    public int VertexCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSetMeshOutputsEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "vertexCount")
                VertexCount = o.ToLiteral<int>();
            else if (o.Name == "primitiveCount")
                PrimitiveCount = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSetMeshOutputsEXT(int vertexCount, int primitiveCount)
    {
        VertexCount = vertexCount;
        PrimitiveCount = primitiveCount;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSetMeshOutputsEXT, VertexCount, PrimitiveCount];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSetMeshOutputsEXT(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformPartitionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformPartitionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformPartitionNV | (1 << 16);
    }

    public static implicit operator Id(OpGroupNonUniformPartitionNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformPartitionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformPartitionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupNonUniformPartitionNV(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformPartitionNV, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformPartitionNV(OpDataIndex odi) => new(odi);
}

public struct OpWritePackedPrimitiveIndices4x8NV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePackedPrimitiveIndices4x8NV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePackedPrimitiveIndices4x8NV | (1 << 16);
    }

    public int IndexOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedIndices
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpWritePackedPrimitiveIndices4x8NV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "indexOffset")
                IndexOffset = o.ToLiteral<int>();
            else if (o.Name == "packedIndices")
                PackedIndices = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpWritePackedPrimitiveIndices4x8NV(int indexOffset, int packedIndices)
    {
        IndexOffset = indexOffset;
        PackedIndices = packedIndices;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePackedPrimitiveIndices4x8NV, IndexOffset, PackedIndices];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpWritePackedPrimitiveIndices4x8NV(OpDataIndex odi) => new(odi);
}

public struct OpFetchMicroTriangleVertexPositionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFetchMicroTriangleVertexPositionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFetchMicroTriangleVertexPositionNV | (1 << 16);
    }

    public static implicit operator Id(OpFetchMicroTriangleVertexPositionNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFetchMicroTriangleVertexPositionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Barycentric
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFetchMicroTriangleVertexPositionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "accel")
                Accel = o.ToLiteral<int>();
            else if (o.Name == "instanceId")
                InstanceId = o.ToLiteral<int>();
            else if (o.Name == "geometryIndex")
                GeometryIndex = o.ToLiteral<int>();
            else if (o.Name == "primitiveIndex")
                PrimitiveIndex = o.ToLiteral<int>();
            else if (o.Name == "barycentric")
                Barycentric = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFetchMicroTriangleVertexPositionNV(int resultType, int resultId, int accel, int instanceId, int geometryIndex, int primitiveIndex, int barycentric)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        InstanceId = instanceId;
        GeometryIndex = geometryIndex;
        PrimitiveIndex = primitiveIndex;
        Barycentric = barycentric;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFetchMicroTriangleVertexPositionNV, ResultType, ResultId, Accel, InstanceId, GeometryIndex, PrimitiveIndex, Barycentric];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFetchMicroTriangleVertexPositionNV(OpDataIndex odi) => new(odi);
}

public struct OpFetchMicroTriangleVertexBarycentricNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFetchMicroTriangleVertexBarycentricNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFetchMicroTriangleVertexBarycentricNV | (1 << 16);
    }

    public static implicit operator Id(OpFetchMicroTriangleVertexBarycentricNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFetchMicroTriangleVertexBarycentricNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Barycentric
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFetchMicroTriangleVertexBarycentricNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "accel")
                Accel = o.ToLiteral<int>();
            else if (o.Name == "instanceId")
                InstanceId = o.ToLiteral<int>();
            else if (o.Name == "geometryIndex")
                GeometryIndex = o.ToLiteral<int>();
            else if (o.Name == "primitiveIndex")
                PrimitiveIndex = o.ToLiteral<int>();
            else if (o.Name == "barycentric")
                Barycentric = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFetchMicroTriangleVertexBarycentricNV(int resultType, int resultId, int accel, int instanceId, int geometryIndex, int primitiveIndex, int barycentric)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        InstanceId = instanceId;
        GeometryIndex = geometryIndex;
        PrimitiveIndex = primitiveIndex;
        Barycentric = barycentric;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFetchMicroTriangleVertexBarycentricNV, ResultType, ResultId, Accel, InstanceId, GeometryIndex, PrimitiveIndex, Barycentric];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFetchMicroTriangleVertexBarycentricNV(OpDataIndex odi) => new(odi);
}

public struct OpReportIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReportIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReportIntersectionKHR | (1 << 16);
    }

    public static implicit operator Id(OpReportIntersectionKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpReportIntersectionKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Hit
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReportIntersectionKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "hit")
                Hit = o.ToLiteral<int>();
            else if (o.Name == "hitKind")
                HitKind = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReportIntersectionKHR(int resultType, int resultId, int hit, int hitKind)
    {
        ResultType = resultType;
        ResultId = resultId;
        Hit = hit;
        HitKind = hitKind;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReportIntersectionKHR, ResultType, ResultId, Hit, HitKind];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReportIntersectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpIgnoreIntersectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIgnoreIntersectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIgnoreIntersectionNV | (1 << 16);
    }

    public OpIgnoreIntersectionNV(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpIgnoreIntersectionNV(OpDataIndex odi) => new(odi);
}

public struct OpTerminateRayNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateRayNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateRayNV | (1 << 16);
    }

    public OpTerminateRayNV(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpTerminateRayNV(OpDataIndex odi) => new(odi);
}

public struct OpTraceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceNV | (1 << 16);
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "accel")
                Accel = o.ToLiteral<int>();
            else if (o.Name == "rayFlags")
                RayFlags = o.ToLiteral<int>();
            else if (o.Name == "cullMask")
                CullMask = o.ToLiteral<int>();
            else if (o.Name == "sBTOffset")
                SBTOffset = o.ToLiteral<int>();
            else if (o.Name == "sBTStride")
                SBTStride = o.ToLiteral<int>();
            else if (o.Name == "missIndex")
                MissIndex = o.ToLiteral<int>();
            else if (o.Name == "rayOrigin")
                RayOrigin = o.ToLiteral<int>();
            else if (o.Name == "rayTmin")
                RayTmin = o.ToLiteral<int>();
            else if (o.Name == "rayDirection")
                RayDirection = o.ToLiteral<int>();
            else if (o.Name == "rayTmax")
                RayTmax = o.ToLiteral<int>();
            else if (o.Name == "payloadId")
                PayloadId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTraceNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int payloadId)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        PayloadId = payloadId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, PayloadId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTraceNV(OpDataIndex odi) => new(odi);
}

public struct OpTraceMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceMotionNV | (1 << 16);
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceMotionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "accel")
                Accel = o.ToLiteral<int>();
            else if (o.Name == "rayFlags")
                RayFlags = o.ToLiteral<int>();
            else if (o.Name == "cullMask")
                CullMask = o.ToLiteral<int>();
            else if (o.Name == "sBTOffset")
                SBTOffset = o.ToLiteral<int>();
            else if (o.Name == "sBTStride")
                SBTStride = o.ToLiteral<int>();
            else if (o.Name == "missIndex")
                MissIndex = o.ToLiteral<int>();
            else if (o.Name == "rayOrigin")
                RayOrigin = o.ToLiteral<int>();
            else if (o.Name == "rayTmin")
                RayTmin = o.ToLiteral<int>();
            else if (o.Name == "rayDirection")
                RayDirection = o.ToLiteral<int>();
            else if (o.Name == "rayTmax")
                RayTmax = o.ToLiteral<int>();
            else if (o.Name == "time")
                Time = o.ToLiteral<int>();
            else if (o.Name == "payloadId")
                PayloadId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTraceMotionNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int time, int payloadId)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Time = time;
        PayloadId = payloadId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceMotionNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Time, PayloadId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTraceMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpTraceRayMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceRayMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceRayMotionNV | (1 << 16);
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceRayMotionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "accel")
                Accel = o.ToLiteral<int>();
            else if (o.Name == "rayFlags")
                RayFlags = o.ToLiteral<int>();
            else if (o.Name == "cullMask")
                CullMask = o.ToLiteral<int>();
            else if (o.Name == "sBTOffset")
                SBTOffset = o.ToLiteral<int>();
            else if (o.Name == "sBTStride")
                SBTStride = o.ToLiteral<int>();
            else if (o.Name == "missIndex")
                MissIndex = o.ToLiteral<int>();
            else if (o.Name == "rayOrigin")
                RayOrigin = o.ToLiteral<int>();
            else if (o.Name == "rayTmin")
                RayTmin = o.ToLiteral<int>();
            else if (o.Name == "rayDirection")
                RayDirection = o.ToLiteral<int>();
            else if (o.Name == "rayTmax")
                RayTmax = o.ToLiteral<int>();
            else if (o.Name == "time")
                Time = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTraceRayMotionNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int time, int payload)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Time = time;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceRayMotionNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Time, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTraceRayMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionTriangleVertexPositionsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTriangleVertexPositionsKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionTriangleVertexPositionsKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionTriangleVertexPositionsKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTriangleVertexPositionsKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpDataIndex odi) => new(odi);
}

public struct OpTypeAccelerationStructureKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAccelerationStructureKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAccelerationStructureKHR | (1 << 16);
    }

    public static implicit operator Id(OpTypeAccelerationStructureKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAccelerationStructureKHR inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAccelerationStructureKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAccelerationStructureKHR(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAccelerationStructureKHR, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAccelerationStructureKHR(OpDataIndex odi) => new(odi);
}

public struct OpExecuteCallableNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecuteCallableNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecuteCallableNV | (1 << 16);
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CallableDataId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecuteCallableNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "sBTIndex")
                SBTIndex = o.ToLiteral<int>();
            else if (o.Name == "callableDataId")
                CallableDataId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpExecuteCallableNV(int sBTIndex, int callableDataId)
    {
        SBTIndex = sBTIndex;
        CallableDataId = callableDataId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecuteCallableNV, SBTIndex, CallableDataId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExecuteCallableNV(OpDataIndex odi) => new(odi);
}

public struct OpTypeCooperativeMatrixNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeCooperativeMatrixNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeCooperativeMatrixNV | (1 << 16);
    }

    public static implicit operator Id(OpTypeCooperativeMatrixNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeCooperativeMatrixNV inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Rows
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Columns
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeCooperativeMatrixNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "componentType")
                ComponentType = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "rows")
                Rows = o.ToLiteral<int>();
            else if (o.Name == "columns")
                Columns = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeCooperativeMatrixNV(int resultId, int componentType, int execution, int rows, int columns)
    {
        ResultId = resultId;
        ComponentType = componentType;
        Execution = execution;
        Rows = rows;
        Columns = columns;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeCooperativeMatrixNV, ResultId, ComponentType, Execution, Rows, Columns];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeCooperativeMatrixNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLoadNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLoadNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLoadNV | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixLoadNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLoadNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnMajor
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLoadNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "stride")
                Stride = o.ToLiteral<int>();
            else if (o.Name == "columnMajor")
                ColumnMajor = o.ToLiteral<int>();
            else if (o.Name == "memoryaccess")
                if (o.Words.Length > 0)
                    Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixLoadNV(int resultType, int resultId, int pointer, int stride, int columnMajor, MemoryAccessMask? memoryaccess)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Stride = stride;
        ColumnMajor = columnMajor;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLoadNV, ResultType, ResultId, Pointer, Stride, ColumnMajor, ..Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLoadNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixStoreNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixStoreNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixStoreNV | (1 << 16);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnMajor
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "objectId")
                ObjectId = o.ToLiteral<int>();
            else if (o.Name == "stride")
                Stride = o.ToLiteral<int>();
            else if (o.Name == "columnMajor")
                ColumnMajor = o.ToLiteral<int>();
            else if (o.Name == "memoryaccess")
                if (o.Words.Length > 0)
                    Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixStoreNV(int pointer, int objectId, int stride, int columnMajor, MemoryAccessMask? memoryaccess)
    {
        Pointer = pointer;
        ObjectId = objectId;
        Stride = stride;
        ColumnMajor = columnMajor;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixStoreNV, Pointer, ObjectId, Stride, ColumnMajor, ..Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixStoreNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixMulAddNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixMulAddNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixMulAddNV | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixMulAddNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixMulAddNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixMulAddNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "c")
                C = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixMulAddNV(int resultType, int resultId, int a, int b, int c)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        B = b;
        C = c;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixMulAddNV, ResultType, ResultId, A, B, C];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixMulAddNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLengthNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLengthNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLengthNV | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixLengthNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLengthNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLengthNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "type")
                Type = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixLengthNV(int resultType, int resultId, int type)
    {
        ResultType = resultType;
        ResultId = resultId;
        Type = type;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLengthNV, ResultType, ResultId, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLengthNV(OpDataIndex odi) => new(odi);
}

public struct OpBeginInvocationInterlockEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBeginInvocationInterlockEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBeginInvocationInterlockEXT | (1 << 16);
    }

    public OpBeginInvocationInterlockEXT(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpBeginInvocationInterlockEXT(OpDataIndex odi) => new(odi);
}

public struct OpEndInvocationInterlockEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndInvocationInterlockEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndInvocationInterlockEXT | (1 << 16);
    }

    public OpEndInvocationInterlockEXT(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpEndInvocationInterlockEXT(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixReduceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixReduceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixReduceNV | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixReduceNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixReduceNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public CooperativeMatrixReduceMask Reduce
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CombineFunc
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixReduceNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "matrix")
                Matrix = o.ToLiteral<int>();
            else if (o.Name == "reduce")
                Reduce = o.ToEnum<CooperativeMatrixReduceMask>();
            else if (o.Name == "combineFunc")
                CombineFunc = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixReduceNV(int resultType, int resultId, int matrix, CooperativeMatrixReduceMask reduce, int combineFunc)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Reduce = reduce;
        CombineFunc = combineFunc;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixReduceNV, ResultType, ResultId, Matrix, (int)Reduce, CombineFunc];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixReduceNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLoadTensorNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLoadTensorNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLoadTensorNV | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixLoadTensorNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLoadTensorNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask MemoryOperand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public TensorAddressingOperandsMask TensorAddressingOperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLoadTensorNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "objectId")
                ObjectId = o.ToLiteral<int>();
            else if (o.Name == "tensorLayout")
                TensorLayout = o.ToLiteral<int>();
            else if (o.Name == "memoryOperand")
                MemoryOperand = o.ToEnum<MemoryAccessMask>();
            else if (o.Name == "tensorAddressingOperands")
                TensorAddressingOperands = o.ToEnum<TensorAddressingOperandsMask>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixLoadTensorNV(int resultType, int resultId, int pointer, int objectId, int tensorLayout, MemoryAccessMask memoryOperand, TensorAddressingOperandsMask tensorAddressingOperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        ObjectId = objectId;
        TensorLayout = tensorLayout;
        MemoryOperand = memoryOperand;
        TensorAddressingOperands = tensorAddressingOperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLoadTensorNV, ResultType, ResultId, Pointer, ObjectId, TensorLayout, (int)MemoryOperand, (int)TensorAddressingOperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLoadTensorNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixStoreTensorNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixStoreTensorNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixStoreTensorNV | (1 << 16);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask MemoryOperand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public TensorAddressingOperandsMask TensorAddressingOperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreTensorNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "objectId")
                ObjectId = o.ToLiteral<int>();
            else if (o.Name == "tensorLayout")
                TensorLayout = o.ToLiteral<int>();
            else if (o.Name == "memoryOperand")
                MemoryOperand = o.ToEnum<MemoryAccessMask>();
            else if (o.Name == "tensorAddressingOperands")
                TensorAddressingOperands = o.ToEnum<TensorAddressingOperandsMask>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixStoreTensorNV(int pointer, int objectId, int tensorLayout, MemoryAccessMask memoryOperand, TensorAddressingOperandsMask tensorAddressingOperands)
    {
        Pointer = pointer;
        ObjectId = objectId;
        TensorLayout = tensorLayout;
        MemoryOperand = memoryOperand;
        TensorAddressingOperands = tensorAddressingOperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixStoreTensorNV, Pointer, ObjectId, TensorLayout, (int)MemoryOperand, (int)TensorAddressingOperands];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixStoreTensorNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixPerElementOpNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixPerElementOpNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixPerElementOpNV | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixPerElementOpNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixPerElementOpNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Func
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixPerElementOpNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "matrix")
                Matrix = o.ToLiteral<int>();
            else if (o.Name == "func")
                Func = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixPerElementOpNV(int resultType, int resultId, int matrix, int func, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Func = func;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixPerElementOpNV, ResultType, ResultId, Matrix, Func, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixPerElementOpNV(OpDataIndex odi) => new(odi);
}

public struct OpTypeTensorLayoutNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeTensorLayoutNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeTensorLayoutNV | (1 << 16);
    }

    public static implicit operator Id(OpTypeTensorLayoutNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeTensorLayoutNV inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClampMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeTensorLayoutNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "dim")
                Dim = o.ToLiteral<int>();
            else if (o.Name == "clampMode")
                ClampMode = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeTensorLayoutNV(int resultId, int dim, int clampMode)
    {
        ResultId = resultId;
        Dim = dim;
        ClampMode = clampMode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeTensorLayoutNV, ResultId, Dim, ClampMode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeTensorLayoutNV(OpDataIndex odi) => new(odi);
}

public struct OpTypeTensorViewNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeTensorViewNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeTensorViewNV | (1 << 16);
    }

    public static implicit operator Id(OpTypeTensorViewNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeTensorViewNV inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HasDimensions
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeTensorViewNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "dim")
                Dim = o.ToLiteral<int>();
            else if (o.Name == "hasDimensions")
                HasDimensions = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTypeTensorViewNV(int resultId, int dim, int hasDimensions, LiteralArray<int> values)
    {
        ResultId = resultId;
        Dim = dim;
        HasDimensions = hasDimensions;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeTensorViewNV, ResultId, Dim, HasDimensions, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeTensorViewNV(OpDataIndex odi) => new(odi);
}

public struct OpCreateTensorLayoutNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateTensorLayoutNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateTensorLayoutNV | (1 << 16);
    }

    public static implicit operator Id(OpCreateTensorLayoutNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCreateTensorLayoutNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCreateTensorLayoutNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCreateTensorLayoutNV(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateTensorLayoutNV, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCreateTensorLayoutNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSetDimensionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetDimensionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetDimensionNV | (1 << 16);
    }

    public static implicit operator Id(OpTensorLayoutSetDimensionNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSetDimensionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSetDimensionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "tensorLayout")
                TensorLayout = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTensorLayoutSetDimensionNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetDimensionNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSetDimensionNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSetStrideNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetStrideNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetStrideNV | (1 << 16);
    }

    public static implicit operator Id(OpTensorLayoutSetStrideNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSetStrideNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSetStrideNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "tensorLayout")
                TensorLayout = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTensorLayoutSetStrideNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetStrideNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSetStrideNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSliceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSliceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSliceNV | (1 << 16);
    }

    public static implicit operator Id(OpTensorLayoutSliceNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSliceNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSliceNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "tensorLayout")
                TensorLayout = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTensorLayoutSliceNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSliceNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSliceNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSetClampValueNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetClampValueNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetClampValueNV | (1 << 16);
    }

    public static implicit operator Id(OpTensorLayoutSetClampValueNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSetClampValueNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSetClampValueNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "tensorLayout")
                TensorLayout = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTensorLayoutSetClampValueNV(int resultType, int resultId, int tensorLayout, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetClampValueNV, ResultType, ResultId, TensorLayout, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSetClampValueNV(OpDataIndex odi) => new(odi);
}

public struct OpCreateTensorViewNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateTensorViewNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateTensorViewNV | (1 << 16);
    }

    public static implicit operator Id(OpCreateTensorViewNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCreateTensorViewNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCreateTensorViewNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCreateTensorViewNV(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateTensorViewNV, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCreateTensorViewNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorViewSetDimensionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetDimensionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetDimensionNV | (1 << 16);
    }

    public static implicit operator Id(OpTensorViewSetDimensionNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTensorViewSetDimensionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTensorViewSetDimensionNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "tensorView")
                TensorView = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTensorViewSetDimensionNV(int resultType, int resultId, int tensorView, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetDimensionNV, ResultType, ResultId, TensorView, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorViewSetDimensionNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorViewSetStrideNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetStrideNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetStrideNV | (1 << 16);
    }

    public static implicit operator Id(OpTensorViewSetStrideNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTensorViewSetStrideNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTensorViewSetStrideNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "tensorView")
                TensorView = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTensorViewSetStrideNV(int resultType, int resultId, int tensorView, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetStrideNV, ResultType, ResultId, TensorView, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorViewSetStrideNV(OpDataIndex odi) => new(odi);
}

public struct OpDemoteToHelperInvocation : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDemoteToHelperInvocation()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDemoteToHelperInvocation | (1 << 16);
    }

    public OpDemoteToHelperInvocation(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpDemoteToHelperInvocation(OpDataIndex odi) => new(odi);
}

public struct OpIsHelperInvocationEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsHelperInvocationEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsHelperInvocationEXT | (1 << 16);
    }

    public static implicit operator Id(OpIsHelperInvocationEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIsHelperInvocationEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIsHelperInvocationEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIsHelperInvocationEXT(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsHelperInvocationEXT, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsHelperInvocationEXT(OpDataIndex odi) => new(odi);
}

public struct OpTensorViewSetClipNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetClipNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetClipNV | (1 << 16);
    }

    public static implicit operator Id(OpTensorViewSetClipNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTensorViewSetClipNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipRowOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipRowSpan
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipColOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipColSpan
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTensorViewSetClipNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "tensorView")
                TensorView = o.ToLiteral<int>();
            else if (o.Name == "clipRowOffset")
                ClipRowOffset = o.ToLiteral<int>();
            else if (o.Name == "clipRowSpan")
                ClipRowSpan = o.ToLiteral<int>();
            else if (o.Name == "clipColOffset")
                ClipColOffset = o.ToLiteral<int>();
            else if (o.Name == "clipColSpan")
                ClipColSpan = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTensorViewSetClipNV(int resultType, int resultId, int tensorView, int clipRowOffset, int clipRowSpan, int clipColOffset, int clipColSpan)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        ClipRowOffset = clipRowOffset;
        ClipRowSpan = clipRowSpan;
        ClipColOffset = clipColOffset;
        ClipColSpan = clipColSpan;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetClipNV, ResultType, ResultId, TensorView, ClipRowOffset, ClipRowSpan, ClipColOffset, ClipColSpan];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorViewSetClipNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSetBlockSizeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetBlockSizeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetBlockSizeNV | (1 << 16);
    }

    public static implicit operator Id(OpTensorLayoutSetBlockSizeNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSetBlockSizeNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSetBlockSizeNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "tensorLayout")
                TensorLayout = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTensorLayoutSetBlockSizeNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetBlockSizeNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSetBlockSizeNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixTransposeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixTransposeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixTransposeNV | (1 << 16);
    }

    public static implicit operator Id(OpCooperativeMatrixTransposeNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixTransposeNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixTransposeNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "matrix")
                Matrix = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCooperativeMatrixTransposeNV(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixTransposeNV, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixTransposeNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToImageNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToImageNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToImageNV | (1 << 16);
    }

    public static implicit operator Id(OpConvertUToImageNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertUToImageNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertUToImageNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertUToImageNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToImageNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToImageNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToSamplerNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToSamplerNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToSamplerNV | (1 << 16);
    }

    public static implicit operator Id(OpConvertUToSamplerNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertUToSamplerNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertUToSamplerNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertUToSamplerNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToSamplerNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToSamplerNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertImageToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertImageToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertImageToUNV | (1 << 16);
    }

    public static implicit operator Id(OpConvertImageToUNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertImageToUNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertImageToUNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertImageToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertImageToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertImageToUNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertSamplerToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSamplerToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSamplerToUNV | (1 << 16);
    }

    public static implicit operator Id(OpConvertSamplerToUNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertSamplerToUNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertSamplerToUNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertSamplerToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSamplerToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertSamplerToUNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToSampledImageNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToSampledImageNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToSampledImageNV | (1 << 16);
    }

    public static implicit operator Id(OpConvertUToSampledImageNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertUToSampledImageNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertUToSampledImageNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertUToSampledImageNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToSampledImageNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToSampledImageNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertSampledImageToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSampledImageToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSampledImageToUNV | (1 << 16);
    }

    public static implicit operator Id(OpConvertSampledImageToUNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertSampledImageToUNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertSampledImageToUNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertSampledImageToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSampledImageToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertSampledImageToUNV(OpDataIndex odi) => new(odi);
}

public struct OpSamplerImageAddressingModeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSamplerImageAddressingModeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSamplerImageAddressingModeNV | (1 << 16);
    }

    public int BitWidth
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSamplerImageAddressingModeNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "bitWidth")
                BitWidth = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSamplerImageAddressingModeNV(int bitWidth)
    {
        BitWidth = bitWidth;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSamplerImageAddressingModeNV, ..BitWidth.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSamplerImageAddressingModeNV(OpDataIndex odi) => new(odi);
}

public struct OpRawAccessChainNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRawAccessChainNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRawAccessChainNV | (1 << 16);
    }

    public static implicit operator Id(OpRawAccessChainNV inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRawAccessChainNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Bytestride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Elementindex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Byteoffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public RawAccessChainOperandsMask? Rawaccesschainoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRawAccessChainNV(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "baseId")
                BaseId = o.ToLiteral<int>();
            else if (o.Name == "bytestride")
                Bytestride = o.ToLiteral<int>();
            else if (o.Name == "elementindex")
                Elementindex = o.ToLiteral<int>();
            else if (o.Name == "byteoffset")
                Byteoffset = o.ToLiteral<int>();
            else if (o.Name == "rawaccesschainoperands")
                if (o.Words.Length > 0)
                    Rawaccesschainoperands = o.ToEnum<RawAccessChainOperandsMask>();
        }

        DataIndex = index;
    }

    public OpRawAccessChainNV(int resultType, int resultId, int baseId, int bytestride, int elementindex, int byteoffset, RawAccessChainOperandsMask? rawaccesschainoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Bytestride = bytestride;
        Elementindex = elementindex;
        Byteoffset = byteoffset;
        Rawaccesschainoperands = rawaccesschainoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRawAccessChainNV, ResultType, ResultId, BaseId, Bytestride, Elementindex, Byteoffset, ..Rawaccesschainoperands is null ? (Span<int>)[] : [(int)Rawaccesschainoperands.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRawAccessChainNV(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupShuffleINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupShuffleINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupShuffleINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InvocationId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupShuffleINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "data")
                Data = o.ToLiteral<int>();
            else if (o.Name == "invocationId")
                InvocationId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupShuffleINTEL(int resultType, int resultId, int data, int invocationId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Data = data;
        InvocationId = invocationId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleINTEL, ResultType, ResultId, Data, InvocationId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupShuffleINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupShuffleDownINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleDownINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleDownINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupShuffleDownINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupShuffleDownINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Current
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Next
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupShuffleDownINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "current")
                Current = o.ToLiteral<int>();
            else if (o.Name == "next")
                Next = o.ToLiteral<int>();
            else if (o.Name == "delta")
                Delta = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupShuffleDownINTEL(int resultType, int resultId, int current, int next, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Current = current;
        Next = next;
        Delta = delta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleDownINTEL, ResultType, ResultId, Current, Next, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupShuffleDownINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupShuffleUpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleUpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleUpINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupShuffleUpINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupShuffleUpINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Previous
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Current
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupShuffleUpINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "previous")
                Previous = o.ToLiteral<int>();
            else if (o.Name == "current")
                Current = o.ToLiteral<int>();
            else if (o.Name == "delta")
                Delta = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupShuffleUpINTEL(int resultType, int resultId, int previous, int current, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Previous = previous;
        Current = current;
        Delta = delta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleUpINTEL, ResultType, ResultId, Previous, Current, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupShuffleUpINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupShuffleXorINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleXorINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleXorINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupShuffleXorINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupShuffleXorINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupShuffleXorINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "data")
                Data = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupShuffleXorINTEL(int resultType, int resultId, int data, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Data = data;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleXorINTEL, ResultType, ResultId, Data, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupShuffleXorINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockReadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupBlockReadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupBlockReadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockReadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "ptr")
                Ptr = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupBlockReadINTEL(int resultType, int resultId, int ptr)
    {
        ResultType = resultType;
        ResultId = resultId;
        Ptr = ptr;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockReadINTEL, ResultType, ResultId, Ptr];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockWriteINTEL | (1 << 16);
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockWriteINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "ptr")
                Ptr = o.ToLiteral<int>();
            else if (o.Name == "data")
                Data = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupBlockWriteINTEL(int ptr, int data)
    {
        Ptr = ptr;
        Data = data;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockWriteINTEL, Ptr, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupImageBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageBlockReadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupImageBlockReadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupImageBlockReadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageBlockReadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupImageBlockReadINTEL(int resultType, int resultId, int image, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageBlockReadINTEL, ResultType, ResultId, Image, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupImageBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupImageBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageBlockWriteINTEL | (1 << 16);
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageBlockWriteINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "data")
                Data = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupImageBlockWriteINTEL(int image, int coordinate, int data)
    {
        Image = image;
        Coordinate = coordinate;
        Data = data;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageBlockWriteINTEL, Image, Coordinate, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupImageBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupImageMediaBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageMediaBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageMediaBlockReadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupImageMediaBlockReadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupImageMediaBlockReadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Height
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageMediaBlockReadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "width")
                Width = o.ToLiteral<int>();
            else if (o.Name == "height")
                Height = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupImageMediaBlockReadINTEL(int resultType, int resultId, int image, int coordinate, int width, int height)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Width = width;
        Height = height;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageMediaBlockReadINTEL, ResultType, ResultId, Image, Coordinate, Width, Height];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupImageMediaBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupImageMediaBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageMediaBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageMediaBlockWriteINTEL | (1 << 16);
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Height
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageMediaBlockWriteINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "image")
                Image = o.ToLiteral<int>();
            else if (o.Name == "coordinate")
                Coordinate = o.ToLiteral<int>();
            else if (o.Name == "width")
                Width = o.ToLiteral<int>();
            else if (o.Name == "height")
                Height = o.ToLiteral<int>();
            else if (o.Name == "data")
                Data = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupImageMediaBlockWriteINTEL(int image, int coordinate, int width, int height, int data)
    {
        Image = image;
        Coordinate = coordinate;
        Width = width;
        Height = height;
        Data = data;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageMediaBlockWriteINTEL, Image, Coordinate, Width, Height, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupImageMediaBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUCountLeadingZerosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUCountLeadingZerosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUCountLeadingZerosINTEL | (1 << 16);
    }

    public static implicit operator Id(OpUCountLeadingZerosINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUCountLeadingZerosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUCountLeadingZerosINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUCountLeadingZerosINTEL(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUCountLeadingZerosINTEL, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUCountLeadingZerosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUCountTrailingZerosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUCountTrailingZerosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUCountTrailingZerosINTEL | (1 << 16);
    }

    public static implicit operator Id(OpUCountTrailingZerosINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUCountTrailingZerosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUCountTrailingZerosINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand")
                Operand = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUCountTrailingZerosINTEL(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUCountTrailingZerosINTEL, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUCountTrailingZerosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAbsISubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAbsISubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAbsISubINTEL | (1 << 16);
    }

    public static implicit operator Id(OpAbsISubINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAbsISubINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAbsISubINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAbsISubINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAbsISubINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAbsISubINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAbsUSubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAbsUSubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAbsUSubINTEL | (1 << 16);
    }

    public static implicit operator Id(OpAbsUSubINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAbsUSubINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAbsUSubINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAbsUSubINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAbsUSubINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAbsUSubINTEL(OpDataIndex odi) => new(odi);
}

public struct OpIAddSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAddSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAddSatINTEL | (1 << 16);
    }

    public static implicit operator Id(OpIAddSatINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIAddSatINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIAddSatINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIAddSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAddSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAddSatINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUAddSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAddSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAddSatINTEL | (1 << 16);
    }

    public static implicit operator Id(OpUAddSatINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUAddSatINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUAddSatINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUAddSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAddSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUAddSatINTEL(OpDataIndex odi) => new(odi);
}

public struct OpIAverageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAverageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAverageINTEL | (1 << 16);
    }

    public static implicit operator Id(OpIAverageINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIAverageINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIAverageINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIAverageINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAverageINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAverageINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUAverageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAverageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAverageINTEL | (1 << 16);
    }

    public static implicit operator Id(OpUAverageINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUAverageINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUAverageINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUAverageINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAverageINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUAverageINTEL(OpDataIndex odi) => new(odi);
}

public struct OpIAverageRoundedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAverageRoundedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAverageRoundedINTEL | (1 << 16);
    }

    public static implicit operator Id(OpIAverageRoundedINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIAverageRoundedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIAverageRoundedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIAverageRoundedINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAverageRoundedINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAverageRoundedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUAverageRoundedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAverageRoundedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAverageRoundedINTEL | (1 << 16);
    }

    public static implicit operator Id(OpUAverageRoundedINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUAverageRoundedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUAverageRoundedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUAverageRoundedINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAverageRoundedINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUAverageRoundedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpISubSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISubSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISubSatINTEL | (1 << 16);
    }

    public static implicit operator Id(OpISubSatINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpISubSatINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpISubSatINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpISubSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISubSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpISubSatINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUSubSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUSubSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUSubSatINTEL | (1 << 16);
    }

    public static implicit operator Id(OpUSubSatINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUSubSatINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUSubSatINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUSubSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUSubSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUSubSatINTEL(OpDataIndex odi) => new(odi);
}

public struct OpIMul32x16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIMul32x16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIMul32x16INTEL | (1 << 16);
    }

    public static implicit operator Id(OpIMul32x16INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpIMul32x16INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpIMul32x16INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpIMul32x16INTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIMul32x16INTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIMul32x16INTEL(OpDataIndex odi) => new(odi);
}

public struct OpUMul32x16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMul32x16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMul32x16INTEL | (1 << 16);
    }

    public static implicit operator Id(OpUMul32x16INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpUMul32x16INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUMul32x16INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "operand1")
                Operand1 = o.ToLiteral<int>();
            else if (o.Name == "operand2")
                Operand2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpUMul32x16INTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMul32x16INTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUMul32x16INTEL(OpDataIndex odi) => new(odi);
}

public struct OpConstantFunctionPointerINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantFunctionPointerINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantFunctionPointerINTEL | (1 << 16);
    }

    public static implicit operator Id(OpConstantFunctionPointerINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConstantFunctionPointerINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Function
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantFunctionPointerINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "function")
                Function = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConstantFunctionPointerINTEL(int resultType, int resultId, int function)
    {
        ResultType = resultType;
        ResultId = resultId;
        Function = function;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantFunctionPointerINTEL, ResultType, ResultId, Function];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantFunctionPointerINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFunctionPointerCallINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionPointerCallINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionPointerCallINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFunctionPointerCallINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFunctionPointerCallINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFunctionPointerCallINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpFunctionPointerCallINTEL(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionPointerCallINTEL, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFunctionPointerCallINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAsmTargetINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmTargetINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmTargetINTEL | (1 << 16);
    }

    public static implicit operator Id(OpAsmTargetINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAsmTargetINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Asmtarget
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAsmTargetINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "asmtarget")
                Asmtarget = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpAsmTargetINTEL(int resultType, int resultId, string asmtarget)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asmtarget = asmtarget;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmTargetINTEL, ResultType, ResultId, ..Asmtarget.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAsmTargetINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAsmINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmINTEL | (1 << 16);
    }

    public static implicit operator Id(OpAsmINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAsmINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Asmtype
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Asminstructions
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Constraints
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAsmINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "asmtype")
                Asmtype = o.ToLiteral<int>();
            else if (o.Name == "target")
                Target = o.ToLiteral<int>();
            else if (o.Name == "asminstructions")
                Asminstructions = o.ToLiteral<string>();
            else if (o.Name == "constraints")
                Constraints = o.ToLiteral<string>();
        }

        DataIndex = index;
    }

    public OpAsmINTEL(int resultType, int resultId, int asmtype, int target, string asminstructions, string constraints)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asmtype = asmtype;
        Target = target;
        Asminstructions = asminstructions;
        Constraints = constraints;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmINTEL, ResultType, ResultId, Asmtype, Target, ..Asminstructions.AsDisposableLiteralValue().Words, ..Constraints.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAsmINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAsmCallINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmCallINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmCallINTEL | (1 << 16);
    }

    public static implicit operator Id(OpAsmCallINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAsmCallINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Asm
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAsmCallINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "asm")
                Asm = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpAsmCallINTEL(int resultType, int resultId, int asm, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asm = asm;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmCallINTEL, ResultType, ResultId, Asm, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAsmCallINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFMinEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFMinEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFMinEXT | (1 << 16);
    }

    public static implicit operator Id(OpAtomicFMinEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicFMinEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicFMinEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicFMinEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFMinEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFMinEXT(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFMaxEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFMaxEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFMaxEXT | (1 << 16);
    }

    public static implicit operator Id(OpAtomicFMaxEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicFMaxEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicFMaxEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicFMaxEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFMaxEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFMaxEXT(OpDataIndex odi) => new(odi);
}

public struct OpAssumeTrueKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAssumeTrueKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAssumeTrueKHR | (1 << 16);
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAssumeTrueKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "condition")
                Condition = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAssumeTrueKHR(int condition)
    {
        Condition = condition;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAssumeTrueKHR, Condition];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAssumeTrueKHR(OpDataIndex odi) => new(odi);
}

public struct OpExpectKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExpectKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExpectKHR | (1 << 16);
    }

    public static implicit operator Id(OpExpectKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpExpectKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ExpectedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExpectKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
            else if (o.Name == "expectedValue")
                ExpectedValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpExpectKHR(int resultType, int resultId, int value, int expectedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        ExpectedValue = expectedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExpectKHR, ResultType, ResultId, Value, ExpectedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExpectKHR(OpDataIndex odi) => new(odi);
}

public struct OpDecorateString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string? AdditionalString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorateString(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "target")
                Target = o.ToLiteral<int>();
            else if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
            else if (o.Name == "additionalString")
                AdditionalString = o.ToLiteral<string?>();
        }

        DataIndex = index;
    }

    public OpDecorateString(int target, Decoration decoration, string? additionalString = null)
    {
        Target = target;
        Decoration = decoration;
        AdditionalString = additionalString;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorateString, Target, (int)Decoration, ..AdditionalString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDecorateString(OpDataIndex odi) => new(odi);
}

public struct OpMemberDecorateString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public int StructType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string? AdditionalString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberDecorateString(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "structType")
                StructType = o.ToLiteral<int>();
            else if (o.Name == "member")
                Member = o.ToLiteral<int>();
            else if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
            else if (o.Name == "additionalString")
                AdditionalString = o.ToLiteral<string?>();
        }

        DataIndex = index;
    }

    public OpMemberDecorateString(int structType, int member, Decoration decoration, string? additionalString = null)
    {
        StructType = structType;
        Member = member;
        Decoration = decoration;
        AdditionalString = additionalString;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberDecorateString, StructType, ..Member.AsDisposableLiteralValue().Words, (int)Decoration, ..AdditionalString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemberDecorateString(OpDataIndex odi) => new(odi);
}

public struct OpVmeImageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVmeImageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVmeImageINTEL | (1 << 16);
    }

    public static implicit operator Id(OpVmeImageINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpVmeImageINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampler
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpVmeImageINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "imageType")
                ImageType = o.ToLiteral<int>();
            else if (o.Name == "sampler")
                Sampler = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpVmeImageINTEL(int resultType, int resultId, int imageType, int sampler)
    {
        ResultType = resultType;
        ResultId = resultId;
        ImageType = imageType;
        Sampler = sampler;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVmeImageINTEL, ResultType, ResultId, ImageType, Sampler];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVmeImageINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeVmeImageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVmeImageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVmeImageINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeVmeImageINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeVmeImageINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeVmeImageINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "imageType")
                ImageType = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeVmeImageINTEL(int resultId, int imageType)
    {
        ResultId = resultId;
        ImageType = imageType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVmeImageINTEL, ResultId, ImageType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeVmeImageINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImePayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcImePayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcImePayloadINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImePayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcImePayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImePayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcRefPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcRefPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcRefPayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcRefPayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcRefPayloadINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcRefPayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcRefPayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcRefPayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcRefPayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcSicPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcSicPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcSicPayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcSicPayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcSicPayloadINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcSicPayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcSicPayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcSicPayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcSicPayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcMcePayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcMcePayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcMcePayloadINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcMcePayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcMcePayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcMcePayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcMceResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcMceResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcMceResultINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcMceResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcMceResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcMceResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcMceResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcImeResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeResultINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcImeResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeResultSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcImeResultSingleReferenceStreamoutINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeResultSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultSingleReferenceStreamoutINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeResultDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultDualReferenceStreamoutINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcImeResultDualReferenceStreamoutINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeResultDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultDualReferenceStreamoutINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeSingleReferenceStreaminINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcImeSingleReferenceStreaminINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeSingleReferenceStreaminINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeDualReferenceStreaminINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcImeDualReferenceStreaminINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeDualReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeDualReferenceStreaminINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcRefResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcRefResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcRefResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcRefResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcRefResultINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcRefResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcRefResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcRefResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcRefResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcSicResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcSicResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcSicResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeAvcSicResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeAvcSicResultINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeAvcSicResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpTypeAvcSicResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcSicResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcSicResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sliceType")
                SliceType = o.ToLiteral<int>();
            else if (o.Name == "qp")
                Qp = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceBasePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "referenceBasePenalty")
                ReferenceBasePenalty = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(int resultType, int resultId, int referenceBasePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReferenceBasePenalty = referenceBasePenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL, ResultType, ResultId, ReferenceBasePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sliceType")
                SliceType = o.ToLiteral<int>();
            else if (o.Name == "qp")
                Qp = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetInterShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterShapePenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceSetInterShapePenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetInterShapePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedShapePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packedShapePenalty")
                PackedShapePenalty = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(int resultType, int resultId, int packedShapePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedShapePenalty = packedShapePenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterShapePenaltyINTEL, ResultType, ResultId, PackedShapePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sliceType")
                SliceType = o.ToLiteral<int>();
            else if (o.Name == "qp")
                Qp = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetInterDirectionPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceSetInterDirectionPenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetInterDirectionPenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DirectionCost
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "directionCost")
                DirectionCost = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(int resultType, int resultId, int directionCost, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        DirectionCost = directionCost;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL, ResultType, ResultId, DirectionCost, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sliceType")
                SliceType = o.ToLiteral<int>();
            else if (o.Name == "qp")
                Qp = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sliceType")
                SliceType = o.ToLiteral<int>();
            else if (o.Name == "qp")
                Qp = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedCostCenterDelta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedCostTable
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CostPrecision
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packedCostCenterDelta")
                PackedCostCenterDelta = o.ToLiteral<int>();
            else if (o.Name == "packedCostTable")
                PackedCostTable = o.ToLiteral<int>();
            else if (o.Name == "costPrecision")
                CostPrecision = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(int resultType, int resultId, int packedCostCenterDelta, int packedCostTable, int costPrecision, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedCostCenterDelta = packedCostCenterDelta;
        PackedCostTable = packedCostTable;
        CostPrecision = costPrecision;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL, ResultType, ResultId, PackedCostCenterDelta, PackedCostTable, CostPrecision, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sliceType")
                SliceType = o.ToLiteral<int>();
            else if (o.Name == "qp")
                Qp = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetAcOnlyHaarINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetAcOnlyHaarINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceSetAcOnlyHaarINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetAcOnlyHaarINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetAcOnlyHaarINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SourceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "sourceFieldPolarity")
                SourceFieldPolarity = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(int resultType, int resultId, int sourceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SourceFieldPolarity = sourceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL, ResultType, ResultId, SourceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "referenceFieldPolarity")
                ReferenceFieldPolarity = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(int resultType, int resultId, int referenceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReferenceFieldPolarity = referenceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL, ResultType, ResultId, ReferenceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ForwardReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BackwardReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "forwardReferenceFieldPolarity")
                ForwardReferenceFieldPolarity = o.ToLiteral<int>();
            else if (o.Name == "backwardReferenceFieldPolarity")
                BackwardReferenceFieldPolarity = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(int resultType, int resultId, int forwardReferenceFieldPolarity, int backwardReferenceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ForwardReferenceFieldPolarity = forwardReferenceFieldPolarity;
        BackwardReferenceFieldPolarity = backwardReferenceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL, ResultType, ResultId, ForwardReferenceFieldPolarity, BackwardReferenceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToImePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToImePayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceConvertToImePayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToImePayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToImePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToImePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToImeResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToImeResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceConvertToImeResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToImeResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToImeResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToImeResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToRefPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToRefPayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceConvertToRefPayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToRefPayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToRefPayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToRefPayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToRefResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToRefResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceConvertToRefResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToRefResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToRefResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToRefResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToSicPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToSicPayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceConvertToSicPayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToSicPayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToSicPayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToSicPayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToSicResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToSicResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceConvertToSicResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToSicResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToSicResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToSicResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetMotionVectorsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetMotionVectorsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetMotionVectorsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetMotionVectorsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterDistortionsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetInterDistortionsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterDistortionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterDistortionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetBestInterDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetBestInterDistortionsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetBestInterDistortionsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetBestInterDistortionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetBestInterDistortionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterMajorShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMajorShapeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetInterMajorShapeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterMajorShapeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMajorShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMajorShapeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterMinorShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMinorShapeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetInterMinorShapeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterMinorShapeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMinorShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMinorShapeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterDirectionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterDirectionsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetInterDirectionsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterDirectionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterDirectionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterDirectionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterMotionVectorCountINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMotionVectorCountINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetInterMotionVectorCountINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterMotionVectorCountINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMotionVectorCountINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterReferenceIdsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetInterReferenceIdsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterReferenceIdsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterReferenceIdsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceParameterFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.ToLiteral<int>();
            else if (o.Name == "packedReferenceParameterFieldPolarities")
                PackedReferenceParameterFieldPolarities = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(int resultType, int resultId, int packedReferenceIds, int packedReferenceParameterFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceParameterFieldPolarities = packedReferenceParameterFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL, ResultType, ResultId, PackedReferenceIds, PackedReferenceParameterFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeInitializeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeInitializeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeInitializeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SADAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeInitializeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcCoord")
                SrcCoord = o.ToLiteral<int>();
            else if (o.Name == "partitionMask")
                PartitionMask = o.ToLiteral<int>();
            else if (o.Name == "sADAdjustment")
                SADAdjustment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeInitializeINTEL(int resultType, int resultId, int srcCoord, int partitionMask, int sADAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        PartitionMask = partitionMask;
        SADAdjustment = sADAdjustment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeInitializeINTEL, ResultType, ResultId, SrcCoord, PartitionMask, SADAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetSingleReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeSetSingleReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetSingleReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "refOffset")
                RefOffset = o.ToLiteral<int>();
            else if (o.Name == "searchWindowConfig")
                SearchWindowConfig = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL(int resultType, int resultId, int refOffset, int searchWindowConfig, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        RefOffset = refOffset;
        SearchWindowConfig = searchWindowConfig;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetSingleReferenceINTEL, ResultType, ResultId, RefOffset, SearchWindowConfig, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetDualReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeSetDualReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetDualReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IdSearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "fwdRefOffset")
                FwdRefOffset = o.ToLiteral<int>();
            else if (o.Name == "bwdRefOffset")
                BwdRefOffset = o.ToLiteral<int>();
            else if (o.Name == "idSearchWindowConfig")
                IdSearchWindowConfig = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL(int resultType, int resultId, int fwdRefOffset, int bwdRefOffset, int idSearchWindowConfig, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        FwdRefOffset = fwdRefOffset;
        BwdRefOffset = bwdRefOffset;
        IdSearchWindowConfig = idSearchWindowConfig;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetDualReferenceINTEL, ResultType, ResultId, FwdRefOffset, BwdRefOffset, IdSearchWindowConfig, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeRefWindowSizeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeRefWindowSizeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeRefWindowSizeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeRefWindowSizeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DualRef
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "searchWindowConfig")
                SearchWindowConfig = o.ToLiteral<int>();
            else if (o.Name == "dualRef")
                DualRef = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL(int resultType, int resultId, int searchWindowConfig, int dualRef)
    {
        ResultType = resultType;
        ResultId = resultId;
        SearchWindowConfig = searchWindowConfig;
        DualRef = dualRef;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeRefWindowSizeINTEL, ResultType, ResultId, SearchWindowConfig, DualRef];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeRefWindowSizeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeAdjustRefOffsetINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeAdjustRefOffsetINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeAdjustRefOffsetINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeAdjustRefOffsetINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefWindowSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "refOffset")
                RefOffset = o.ToLiteral<int>();
            else if (o.Name == "srcCoord")
                SrcCoord = o.ToLiteral<int>();
            else if (o.Name == "refWindowSize")
                RefWindowSize = o.ToLiteral<int>();
            else if (o.Name == "imageSize")
                ImageSize = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL(int resultType, int resultId, int refOffset, int srcCoord, int refWindowSize, int imageSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        RefOffset = refOffset;
        SrcCoord = srcCoord;
        RefWindowSize = refWindowSize;
        ImageSize = imageSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeAdjustRefOffsetINTEL, ResultType, ResultId, RefOffset, SrcCoord, RefWindowSize, ImageSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeAdjustRefOffsetINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeConvertToMcePayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeConvertToMcePayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeConvertToMcePayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetMaxMotionVectorCountINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeSetMaxMotionVectorCountINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetMaxMotionVectorCountINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxMotionVectorCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "maxMotionVectorCount")
                MaxMotionVectorCount = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(int resultType, int resultId, int maxMotionVectorCount, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        MaxMotionVectorCount = maxMotionVectorCount;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL, ResultType, ResultId, MaxMotionVectorCount, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Threshold
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "threshold")
                Threshold = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(int resultType, int resultId, int threshold, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Threshold = threshold;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL, ResultType, ResultId, Threshold, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetWeightedSadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetWeightedSadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeSetWeightedSadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetWeightedSadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedSadWeights
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packedSadWeights")
                PackedSadWeights = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL(int resultType, int resultId, int packedSadWeights, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedSadWeights = packedSadWeights;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetWeightedSadINTEL, ResultType, ResultId, PackedSadWeights, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetWeightedSadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "refImage")
                RefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeEvaluateWithDualReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "fwdRefImage")
                FwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "bwdRefImage")
                BwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "refImage")
                RefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "streaminComponents")
                StreaminComponents = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(int resultType, int resultId, int srcImage, int refImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL, ResultType, ResultId, SrcImage, RefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "fwdRefImage")
                FwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "bwdRefImage")
                BwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "streaminComponents")
                StreaminComponents = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "refImage")
                RefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "fwdRefImage")
                FwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "bwdRefImage")
                BwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "refImage")
                RefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "streaminComponents")
                StreaminComponents = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(int resultType, int resultId, int srcImage, int refImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL, ResultType, ResultId, SrcImage, RefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "fwdRefImage")
                FwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "bwdRefImage")
                BwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "streaminComponents")
                StreaminComponents = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeConvertToMceResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeConvertToMceResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeConvertToMceResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetSingleReferenceStreaminINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetDualReferenceStreaminINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetDualReferenceStreaminINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetDualReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetDualReferenceStreaminINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeStripDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeStripDualReferenceStreamoutINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeStripDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "majorShape")
                MajorShape = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "majorShape")
                MajorShape = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "majorShape")
                MajorShape = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "majorShape")
                MajorShape = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "majorShape")
                MajorShape = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
            else if (o.Name == "majorShape")
                MajorShape = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetBorderReachedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetBorderReachedINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetBorderReachedINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetBorderReachedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageSelect
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "imageSelect")
                ImageSelect = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL(int resultType, int resultId, int imageSelect, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ImageSelect = imageSelect;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetBorderReachedINTEL, ResultType, ResultId, ImageSelect, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetBorderReachedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcFmeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcFmeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcFmeInitializeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcFmeInitializeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcFmeInitializeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PixelResolution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcFmeInitializeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcCoord")
                SrcCoord = o.ToLiteral<int>();
            else if (o.Name == "motionVectors")
                MotionVectors = o.ToLiteral<int>();
            else if (o.Name == "majorShapes")
                MajorShapes = o.ToLiteral<int>();
            else if (o.Name == "minorShapes")
                MinorShapes = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "pixelResolution")
                PixelResolution = o.ToLiteral<int>();
            else if (o.Name == "sadAdjustment")
                SadAdjustment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcFmeInitializeINTEL(int resultType, int resultId, int srcCoord, int motionVectors, int majorShapes, int minorShapes, int direction, int pixelResolution, int sadAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        MotionVectors = motionVectors;
        MajorShapes = majorShapes;
        MinorShapes = minorShapes;
        Direction = direction;
        PixelResolution = pixelResolution;
        SadAdjustment = sadAdjustment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcFmeInitializeINTEL, ResultType, ResultId, SrcCoord, MotionVectors, MajorShapes, MinorShapes, Direction, PixelResolution, SadAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcFmeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcBmeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcBmeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcBmeInitializeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcBmeInitializeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcBmeInitializeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PixelResolution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BidirectionalWeight
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcBmeInitializeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcCoord")
                SrcCoord = o.ToLiteral<int>();
            else if (o.Name == "motionVectors")
                MotionVectors = o.ToLiteral<int>();
            else if (o.Name == "majorShapes")
                MajorShapes = o.ToLiteral<int>();
            else if (o.Name == "minorShapes")
                MinorShapes = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
            else if (o.Name == "pixelResolution")
                PixelResolution = o.ToLiteral<int>();
            else if (o.Name == "bidirectionalWeight")
                BidirectionalWeight = o.ToLiteral<int>();
            else if (o.Name == "sadAdjustment")
                SadAdjustment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcBmeInitializeINTEL(int resultType, int resultId, int srcCoord, int motionVectors, int majorShapes, int minorShapes, int direction, int pixelResolution, int bidirectionalWeight, int sadAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        MotionVectors = motionVectors;
        MajorShapes = majorShapes;
        MinorShapes = minorShapes;
        Direction = direction;
        PixelResolution = pixelResolution;
        BidirectionalWeight = bidirectionalWeight;
        SadAdjustment = sadAdjustment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcBmeInitializeINTEL, ResultType, ResultId, SrcCoord, MotionVectors, MajorShapes, MinorShapes, Direction, PixelResolution, BidirectionalWeight, SadAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcBmeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefConvertToMcePayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcRefConvertToMcePayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefConvertToMcePayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefSetBidirectionalMixDisableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcRefSetBidirectionalMixDisableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefSetBidirectionalMixDisableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefSetBilinearFilterEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefSetBilinearFilterEnableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcRefSetBilinearFilterEnableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefSetBilinearFilterEnableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefSetBilinearFilterEnableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "refImage")
                RefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcRefEvaluateWithDualReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "fwdRefImage")
                FwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "bwdRefImage")
                BwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.ToLiteral<int>();
            else if (o.Name == "packedReferenceFieldPolarities")
                PackedReferenceFieldPolarities = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int packedReferenceFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceFieldPolarities = packedReferenceFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, PackedReferenceFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefConvertToMceResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcRefConvertToMceResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefConvertToMceResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicInitializeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicInitializeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicInitializeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicInitializeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcCoord")
                SrcCoord = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicInitializeINTEL(int resultType, int resultId, int srcCoord)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicInitializeINTEL, ResultType, ResultId, SrcCoord];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicInitializeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConfigureSkcINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureSkcINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureSkcINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicConfigureSkcINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConfigureSkcINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipBlockPartitionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipMotionVectorMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BidirectionalWeight
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConfigureSkcINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "skipBlockPartitionType")
                SkipBlockPartitionType = o.ToLiteral<int>();
            else if (o.Name == "skipMotionVectorMask")
                SkipMotionVectorMask = o.ToLiteral<int>();
            else if (o.Name == "motionVectors")
                MotionVectors = o.ToLiteral<int>();
            else if (o.Name == "bidirectionalWeight")
                BidirectionalWeight = o.ToLiteral<int>();
            else if (o.Name == "sadAdjustment")
                SadAdjustment = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicConfigureSkcINTEL(int resultType, int resultId, int skipBlockPartitionType, int skipMotionVectorMask, int motionVectors, int bidirectionalWeight, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SkipBlockPartitionType = skipBlockPartitionType;
        SkipMotionVectorMask = skipMotionVectorMask;
        MotionVectors = motionVectors;
        BidirectionalWeight = bidirectionalWeight;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureSkcINTEL, ResultType, ResultId, SkipBlockPartitionType, SkipMotionVectorMask, MotionVectors, BidirectionalWeight, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureSkcINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConfigureIpeLumaINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureIpeLumaINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicConfigureIpeLumaINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConfigureIpeLumaINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaIntraPartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntraNeighbourAvailabilty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerLumaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperRightEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "lumaIntraPartitionMask")
                LumaIntraPartitionMask = o.ToLiteral<int>();
            else if (o.Name == "intraNeighbourAvailabilty")
                IntraNeighbourAvailabilty = o.ToLiteral<int>();
            else if (o.Name == "leftEdgeLumaPixels")
                LeftEdgeLumaPixels = o.ToLiteral<int>();
            else if (o.Name == "upperLeftCornerLumaPixel")
                UpperLeftCornerLumaPixel = o.ToLiteral<int>();
            else if (o.Name == "upperEdgeLumaPixels")
                UpperEdgeLumaPixels = o.ToLiteral<int>();
            else if (o.Name == "upperRightEdgeLumaPixels")
                UpperRightEdgeLumaPixels = o.ToLiteral<int>();
            else if (o.Name == "sadAdjustment")
                SadAdjustment = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL(int resultType, int resultId, int lumaIntraPartitionMask, int intraNeighbourAvailabilty, int leftEdgeLumaPixels, int upperLeftCornerLumaPixel, int upperEdgeLumaPixels, int upperRightEdgeLumaPixels, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaIntraPartitionMask = lumaIntraPartitionMask;
        IntraNeighbourAvailabilty = intraNeighbourAvailabilty;
        LeftEdgeLumaPixels = leftEdgeLumaPixels;
        UpperLeftCornerLumaPixel = upperLeftCornerLumaPixel;
        UpperEdgeLumaPixels = upperEdgeLumaPixels;
        UpperRightEdgeLumaPixels = upperRightEdgeLumaPixels;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureIpeLumaINTEL, ResultType, ResultId, LumaIntraPartitionMask, IntraNeighbourAvailabilty, LeftEdgeLumaPixels, UpperLeftCornerLumaPixel, UpperEdgeLumaPixels, UpperRightEdgeLumaPixels, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConfigureIpeLumaChromaINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicConfigureIpeLumaChromaINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConfigureIpeLumaChromaINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaIntraPartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntraNeighbourAvailabilty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerLumaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperRightEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeChromaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerChromaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeChromaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "lumaIntraPartitionMask")
                LumaIntraPartitionMask = o.ToLiteral<int>();
            else if (o.Name == "intraNeighbourAvailabilty")
                IntraNeighbourAvailabilty = o.ToLiteral<int>();
            else if (o.Name == "leftEdgeLumaPixels")
                LeftEdgeLumaPixels = o.ToLiteral<int>();
            else if (o.Name == "upperLeftCornerLumaPixel")
                UpperLeftCornerLumaPixel = o.ToLiteral<int>();
            else if (o.Name == "upperEdgeLumaPixels")
                UpperEdgeLumaPixels = o.ToLiteral<int>();
            else if (o.Name == "upperRightEdgeLumaPixels")
                UpperRightEdgeLumaPixels = o.ToLiteral<int>();
            else if (o.Name == "leftEdgeChromaPixels")
                LeftEdgeChromaPixels = o.ToLiteral<int>();
            else if (o.Name == "upperLeftCornerChromaPixel")
                UpperLeftCornerChromaPixel = o.ToLiteral<int>();
            else if (o.Name == "upperEdgeChromaPixels")
                UpperEdgeChromaPixels = o.ToLiteral<int>();
            else if (o.Name == "sadAdjustment")
                SadAdjustment = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(int resultType, int resultId, int lumaIntraPartitionMask, int intraNeighbourAvailabilty, int leftEdgeLumaPixels, int upperLeftCornerLumaPixel, int upperEdgeLumaPixels, int upperRightEdgeLumaPixels, int leftEdgeChromaPixels, int upperLeftCornerChromaPixel, int upperEdgeChromaPixels, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaIntraPartitionMask = lumaIntraPartitionMask;
        IntraNeighbourAvailabilty = intraNeighbourAvailabilty;
        LeftEdgeLumaPixels = leftEdgeLumaPixels;
        UpperLeftCornerLumaPixel = upperLeftCornerLumaPixel;
        UpperEdgeLumaPixels = upperEdgeLumaPixels;
        UpperRightEdgeLumaPixels = upperRightEdgeLumaPixels;
        LeftEdgeChromaPixels = leftEdgeChromaPixels;
        UpperLeftCornerChromaPixel = upperLeftCornerChromaPixel;
        UpperEdgeChromaPixels = upperEdgeChromaPixels;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL, ResultType, ResultId, LumaIntraPartitionMask, IntraNeighbourAvailabilty, LeftEdgeLumaPixels, UpperLeftCornerLumaPixel, UpperEdgeLumaPixels, UpperRightEdgeLumaPixels, LeftEdgeChromaPixels, UpperLeftCornerChromaPixel, UpperEdgeChromaPixels, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetMotionVectorMaskINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetMotionVectorMaskINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetMotionVectorMaskINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetMotionVectorMaskINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipBlockPartitionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "skipBlockPartitionType")
                SkipBlockPartitionType = o.ToLiteral<int>();
            else if (o.Name == "direction")
                Direction = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(int resultType, int resultId, int skipBlockPartitionType, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        SkipBlockPartitionType = skipBlockPartitionType;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetMotionVectorMaskINTEL, ResultType, ResultId, SkipBlockPartitionType, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConvertToMcePayloadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicConvertToMcePayloadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConvertToMcePayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedShapePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packedShapePenalty")
                PackedShapePenalty = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(int resultType, int resultId, int packedShapePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedShapePenalty = packedShapePenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL, ResultType, ResultId, PackedShapePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaModePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaPackedNeighborModes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaPackedNonDcPenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "lumaModePenalty")
                LumaModePenalty = o.ToLiteral<int>();
            else if (o.Name == "lumaPackedNeighborModes")
                LumaPackedNeighborModes = o.ToLiteral<int>();
            else if (o.Name == "lumaPackedNonDcPenalty")
                LumaPackedNonDcPenalty = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(int resultType, int resultId, int lumaModePenalty, int lumaPackedNeighborModes, int lumaPackedNonDcPenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaModePenalty = lumaModePenalty;
        LumaPackedNeighborModes = lumaPackedNeighborModes;
        LumaPackedNonDcPenalty = lumaPackedNonDcPenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL, ResultType, ResultId, LumaModePenalty, LumaPackedNeighborModes, LumaPackedNonDcPenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ChromaModeBasePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "chromaModeBasePenalty")
                ChromaModeBasePenalty = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(int resultType, int resultId, int chromaModeBasePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ChromaModeBasePenalty = chromaModeBasePenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL, ResultType, ResultId, ChromaModeBasePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetBilinearFilterEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetBilinearFilterEnableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicSetBilinearFilterEnableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetBilinearFilterEnableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetBilinearFilterEnableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedSadCoefficients
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packedSadCoefficients")
                PackedSadCoefficients = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(int resultType, int resultId, int packedSadCoefficients, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedSadCoefficients = packedSadCoefficients;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL, ResultType, ResultId, PackedSadCoefficients, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockBasedSkipType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "blockBasedSkipType")
                BlockBasedSkipType = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(int resultType, int resultId, int blockBasedSkipType, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        BlockBasedSkipType = blockBasedSkipType;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL, ResultType, ResultId, BlockBasedSkipType, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateIpeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateIpeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicEvaluateIpeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateIpeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL(int resultType, int resultId, int srcImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateIpeINTEL, ResultType, ResultId, SrcImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateIpeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "refImage")
                RefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicEvaluateWithDualReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "fwdRefImage")
                FwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "bwdRefImage")
                BwdRefImage = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "srcImage")
                SrcImage = o.ToLiteral<int>();
            else if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.ToLiteral<int>();
            else if (o.Name == "packedReferenceFieldPolarities")
                PackedReferenceFieldPolarities = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int packedReferenceFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceFieldPolarities = packedReferenceFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, PackedReferenceFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConvertToMceResultINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicConvertToMceResultINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConvertToMceResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetIpeLumaShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetIpeLumaShapeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetIpeLumaShapeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetIpeLumaShapeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetIpeLumaShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetPackedIpeLumaModesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetPackedIpeLumaModesINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetPackedIpeLumaModesINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetIpeChromaModeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetIpeChromaModeINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetIpeChromaModeINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetIpeChromaModeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetIpeChromaModeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetIpeChromaModeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetInterRawSadsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetInterRawSadsINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSubgroupAvcSicGetInterRawSadsINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetInterRawSadsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "payload")
                Payload = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetInterRawSadsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetInterRawSadsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpVariableLengthArrayINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVariableLengthArrayINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVariableLengthArrayINTEL | (1 << 16);
    }

    public static implicit operator Id(OpVariableLengthArrayINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpVariableLengthArrayINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Lenght
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpVariableLengthArrayINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "lenght")
                Lenght = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpVariableLengthArrayINTEL(int resultType, int resultId, int lenght)
    {
        ResultType = resultType;
        ResultId = resultId;
        Lenght = lenght;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVariableLengthArrayINTEL, ResultType, ResultId, Lenght];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVariableLengthArrayINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSaveMemoryINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSaveMemoryINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSaveMemoryINTEL | (1 << 16);
    }

    public static implicit operator Id(OpSaveMemoryINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpSaveMemoryINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSaveMemoryINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpSaveMemoryINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSaveMemoryINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSaveMemoryINTEL(OpDataIndex odi) => new(odi);
}

public struct OpRestoreMemoryINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRestoreMemoryINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRestoreMemoryINTEL | (1 << 16);
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRestoreMemoryINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "ptr")
                Ptr = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRestoreMemoryINTEL(int ptr)
    {
        Ptr = ptr;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRestoreMemoryINTEL, Ptr];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRestoreMemoryINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSinCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinCosPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatSinCosPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSinCosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FromSign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSinCosPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "fromSign")
                FromSign = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatSinCosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int fromSign, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        FromSign = fromSign;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinCosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..FromSign.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSinCosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCastINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatCastINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCastINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCastINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatCastINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCastINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCastFromIntINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastFromIntINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastFromIntINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatCastFromIntINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCastFromIntINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FromSign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCastFromIntINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "fromSign")
                FromSign = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatCastFromIntINTEL(int resultType, int resultId, int a, int mout, int fromSign, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        Mout = mout;
        FromSign = fromSign;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastFromIntINTEL, ResultType, ResultId, A, ..Mout.AsDisposableLiteralValue().Words, ..FromSign.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCastFromIntINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCastToIntINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastToIntINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastToIntINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatCastToIntINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCastToIntINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCastToIntINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatCastToIntINTEL(int resultType, int resultId, int a, int m1, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastToIntINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCastToIntINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatAddINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatAddINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatAddINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatAddINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatAddINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatAddINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatAddINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatAddINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatAddINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSubINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatSubINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSubINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSubINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatSubINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSubINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSubINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatMulINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatMulINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatMulINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatMulINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatMulINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatMulINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatMulINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatMulINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatMulINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatDivINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatDivINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatDivINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatDivINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatDivINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatDivINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatDivINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatDivINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatDivINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatGTINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatGTINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatGTINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatGTINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatGTINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatGTINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatGTINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatGTINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatGTINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatGEINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatGEINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatGEINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatGEINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatGEINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatGEINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatGEINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatGEINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatGEINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLTINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLTINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLTINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatLTINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLTINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLTINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatLTINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLTINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLTINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLEINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLEINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLEINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatLEINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLEINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLEINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatLEINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLEINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLEINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatEQINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatEQINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatEQINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatEQINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatEQINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatEQINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatEQINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatEQINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatEQINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatRecipINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatRecipINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatRecipINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatRecipINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatRecipINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatRecipINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatRecipINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatRecipINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatRecipINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatRSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatRSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatRSqrtINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatRSqrtINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatRSqrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatRSqrtINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatRSqrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatRSqrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatRSqrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCbrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCbrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCbrtINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatCbrtINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCbrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCbrtINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatCbrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCbrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCbrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatHypotINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatHypotINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatHypotINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatHypotINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatHypotINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatHypotINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatHypotINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatHypotINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatHypotINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSqrtINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatSqrtINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSqrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSqrtINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatSqrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSqrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSqrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLogINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLogINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLogINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatLogINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLogINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLogINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatLogINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLogINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLogINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLog2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog2INTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatLog2INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLog2INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLog2INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatLog2INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLog2INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLog10INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog10INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog10INTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatLog10INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLog10INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLog10INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatLog10INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog10INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLog10INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLog1pINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog1pINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog1pINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatLog1pINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLog1pINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLog1pINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatLog1pINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog1pINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLog1pINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatExpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExpINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatExpINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatExpINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatExpINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatExpINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExpINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatExpINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatExp2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExp2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExp2INTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatExp2INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatExp2INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatExp2INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatExp2INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExp2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatExp2INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatExp10INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExp10INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExp10INTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatExp10INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatExp10INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatExp10INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatExp10INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExp10INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatExp10INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatExpm1INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExpm1INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExpm1INTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatExpm1INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatExpm1INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatExpm1INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatExpm1INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExpm1INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatExpm1INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatSinINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSinINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSinINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatSinINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSinINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCosINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatCosINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCosINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatCosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSinCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinCosINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatSinCosINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSinCosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSinCosINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatSinCosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinCosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSinCosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatSinPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSinPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSinPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatSinPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSinPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCosPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatCosPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCosPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatCosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatASinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatASinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatASinINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatASinINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatASinINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatASinINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatASinINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatASinINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatASinINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatASinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatASinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatASinPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatASinPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatASinPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatASinPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatASinPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatASinPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatASinPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatACosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatACosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatACosINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatACosINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatACosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatACosINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatACosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatACosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatACosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatACosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatACosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatACosPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatACosPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatACosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatACosPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatACosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatACosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatACosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatATanINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATanINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATanINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatATanINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatATanINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatATanINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatATanINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATanINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatATanINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatATanPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATanPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATanPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatATanPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatATanPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatATanPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatATanPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATanPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatATanPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatATan2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATan2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATan2INTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatATan2INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatATan2INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatATan2INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatATan2INTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATan2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatATan2INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatPowINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatPowINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatPowINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatPowINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatPowINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatPowINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatPowRINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowRINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowRINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatPowRINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatPowRINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatPowRINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "m2")
                M2 = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatPowRINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowRINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatPowRINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatPowNINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowNINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowNINTEL | (1 << 16);
    }

    public static implicit operator Id(OpArbitraryFloatPowNINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatPowNINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatPowNINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "a")
                A = o.ToLiteral<int>();
            else if (o.Name == "m1")
                M1 = o.ToLiteral<int>();
            else if (o.Name == "b")
                B = o.ToLiteral<int>();
            else if (o.Name == "mout")
                Mout = o.ToLiteral<int>();
            else if (o.Name == "enableSubnormals")
                EnableSubnormals = o.ToLiteral<int>();
            else if (o.Name == "roundingMode")
                RoundingMode = o.ToLiteral<int>();
            else if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArbitraryFloatPowNINTEL(int resultType, int resultId, int a, int m1, int b, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowNINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatPowNINTEL(OpDataIndex odi) => new(odi);
}

public struct OpLoopControlINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoopControlINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoopControlINTEL | (1 << 16);
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLoopControlINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpLoopControlINTEL(LiteralArray<int> values)
    {
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoopControlINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLoopControlINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAliasDomainDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasDomainDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasDomainDeclINTEL | (1 << 16);
    }

    public static implicit operator Id(OpAliasDomainDeclINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAliasDomainDeclINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAliasDomainDeclINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "name")
                if (o.Words.Length > 0)
                    Name = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpAliasDomainDeclINTEL(int resultId, int? name)
    {
        ResultId = resultId;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasDomainDeclINTEL, ResultId, ..Name is null ? (Span<int>)[] : [Name.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAliasDomainDeclINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAliasScopeDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasScopeDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasScopeDeclINTEL | (1 << 16);
    }

    public static implicit operator Id(OpAliasScopeDeclINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAliasScopeDeclINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AliasDomain
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAliasScopeDeclINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "aliasDomain")
                AliasDomain = o.ToLiteral<int>();
            else if (o.Name == "name")
                if (o.Words.Length > 0)
                    Name = o.ToLiteral<int?>();
        }

        DataIndex = index;
    }

    public OpAliasScopeDeclINTEL(int resultId, int aliasDomain, int? name)
    {
        ResultId = resultId;
        AliasDomain = aliasDomain;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasScopeDeclINTEL, ResultId, AliasDomain, ..Name is null ? (Span<int>)[] : [Name.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAliasScopeDeclINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAliasScopeListDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasScopeListDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasScopeListDeclINTEL | (1 << 16);
    }

    public static implicit operator Id(OpAliasScopeListDeclINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAliasScopeListDeclINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAliasScopeListDeclINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpAliasScopeListDeclINTEL(int resultId, LiteralArray<int> values)
    {
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasScopeListDeclINTEL, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAliasScopeListDeclINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSqrtINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedSqrtINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedSqrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedSqrtINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedSqrtINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSqrtINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSqrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedRecipINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedRecipINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedRecipINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedRecipINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedRecipINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedRecipINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedRecipINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedRecipINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedRecipINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedRsqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedRsqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedRsqrtINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedRsqrtINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedRsqrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedRsqrtINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedRsqrtINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedRsqrtINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedRsqrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedSinINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedSinINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedSinINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedSinINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSinINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedCosINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedCosINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedCosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedCosINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedCosINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedCosINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedCosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSinCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinCosINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedSinCosINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedSinCosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedSinCosINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedSinCosINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinCosINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSinCosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedSinPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedSinPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedSinPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedSinPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSinPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedCosPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedCosPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedCosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedCosPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedCosPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedCosPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedCosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSinCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinCosPiINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedSinCosPiINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedSinCosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedSinCosPiINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedSinCosPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinCosPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSinCosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedLogINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedLogINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedLogINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedLogINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedLogINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedLogINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedLogINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedLogINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedLogINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedExpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedExpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedExpINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFixedExpINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFixedExpINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFixedExpINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "inputType")
                InputType = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
            else if (o.Name == "s")
                S = o.ToLiteral<int>();
            else if (o.Name == "i")
                I = o.ToLiteral<int>();
            else if (o.Name == "rI")
                RI = o.ToLiteral<int>();
            else if (o.Name == "q")
                Q = o.ToLiteral<int>();
            else if (o.Name == "o")
                O = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFixedExpINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedExpINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedExpINTEL(OpDataIndex odi) => new(odi);
}

public struct OpPtrCastToCrossWorkgroupINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrCastToCrossWorkgroupINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrCastToCrossWorkgroupINTEL | (1 << 16);
    }

    public static implicit operator Id(OpPtrCastToCrossWorkgroupINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpPtrCastToCrossWorkgroupINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpPtrCastToCrossWorkgroupINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpPtrCastToCrossWorkgroupINTEL(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrCastToCrossWorkgroupINTEL, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrCastToCrossWorkgroupINTEL(OpDataIndex odi) => new(odi);
}

public struct OpCrossWorkgroupCastToPtrINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCrossWorkgroupCastToPtrINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCrossWorkgroupCastToPtrINTEL | (1 << 16);
    }

    public static implicit operator Id(OpCrossWorkgroupCastToPtrINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCrossWorkgroupCastToPtrINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCrossWorkgroupCastToPtrINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpCrossWorkgroupCastToPtrINTEL(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCrossWorkgroupCastToPtrINTEL, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCrossWorkgroupCastToPtrINTEL(OpDataIndex odi) => new(odi);
}

public struct OpReadPipeBlockingINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadPipeBlockingINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadPipeBlockingINTEL | (1 << 16);
    }

    public static implicit operator Id(OpReadPipeBlockingINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpReadPipeBlockingINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReadPipeBlockingINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpReadPipeBlockingINTEL(int resultType, int resultId, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadPipeBlockingINTEL, ResultType, ResultId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReadPipeBlockingINTEL(OpDataIndex odi) => new(odi);
}

public struct OpWritePipeBlockingINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePipeBlockingINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePipeBlockingINTEL | (1 << 16);
    }

    public static implicit operator Id(OpWritePipeBlockingINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpWritePipeBlockingINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpWritePipeBlockingINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "packetSize")
                PacketSize = o.ToLiteral<int>();
            else if (o.Name == "packetAlignment")
                PacketAlignment = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpWritePipeBlockingINTEL(int resultType, int resultId, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePipeBlockingINTEL, ResultType, ResultId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpWritePipeBlockingINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFPGARegINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFPGARegINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFPGARegINTEL | (1 << 16);
    }

    public static implicit operator Id(OpFPGARegINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpFPGARegINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Result
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpFPGARegINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "result")
                Result = o.ToLiteral<int>();
            else if (o.Name == "input")
                Input = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpFPGARegINTEL(int resultType, int resultId, int result, int input)
    {
        ResultType = resultType;
        ResultId = resultId;
        Result = result;
        Input = input;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFPGARegINTEL, ResultType, ResultId, Result, Input];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFPGARegINTEL(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetRayTMinKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetRayTMinKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetRayTMinKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetRayTMinKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetRayTMinKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetRayTMinKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetRayTMinKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetRayTMinKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetRayTMinKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetRayFlagsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetRayFlagsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetRayFlagsKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetRayFlagsKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetRayFlagsKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetRayFlagsKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetRayFlagsKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetRayFlagsKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetRayFlagsKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionTKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionTKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionTKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionTKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionTKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionInstanceCustomIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceCustomIndexKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionInstanceCustomIndexKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionInstanceCustomIndexKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceCustomIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionInstanceIdKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceIdKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceIdKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionInstanceIdKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionInstanceIdKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionInstanceIdKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionInstanceIdKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceIdKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceIdKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionGeometryIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionGeometryIndexKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionGeometryIndexKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionGeometryIndexKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionGeometryIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionGeometryIndexKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionPrimitiveIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionPrimitiveIndexKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionPrimitiveIndexKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionPrimitiveIndexKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionPrimitiveIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionPrimitiveIndexKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionBarycentricsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionBarycentricsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionBarycentricsKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionBarycentricsKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionBarycentricsKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionBarycentricsKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionBarycentricsKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionBarycentricsKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionBarycentricsKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionFrontFaceKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionFrontFaceKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionFrontFaceKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionFrontFaceKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionFrontFaceKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionFrontFaceKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionFrontFaceKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionFrontFaceKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionFrontFaceKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionCandidateAABBOpaqueKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionCandidateAABBOpaqueKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionCandidateAABBOpaqueKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionObjectRayDirectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectRayDirectionKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionObjectRayDirectionKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionObjectRayDirectionKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectRayDirectionKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectRayDirectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionObjectRayOriginKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectRayOriginKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionObjectRayOriginKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionObjectRayOriginKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectRayOriginKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectRayOriginKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetWorldRayDirectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetWorldRayDirectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetWorldRayDirectionKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetWorldRayDirectionKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetWorldRayDirectionKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetWorldRayDirectionKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetWorldRayDirectionKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetWorldRayDirectionKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetWorldRayDirectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetWorldRayOriginKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetWorldRayOriginKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetWorldRayOriginKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetWorldRayOriginKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetWorldRayOriginKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetWorldRayOriginKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetWorldRayOriginKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetWorldRayOriginKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetWorldRayOriginKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionObjectToWorldKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectToWorldKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionObjectToWorldKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionObjectToWorldKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectToWorldKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectToWorldKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionWorldToObjectKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionWorldToObjectKHR | (1 << 16);
    }

    public static implicit operator Id(OpRayQueryGetIntersectionWorldToObjectKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionWorldToObjectKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "rayQuery")
                RayQuery = o.ToLiteral<int>();
            else if (o.Name == "intersection")
                Intersection = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionWorldToObjectKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionWorldToObjectKHR(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFAddEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFAddEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFAddEXT | (1 << 16);
    }

    public static implicit operator Id(OpAtomicFAddEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpAtomicFAddEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicFAddEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "pointer")
                Pointer = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
            else if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpAtomicFAddEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFAddEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFAddEXT(OpDataIndex odi) => new(odi);
}

public struct OpTypeBufferSurfaceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeBufferSurfaceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeBufferSurfaceINTEL | (1 << 16);
    }

    public static implicit operator Id(OpTypeBufferSurfaceINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpTypeBufferSurfaceINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier AccessQualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeBufferSurfaceINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "accessQualifier")
                AccessQualifier = o.ToEnum<AccessQualifier>();
        }

        DataIndex = index;
    }

    public OpTypeBufferSurfaceINTEL(int resultId, AccessQualifier accessQualifier)
    {
        ResultId = resultId;
        AccessQualifier = accessQualifier;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeBufferSurfaceINTEL, ResultId, (int)AccessQualifier];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeBufferSurfaceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeStructContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeStructContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeStructContinuedINTEL | (1 << 16);
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeStructContinuedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpTypeStructContinuedINTEL(LiteralArray<int> values)
    {
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeStructContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeStructContinuedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpConstantCompositeContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantCompositeContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantCompositeContinuedINTEL | (1 << 16);
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantCompositeContinuedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpConstantCompositeContinuedINTEL(LiteralArray<int> values)
    {
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantCompositeContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConstantCompositeContinuedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSpecConstantCompositeContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantCompositeContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantCompositeContinuedINTEL | (1 << 16);
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantCompositeContinuedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpSpecConstantCompositeContinuedINTEL(LiteralArray<int> values)
    {
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantCompositeContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSpecConstantCompositeContinuedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpCompositeConstructContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstructContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstructContinuedINTEL | (1 << 16);
    }

    public static implicit operator Id(OpCompositeConstructContinuedINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpCompositeConstructContinuedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCompositeConstructContinuedINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "values")
                Values = o.ToLiteralArray<int>();
        }

        DataIndex = index;
    }

    public OpCompositeConstructContinuedINTEL(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstructContinuedINTEL, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeConstructContinuedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpConvertFToBF16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToBF16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToBF16INTEL | (1 << 16);
    }

    public static implicit operator Id(OpConvertFToBF16INTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertFToBF16INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertFToBF16INTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "floatValue")
                FloatValue = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertFToBF16INTEL(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToBF16INTEL, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertFToBF16INTEL(OpDataIndex odi) => new(odi);
}

public struct OpConvertBF16ToFINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertBF16ToFINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertBF16ToFINTEL | (1 << 16);
    }

    public static implicit operator Id(OpConvertBF16ToFINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpConvertBF16ToFINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BFloat16Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConvertBF16ToFINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "bFloat16Value")
                BFloat16Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpConvertBF16ToFINTEL(int resultType, int resultId, int bFloat16Value)
    {
        ResultType = resultType;
        ResultId = resultId;
        BFloat16Value = bFloat16Value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertBF16ToFINTEL, ResultType, ResultId, BFloat16Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertBF16ToFINTEL(OpDataIndex odi) => new(odi);
}

public struct OpControlBarrierArriveINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrierArriveINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrierArriveINTEL | (1 << 16);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrierArriveINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpControlBarrierArriveINTEL(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrierArriveINTEL, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpControlBarrierArriveINTEL(OpDataIndex odi) => new(odi);
}

public struct OpControlBarrierWaitINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrierWaitINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrierWaitINTEL | (1 << 16);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrierWaitINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "memory")
                Memory = o.ToLiteral<int>();
            else if (o.Name == "semantics")
                Semantics = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpControlBarrierWaitINTEL(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrierWaitINTEL, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpControlBarrierWaitINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArithmeticFenceEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArithmeticFenceEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArithmeticFenceEXT | (1 << 16);
    }

    public static implicit operator Id(OpArithmeticFenceEXT inst) => new Id(inst.ResultId);
    public static implicit operator int (OpArithmeticFenceEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpArithmeticFenceEXT(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "target")
                Target = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpArithmeticFenceEXT(int resultType, int resultId, int target)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArithmeticFenceEXT, ResultType, ResultId, Target];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArithmeticFenceEXT(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupBlockPrefetchINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockPrefetchINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockPrefetchINTEL | (1 << 16);
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumBytes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockPrefetchINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "ptr")
                Ptr = o.ToLiteral<int>();
            else if (o.Name == "numBytes")
                NumBytes = o.ToLiteral<int>();
            else if (o.Name == "memoryaccess")
                if (o.Words.Length > 0)
                    Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }

        DataIndex = index;
    }

    public OpSubgroupBlockPrefetchINTEL(int ptr, int numBytes, MemoryAccessMask? memoryaccess)
    {
        Ptr = ptr;
        NumBytes = numBytes;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockPrefetchINTEL, Ptr, NumBytes, ..Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupBlockPrefetchINTEL(OpDataIndex odi) => new(odi);
}

public struct OpGroupIMulKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIMulKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIMulKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupIMulKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupIMulKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupIMulKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupIMulKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIMulKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupIMulKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMulKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMulKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMulKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupFMulKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupFMulKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupFMulKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupFMulKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMulKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMulKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupBitwiseAndKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseAndKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseAndKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupBitwiseAndKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupBitwiseAndKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupBitwiseAndKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupBitwiseAndKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseAndKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupBitwiseAndKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupBitwiseOrKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseOrKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseOrKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupBitwiseOrKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupBitwiseOrKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupBitwiseOrKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupBitwiseOrKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseOrKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupBitwiseOrKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupBitwiseXorKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseXorKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseXorKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupBitwiseXorKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupBitwiseXorKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupBitwiseXorKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupBitwiseXorKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseXorKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupBitwiseXorKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupLogicalAndKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalAndKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalAndKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupLogicalAndKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupLogicalAndKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupLogicalAndKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupLogicalAndKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalAndKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupLogicalAndKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupLogicalOrKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalOrKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalOrKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupLogicalOrKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupLogicalOrKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupLogicalOrKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupLogicalOrKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalOrKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupLogicalOrKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupLogicalXorKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalXorKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalXorKHR | (1 << 16);
    }

    public static implicit operator Id(OpGroupLogicalXorKHR inst) => new Id(inst.ResultId);
    public static implicit operator int (OpGroupLogicalXorKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupLogicalXorKHR(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "execution")
                Execution = o.ToLiteral<int>();
            else if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            else if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpGroupLogicalXorKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalXorKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupLogicalXorKHR(OpDataIndex odi) => new(odi);
}

public struct OpMaskedGatherINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMaskedGatherINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMaskedGatherINTEL | (1 << 16);
    }

    public static implicit operator Id(OpMaskedGatherINTEL inst) => new Id(inst.ResultId);
    public static implicit operator int (OpMaskedGatherINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PtrVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Alignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FillEmpty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMaskedGatherINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            else if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            else if (o.Name == "ptrVector")
                PtrVector = o.ToLiteral<int>();
            else if (o.Name == "alignment")
                Alignment = o.ToLiteral<int>();
            else if (o.Name == "mask")
                Mask = o.ToLiteral<int>();
            else if (o.Name == "fillEmpty")
                FillEmpty = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpMaskedGatherINTEL(int resultType, int resultId, int ptrVector, int alignment, int mask, int fillEmpty)
    {
        ResultType = resultType;
        ResultId = resultId;
        PtrVector = ptrVector;
        Alignment = alignment;
        Mask = mask;
        FillEmpty = fillEmpty;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMaskedGatherINTEL, ResultType, ResultId, PtrVector, ..Alignment.AsDisposableLiteralValue().Words, Mask, FillEmpty];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMaskedGatherINTEL(OpDataIndex odi) => new(odi);
}

public struct OpMaskedScatterINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMaskedScatterINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMaskedScatterINTEL | (1 << 16);
    }

    public int InputVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PtrVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Alignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMaskedScatterINTEL(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "inputVector")
                InputVector = o.ToLiteral<int>();
            else if (o.Name == "ptrVector")
                PtrVector = o.ToLiteral<int>();
            else if (o.Name == "alignment")
                Alignment = o.ToLiteral<int>();
            else if (o.Name == "mask")
                Mask = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public OpMaskedScatterINTEL(int inputVector, int ptrVector, int alignment, int mask)
    {
        InputVector = inputVector;
        PtrVector = ptrVector;
        Alignment = alignment;
        Mask = mask;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMaskedScatterINTEL, InputVector, PtrVector, ..Alignment.AsDisposableLiteralValue().Words, Mask];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMaskedScatterINTEL(OpDataIndex odi) => new(odi);
}

public struct GLSLRound : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLRound inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLRound inst) => inst.ResultId;
    public int Instruction => 1;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLRound(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLRound(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLRound(OpDataIndex odi) => new(odi);
}

public struct GLSLRoundEven : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLRoundEven inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLRoundEven inst) => inst.ResultId;
    public int Instruction => 2;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLRoundEven(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLRoundEven(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLRoundEven(OpDataIndex odi) => new(odi);
}

public struct GLSLTrunc : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLTrunc inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLTrunc inst) => inst.ResultId;
    public int Instruction => 3;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLTrunc(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLTrunc(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLTrunc(OpDataIndex odi) => new(odi);
}

public struct GLSLFAbs : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFAbs inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFAbs inst) => inst.ResultId;
    public int Instruction => 4;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFAbs(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFAbs(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFAbs(OpDataIndex odi) => new(odi);
}

public struct GLSLSAbs : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSAbs inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSAbs inst) => inst.ResultId;
    public int Instruction => 5;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSAbs(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSAbs(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSAbs(OpDataIndex odi) => new(odi);
}

public struct GLSLFSign : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFSign inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFSign inst) => inst.ResultId;
    public int Instruction => 6;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFSign(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFSign(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFSign(OpDataIndex odi) => new(odi);
}

public struct GLSLSSign : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSSign inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSSign inst) => inst.ResultId;
    public int Instruction => 7;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSSign(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSSign(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSSign(OpDataIndex odi) => new(odi);
}

public struct GLSLFloor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFloor inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFloor inst) => inst.ResultId;
    public int Instruction => 8;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFloor(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFloor(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFloor(OpDataIndex odi) => new(odi);
}

public struct GLSLCeil : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLCeil inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLCeil inst) => inst.ResultId;
    public int Instruction => 9;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLCeil(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLCeil(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLCeil(OpDataIndex odi) => new(odi);
}

public struct GLSLFract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFract inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFract inst) => inst.ResultId;
    public int Instruction => 10;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFract(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFract(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFract(OpDataIndex odi) => new(odi);
}

public struct GLSLRadians : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLRadians inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLRadians inst) => inst.ResultId;
    public int Instruction => 11;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Degrees
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLRadians(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "degrees")
                Degrees = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLRadians(int resultType, int resultId, int set, int degrees)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Degrees = degrees;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Degrees];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLRadians(OpDataIndex odi) => new(odi);
}

public struct GLSLDegrees : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLDegrees inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLDegrees inst) => inst.ResultId;
    public int Instruction => 12;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Radians
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLDegrees(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "radians")
                Radians = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLDegrees(int resultType, int resultId, int set, int radians)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Radians = radians;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Radians];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLDegrees(OpDataIndex odi) => new(odi);
}

public struct GLSLSin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSin inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSin inst) => inst.ResultId;
    public int Instruction => 13;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSin(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSin(OpDataIndex odi) => new(odi);
}

public struct GLSLCos : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLCos inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLCos inst) => inst.ResultId;
    public int Instruction => 14;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLCos(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLCos(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLCos(OpDataIndex odi) => new(odi);
}

public struct GLSLTan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLTan inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLTan inst) => inst.ResultId;
    public int Instruction => 15;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLTan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLTan(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLTan(OpDataIndex odi) => new(odi);
}

public struct GLSLAsin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLAsin inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLAsin inst) => inst.ResultId;
    public int Instruction => 16;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLAsin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLAsin(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAsin(OpDataIndex odi) => new(odi);
}

public struct GLSLAcos : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLAcos inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLAcos inst) => inst.ResultId;
    public int Instruction => 17;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLAcos(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLAcos(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAcos(OpDataIndex odi) => new(odi);
}

public struct GLSLAtan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLAtan inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLAtan inst) => inst.ResultId;
    public int Instruction => 18;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y_over_x
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLAtan(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "y_over_x")
                Y_over_x = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLAtan(int resultType, int resultId, int set, int y_over_x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Y_over_x = y_over_x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Y_over_x];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAtan(OpDataIndex odi) => new(odi);
}

public struct GLSLSinh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSinh inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSinh inst) => inst.ResultId;
    public int Instruction => 19;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSinh(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSinh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSinh(OpDataIndex odi) => new(odi);
}

public struct GLSLCosh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLCosh inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLCosh inst) => inst.ResultId;
    public int Instruction => 20;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLCosh(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLCosh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLCosh(OpDataIndex odi) => new(odi);
}

public struct GLSLTanh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLTanh inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLTanh inst) => inst.ResultId;
    public int Instruction => 21;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLTanh(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLTanh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLTanh(OpDataIndex odi) => new(odi);
}

public struct GLSLAsinh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLAsinh inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLAsinh inst) => inst.ResultId;
    public int Instruction => 22;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLAsinh(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLAsinh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAsinh(OpDataIndex odi) => new(odi);
}

public struct GLSLAcosh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLAcosh inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLAcosh inst) => inst.ResultId;
    public int Instruction => 23;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLAcosh(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLAcosh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAcosh(OpDataIndex odi) => new(odi);
}

public struct GLSLAtanh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLAtanh inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLAtanh inst) => inst.ResultId;
    public int Instruction => 24;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLAtanh(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLAtanh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAtanh(OpDataIndex odi) => new(odi);
}

public struct GLSLAtan2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLAtan2 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLAtan2 inst) => inst.ResultId;
    public int Instruction => 25;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLAtan2(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLAtan2(int resultType, int resultId, int set, int y, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Y = y;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Y, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAtan2(OpDataIndex odi) => new(odi);
}

public struct GLSLPow : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLPow inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLPow inst) => inst.ResultId;
    public int Instruction => 26;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLPow(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLPow(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPow(OpDataIndex odi) => new(odi);
}

public struct GLSLExp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLExp inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLExp inst) => inst.ResultId;
    public int Instruction => 27;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLExp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLExp(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLExp(OpDataIndex odi) => new(odi);
}

public struct GLSLLog : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLLog inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLLog inst) => inst.ResultId;
    public int Instruction => 28;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLLog(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLLog(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLLog(OpDataIndex odi) => new(odi);
}

public struct GLSLExp2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLExp2 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLExp2 inst) => inst.ResultId;
    public int Instruction => 29;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLExp2(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLExp2(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLExp2(OpDataIndex odi) => new(odi);
}

public struct GLSLLog2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLLog2 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLLog2 inst) => inst.ResultId;
    public int Instruction => 30;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLLog2(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLLog2(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLLog2(OpDataIndex odi) => new(odi);
}

public struct GLSLSqrt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSqrt inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSqrt inst) => inst.ResultId;
    public int Instruction => 31;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSqrt(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSqrt(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSqrt(OpDataIndex odi) => new(odi);
}

public struct GLSLInverseSqrt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLInverseSqrt inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLInverseSqrt inst) => inst.ResultId;
    public int Instruction => 32;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLInverseSqrt(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLInverseSqrt(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLInverseSqrt(OpDataIndex odi) => new(odi);
}

public struct GLSLDeterminant : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLDeterminant inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLDeterminant inst) => inst.ResultId;
    public int Instruction => 33;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLDeterminant(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLDeterminant(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLDeterminant(OpDataIndex odi) => new(odi);
}

public struct GLSLMatrixInverse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLMatrixInverse inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLMatrixInverse inst) => inst.ResultId;
    public int Instruction => 34;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLMatrixInverse(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLMatrixInverse(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLMatrixInverse(OpDataIndex odi) => new(odi);
}

public struct GLSLModf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLModf inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLModf inst) => inst.ResultId;
    public int Instruction => 35;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLModf(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "i")
                I = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLModf(int resultType, int resultId, int set, int x, int i)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        I = i;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, I];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLModf(OpDataIndex odi) => new(odi);
}

public struct GLSLModfStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLModfStruct inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLModfStruct inst) => inst.ResultId;
    public int Instruction => 36;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLModfStruct(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLModfStruct(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLModfStruct(OpDataIndex odi) => new(odi);
}

public struct GLSLFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFMin inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFMin inst) => inst.ResultId;
    public int Instruction => 37;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFMin(OpDataIndex odi) => new(odi);
}

public struct GLSLUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUMin inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUMin inst) => inst.ResultId;
    public int Instruction => 38;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUMin(OpDataIndex odi) => new(odi);
}

public struct GLSLSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSMin inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSMin inst) => inst.ResultId;
    public int Instruction => 39;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSMin(OpDataIndex odi) => new(odi);
}

public struct GLSLFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFMax inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFMax inst) => inst.ResultId;
    public int Instruction => 40;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFMax(OpDataIndex odi) => new(odi);
}

public struct GLSLUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUMax inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUMax inst) => inst.ResultId;
    public int Instruction => 41;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUMax(OpDataIndex odi) => new(odi);
}

public struct GLSLSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSMax inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSMax inst) => inst.ResultId;
    public int Instruction => 42;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSMax(OpDataIndex odi) => new(odi);
}

public struct GLSLFClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFClamp inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFClamp inst) => inst.ResultId;
    public int Instruction => 43;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFClamp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "minVal")
                MinVal = o.ToLiteral<int>();
            if (o.Name == "maxVal")
                MaxVal = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFClamp(OpDataIndex odi) => new(odi);
}

public struct GLSLUClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUClamp inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUClamp inst) => inst.ResultId;
    public int Instruction => 44;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUClamp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "minVal")
                MinVal = o.ToLiteral<int>();
            if (o.Name == "maxVal")
                MaxVal = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUClamp(OpDataIndex odi) => new(odi);
}

public struct GLSLSClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSClamp inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSClamp inst) => inst.ResultId;
    public int Instruction => 45;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSClamp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "minVal")
                MinVal = o.ToLiteral<int>();
            if (o.Name == "maxVal")
                MaxVal = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSClamp(OpDataIndex odi) => new(odi);
}

public struct GLSLFMix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFMix inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFMix inst) => inst.ResultId;
    public int Instruction => 46;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFMix(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
            if (o.Name == "a")
                A = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFMix(int resultType, int resultId, int set, int x, int y, int a)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        A = a;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y, A];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFMix(OpDataIndex odi) => new(odi);
}

public struct GLSLIMix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLIMix inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLIMix inst) => inst.ResultId;
    public int Instruction => 47;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLIMix(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
            if (o.Name == "a")
                A = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLIMix(int resultType, int resultId, int set, int x, int y, int a)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        A = a;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y, A];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLIMix(OpDataIndex odi) => new(odi);
}

public struct GLSLStep : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLStep inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLStep inst) => inst.ResultId;
    public int Instruction => 48;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLStep(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "edge")
                Edge = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLStep(int resultType, int resultId, int set, int edge, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Edge = edge;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Edge, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLStep(OpDataIndex odi) => new(odi);
}

public struct GLSLSmoothStep : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLSmoothStep inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLSmoothStep inst) => inst.ResultId;
    public int Instruction => 49;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge0
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLSmoothStep(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "edge0")
                Edge0 = o.ToLiteral<int>();
            if (o.Name == "edge1")
                Edge1 = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLSmoothStep(int resultType, int resultId, int set, int edge0, int edge1, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Edge0 = edge0;
        Edge1 = edge1;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Edge0, Edge1, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSmoothStep(OpDataIndex odi) => new(odi);
}

public struct GLSLFma : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFma inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFma inst) => inst.ResultId;
    public int Instruction => 50;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFma(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "a")
                A = o.ToLiteral<int>();
            if (o.Name == "b")
                B = o.ToLiteral<int>();
            if (o.Name == "c")
                C = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFma(int resultType, int resultId, int set, int a, int b, int c)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        A = a;
        B = b;
        C = c;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, A, B, C];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFma(OpDataIndex odi) => new(odi);
}

public struct GLSLFrexp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFrexp inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFrexp inst) => inst.ResultId;
    public int Instruction => 51;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Exp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFrexp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "exp")
                Exp = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFrexp(int resultType, int resultId, int set, int x, int exp)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Exp = exp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Exp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFrexp(OpDataIndex odi) => new(odi);
}

public struct GLSLFrexpStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFrexpStruct inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFrexpStruct inst) => inst.ResultId;
    public int Instruction => 52;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFrexpStruct(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFrexpStruct(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFrexpStruct(OpDataIndex odi) => new(odi);
}

public struct GLSLLdexp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLLdexp inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLLdexp inst) => inst.ResultId;
    public int Instruction => 53;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Exp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLLdexp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "exp")
                Exp = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLLdexp(int resultType, int resultId, int set, int x, int exp)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Exp = exp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Exp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLLdexp(OpDataIndex odi) => new(odi);
}

public struct GLSLPackSnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLPackSnorm4x8 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLPackSnorm4x8 inst) => inst.ResultId;
    public int Instruction => 54;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLPackSnorm4x8(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "v")
                V = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLPackSnorm4x8(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackSnorm4x8(OpDataIndex odi) => new(odi);
}

public struct GLSLPackUnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLPackUnorm4x8 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLPackUnorm4x8 inst) => inst.ResultId;
    public int Instruction => 55;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLPackUnorm4x8(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "v")
                V = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLPackUnorm4x8(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackUnorm4x8(OpDataIndex odi) => new(odi);
}

public struct GLSLPackSnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLPackSnorm2x16 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLPackSnorm2x16 inst) => inst.ResultId;
    public int Instruction => 56;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLPackSnorm2x16(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "v")
                V = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLPackSnorm2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackSnorm2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLPackUnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLPackUnorm2x16 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLPackUnorm2x16 inst) => inst.ResultId;
    public int Instruction => 57;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLPackUnorm2x16(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "v")
                V = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLPackUnorm2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackUnorm2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLPackHalf2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLPackHalf2x16 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLPackHalf2x16 inst) => inst.ResultId;
    public int Instruction => 58;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLPackHalf2x16(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "v")
                V = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLPackHalf2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackHalf2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLPackDouble2x32 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLPackDouble2x32 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLPackDouble2x32 inst) => inst.ResultId;
    public int Instruction => 59;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLPackDouble2x32(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "v")
                V = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLPackDouble2x32(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackDouble2x32(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackSnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUnpackSnorm2x16 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUnpackSnorm2x16 inst) => inst.ResultId;
    public int Instruction => 60;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUnpackSnorm2x16(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUnpackSnorm2x16(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackSnorm2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackUnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUnpackUnorm2x16 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUnpackUnorm2x16 inst) => inst.ResultId;
    public int Instruction => 61;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUnpackUnorm2x16(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUnpackUnorm2x16(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackUnorm2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackHalf2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUnpackHalf2x16 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUnpackHalf2x16 inst) => inst.ResultId;
    public int Instruction => 62;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUnpackHalf2x16(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "v")
                V = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUnpackHalf2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackHalf2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackSnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUnpackSnorm4x8 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUnpackSnorm4x8 inst) => inst.ResultId;
    public int Instruction => 63;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUnpackSnorm4x8(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUnpackSnorm4x8(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackSnorm4x8(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackUnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUnpackUnorm4x8 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUnpackUnorm4x8 inst) => inst.ResultId;
    public int Instruction => 64;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUnpackUnorm4x8(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "p")
                P = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUnpackUnorm4x8(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackUnorm4x8(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackDouble2x32 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLUnpackDouble2x32 inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLUnpackDouble2x32 inst) => inst.ResultId;
    public int Instruction => 65;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLUnpackDouble2x32(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "v")
                V = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLUnpackDouble2x32(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackDouble2x32(OpDataIndex odi) => new(odi);
}

public struct GLSLLength : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLLength inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLLength inst) => inst.ResultId;
    public int Instruction => 66;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLLength(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLLength(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLLength(OpDataIndex odi) => new(odi);
}

public struct GLSLDistance : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLDistance inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLDistance inst) => inst.ResultId;
    public int Instruction => 67;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P0
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLDistance(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "p0")
                P0 = o.ToLiteral<int>();
            if (o.Name == "p1")
                P1 = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLDistance(int resultType, int resultId, int set, int p0, int p1)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P0 = p0;
        P1 = p1;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, P0, P1];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLDistance(OpDataIndex odi) => new(odi);
}

public struct GLSLCross : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLCross inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLCross inst) => inst.ResultId;
    public int Instruction => 68;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLCross(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLCross(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLCross(OpDataIndex odi) => new(odi);
}

public struct GLSLNormalize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLNormalize inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLNormalize inst) => inst.ResultId;
    public int Instruction => 69;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLNormalize(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLNormalize(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLNormalize(OpDataIndex odi) => new(odi);
}

public struct GLSLFaceForward : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFaceForward inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFaceForward inst) => inst.ResultId;
    public int Instruction => 70;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Nref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFaceForward(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "n")
                N = o.ToLiteral<int>();
            if (o.Name == "i")
                I = o.ToLiteral<int>();
            if (o.Name == "nref")
                Nref = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFaceForward(int resultType, int resultId, int set, int n, int i, int nref)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        N = n;
        I = i;
        Nref = nref;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, N, I, Nref];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFaceForward(OpDataIndex odi) => new(odi);
}

public struct GLSLReflect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLReflect inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLReflect inst) => inst.ResultId;
    public int Instruction => 71;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLReflect(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "i")
                I = o.ToLiteral<int>();
            if (o.Name == "n")
                N = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLReflect(int resultType, int resultId, int set, int i, int n)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        I = i;
        N = n;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, I, N];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLReflect(OpDataIndex odi) => new(odi);
}

public struct GLSLRefract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLRefract inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLRefract inst) => inst.ResultId;
    public int Instruction => 72;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Eta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLRefract(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "i")
                I = o.ToLiteral<int>();
            if (o.Name == "n")
                N = o.ToLiteral<int>();
            if (o.Name == "eta")
                Eta = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLRefract(int resultType, int resultId, int set, int i, int n, int eta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        I = i;
        N = n;
        Eta = eta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, I, N, Eta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLRefract(OpDataIndex odi) => new(odi);
}

public struct GLSLFindILsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFindILsb inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFindILsb inst) => inst.ResultId;
    public int Instruction => 73;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFindILsb(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFindILsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFindILsb(OpDataIndex odi) => new(odi);
}

public struct GLSLFindSMsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFindSMsb inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFindSMsb inst) => inst.ResultId;
    public int Instruction => 74;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFindSMsb(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFindSMsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFindSMsb(OpDataIndex odi) => new(odi);
}

public struct GLSLFindUMsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLFindUMsb inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLFindUMsb inst) => inst.ResultId;
    public int Instruction => 75;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLFindUMsb(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "value")
                Value = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLFindUMsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFindUMsb(OpDataIndex odi) => new(odi);
}

public struct GLSLInterpolateAtCentroid : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLInterpolateAtCentroid inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLInterpolateAtCentroid inst) => inst.ResultId;
    public int Instruction => 76;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLInterpolateAtCentroid(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "interpolant")
                Interpolant = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLInterpolateAtCentroid(int resultType, int resultId, int set, int interpolant)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Interpolant];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLInterpolateAtCentroid(OpDataIndex odi) => new(odi);
}

public struct GLSLInterpolateAtSample : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLInterpolateAtSample inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLInterpolateAtSample inst) => inst.ResultId;
    public int Instruction => 77;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLInterpolateAtSample(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "interpolant")
                Interpolant = o.ToLiteral<int>();
            if (o.Name == "sample")
                Sample = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLInterpolateAtSample(int resultType, int resultId, int set, int interpolant, int sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Interpolant, Sample];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLInterpolateAtSample(OpDataIndex odi) => new(odi);
}

public struct GLSLInterpolateAtOffset : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLInterpolateAtOffset inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLInterpolateAtOffset inst) => inst.ResultId;
    public int Instruction => 78;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLInterpolateAtOffset(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "interpolant")
                Interpolant = o.ToLiteral<int>();
            if (o.Name == "offset")
                Offset = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLInterpolateAtOffset(int resultType, int resultId, int set, int interpolant, int offset)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        Offset = offset;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, Interpolant, Offset];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLInterpolateAtOffset(OpDataIndex odi) => new(odi);
}

public struct GLSLNMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLNMin inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLNMin inst) => inst.ResultId;
    public int Instruction => 79;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLNMin(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLNMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLNMin(OpDataIndex odi) => new(odi);
}

public struct GLSLNMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLNMax inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLNMax inst) => inst.ResultId;
    public int Instruction => 80;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLNMax(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "y")
                Y = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLNMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLNMax(OpDataIndex odi) => new(odi);
}

public struct GLSLNClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator Id(GLSLNClamp inst) => new Id(inst.ResultId);
    public static implicit operator int (GLSLNClamp inst) => inst.ResultId;
    public int Instruction => 81;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GLSLNClamp(OpDataIndex index)
    {
        foreach (var o in index.Data)
        {
            if (o.Name == "resultType")
                ResultType = o.ToLiteral<int>();
            if (o.Name == "resultId")
                ResultId = o.ToLiteral<int>();
            if (o.Name == "set")
                Set = o.ToLiteral<int>();
            if (o.Name == "x")
                X = o.ToLiteral<int>();
            if (o.Name == "minVal")
                MinVal = o.ToLiteral<int>();
            if (o.Name == "maxVal")
                MaxVal = o.ToLiteral<int>();
        }

        DataIndex = index;
    }

    public GLSLNClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        if (InstructionMemory is null)
            InstructionMemory = MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLNClamp(OpDataIndex odi) => new(odi);
}