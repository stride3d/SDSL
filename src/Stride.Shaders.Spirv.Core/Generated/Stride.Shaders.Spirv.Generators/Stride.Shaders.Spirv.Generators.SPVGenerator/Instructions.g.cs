using static Stride.Shaders.Spirv.Specification;
using CommunityToolkit.HighPerformance;
using CommunityToolkit.HighPerformance.Buffers;
using Stride.Shaders.Spirv.Core.Buffers;

namespace Stride.Shaders.Spirv.Core;
public struct OpSDSLShader : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public LiteralString ShaderName
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDSLShader(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "shaderName")
                ShaderName = o.To<LiteralString>();
        }
    }

    public OpSDSLShader(LiteralString shaderName)
    {
        ShaderName = shaderName;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDSLShader, ..ShaderName.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLShader(OpDataIndex odi) => new(odi);
}

public struct OpSDSLShaderEnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLShaderEnd(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpSDSLShaderEnd(OpDataIndex odi) => new(odi);
}

public struct OpSDSLMixinInherit : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDSLMixinInherit(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "shader")
                Shader = o.To<IdRef>();
        }
    }

    public OpSDSLMixinInherit(int shader)
    {
        Shader = shader;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDSLMixinInherit, ..Shader.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLMixinInherit(OpDataIndex odi) => new(odi);
}

public struct OpSDSLCompose : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public LiteralString Mixin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Name
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDSLCompose(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "mixin")
                Mixin = o.To<LiteralString>();
            if (o.Name == "name")
                Name = o.To<LiteralString>();
        }
    }

    public OpSDSLCompose(LiteralString mixin, LiteralString name)
    {
        Mixin = mixin;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDSLCompose, ..Mixin.AsSpirvSpan(), ..Name.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLCompose(OpDataIndex odi) => new(odi);
}

public struct OpSDSLStage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int StagedElement
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDSLStage(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "stagedElement")
                StagedElement = o.To<IdRef>();
        }
    }

    public OpSDSLStage(int stagedElement)
    {
        StagedElement = stagedElement;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDSLStage, ..StagedElement.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLStage(OpDataIndex odi) => new(odi);
}

public struct OpSDSLImportShader : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSDSLImportShader inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSDSLImportShader inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString ShaderName
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDSLImportShader(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "shaderName")
                ShaderName = o.To<LiteralString>();
        }
    }

    public OpSDSLImportShader(int resultId, LiteralString shaderName)
    {
        ResultId = resultId;
        ShaderName = shaderName;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDSLImportShader, ..ResultId.AsSpirvSpan(), ..ShaderName.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLImportShader(OpDataIndex odi) => new(odi);
}

public struct OpSDSLImportFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSDSLImportFunction inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSDSLImportFunction inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString FunctionName
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDSLImportFunction(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "functionName")
                FunctionName = o.To<LiteralString>();
            if (o.Name == "shader")
                Shader = o.To<IdRef>();
        }
    }

    public OpSDSLImportFunction(int resultType, int resultId, LiteralString functionName, int shader)
    {
        ResultType = resultType;
        ResultId = resultId;
        FunctionName = functionName;
        Shader = shader;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDSLImportFunction, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..FunctionName.AsSpirvSpan(), ..Shader.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLImportFunction(OpDataIndex odi) => new(odi);
}

public struct OpSDSLImportVariable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSDSLImportVariable inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSDSLImportVariable inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString VariableName
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDSLImportVariable(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "variableName")
                VariableName = o.To<LiteralString>();
            if (o.Name == "shader")
                Shader = o.To<IdRef>();
        }
    }

    public OpSDSLImportVariable(int resultType, int resultId, LiteralString variableName, int shader)
    {
        ResultType = resultType;
        ResultId = resultId;
        VariableName = variableName;
        Shader = shader;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDSLImportVariable, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..VariableName.AsSpirvSpan(), ..Shader.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDSLImportVariable(OpDataIndex odi) => new(odi);
}

public struct OpNop : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNop(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpNop(OpDataIndex odi) => new(odi);
}

public struct OpUndef : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUndef inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUndef inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUndef(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpUndef(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUndef, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUndef(OpDataIndex odi) => new(odi);
}

public struct OpSourceContinued : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public LiteralString ContinuedSource
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSourceContinued(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "continuedSource")
                ContinuedSource = o.To<LiteralString>();
        }
    }

    public OpSourceContinued(LiteralString continuedSource)
    {
        ContinuedSource = continuedSource;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSourceContinued, ..ContinuedSource.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSourceContinued(OpDataIndex odi) => new(odi);
}

public struct OpSource : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public SourceLanguage Sourcelanguage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Version
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? File
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString? Source
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSource(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "sourcelanguage")
                Sourcelanguage = o.ToEnum<SourceLanguage>();
            if (o.Name == "version")
                Version = o.To<LiteralInteger>();
            if (o.Name == "file")
                File = o.To<IdRef>();
            if (o.Name == "source")
                Source = o.To<LiteralString>();
        }
    }

    public OpSource(SourceLanguage sourcelanguage, int version, int? file, LiteralString? source)
    {
        Sourcelanguage = sourcelanguage;
        Version = version;
        File = file;
        Source = source;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSource, ..Sourcelanguage.AsSpirvSpan(), ..Version.AsSpirvSpan(), ..File.AsSpirvSpan(), ..Source.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSource(OpDataIndex odi) => new(odi);
}

public struct OpSourceExtension : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public LiteralString Extension
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSourceExtension(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "extension")
                Extension = o.To<LiteralString>();
        }
    }

    public OpSourceExtension(LiteralString extension)
    {
        Extension = extension;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSourceExtension, ..Extension.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSourceExtension(OpDataIndex odi) => new(odi);
}

public struct OpName : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Name
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpName(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "target")
                Target = o.To<IdRef>();
            if (o.Name == "name")
                Name = o.To<LiteralString>();
        }
    }

    public OpName(int target, LiteralString name)
    {
        Target = target;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpName, ..Target.AsSpirvSpan(), ..Name.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpName(OpDataIndex odi) => new(odi);
}

public struct OpMemberName : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Name
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMemberName(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "type")
                Type = o.To<IdRef>();
            if (o.Name == "member")
                Member = o.To<LiteralInteger>();
            if (o.Name == "name")
                Name = o.To<LiteralString>();
        }
    }

    public OpMemberName(int type, int member, LiteralString name)
    {
        Type = type;
        Member = member;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMemberName, ..Type.AsSpirvSpan(), ..Member.AsSpirvSpan(), ..Name.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemberName(OpDataIndex odi) => new(odi);
}

public struct OpString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpString inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpString inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpString(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "value")
                Value = o.To<LiteralString>();
        }
    }

    public OpString(int resultId, LiteralString value)
    {
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpString, ..ResultId.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpString(OpDataIndex odi) => new(odi);
}

public struct OpLine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int File
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Line
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Column
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLine(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "file")
                File = o.To<IdRef>();
            if (o.Name == "line")
                Line = o.To<LiteralInteger>();
            if (o.Name == "column")
                Column = o.To<LiteralInteger>();
        }
    }

    public OpLine(int file, int line, int column)
    {
        File = file;
        Line = line;
        Column = column;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLine, ..File.AsSpirvSpan(), ..Line.AsSpirvSpan(), ..Column.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLine(OpDataIndex odi) => new(odi);
}

public struct OpExtension : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public LiteralString Name
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpExtension(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "name")
                Name = o.To<LiteralString>();
        }
    }

    public OpExtension(LiteralString name)
    {
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtension, ..Name.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExtension(OpDataIndex odi) => new(odi);
}

public struct OpExtInstImport : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpExtInstImport inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpExtInstImport inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Name
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpExtInstImport(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "name")
                Name = o.To<LiteralString>();
        }
    }

    public OpExtInstImport(int resultId, LiteralString name)
    {
        ResultId = resultId;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInstImport, ..ResultId.AsSpirvSpan(), ..Name.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExtInstImport(OpDataIndex odi) => new(odi);
}

public struct OpExtInst : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpExtInst inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpExtInst inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Instruction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpExtInst(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "instruction")
                Instruction = o.To<LiteralExtInstInteger>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpExtInst(int resultType, int resultId, int set, int instruction, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Instruction = instruction;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExtInst(OpDataIndex odi) => new(odi);
}

public struct OpMemoryModel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public AddressingModel Addressingmodel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryModel Memorymodel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMemoryModel(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "addressingmodel")
                Addressingmodel = o.ToEnum<AddressingModel>();
            if (o.Name == "memorymodel")
                Memorymodel = o.ToEnum<MemoryModel>();
        }
    }

    public OpMemoryModel(AddressingModel addressingmodel, MemoryModel memorymodel)
    {
        Addressingmodel = addressingmodel;
        Memorymodel = memorymodel;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMemoryModel, ..Addressingmodel.AsSpirvSpan(), ..Memorymodel.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemoryModel(OpDataIndex odi) => new(odi);
}

public struct OpEntryPoint : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public ExecutionModel Executionmodel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Name
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpEntryPoint(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "executionmodel")
                Executionmodel = o.ToEnum<ExecutionModel>();
            if (o.Name == "entryPoint")
                EntryPoint = o.To<IdRef>();
            if (o.Name == "name")
                Name = o.To<LiteralString>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpEntryPoint(ExecutionModel executionmodel, int entryPoint, LiteralString name, LiteralArray<IdRef> values)
    {
        Executionmodel = executionmodel;
        EntryPoint = entryPoint;
        Name = name;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpEntryPoint, ..Executionmodel.AsSpirvSpan(), ..EntryPoint.AsSpirvSpan(), ..Name.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEntryPoint(OpDataIndex odi) => new(odi);
}

public struct OpExecutionMode : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ExecutionMode Mode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpExecutionMode(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "entryPoint")
                EntryPoint = o.To<IdRef>();
            if (o.Name == "mode")
                Mode = o.ToEnum<ExecutionMode>();
        }
    }

    public OpExecutionMode(int entryPoint, ExecutionMode mode)
    {
        EntryPoint = entryPoint;
        Mode = mode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExecutionMode, ..EntryPoint.AsSpirvSpan(), ..Mode.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExecutionMode(OpDataIndex odi) => new(odi);
}

public struct OpCapability : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public Capability Capability
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCapability(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "capability")
                Capability = o.ToEnum<Capability>();
        }
    }

    public OpCapability(Capability capability)
    {
        Capability = capability;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCapability, ..Capability.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCapability(OpDataIndex odi) => new(odi);
}

public struct OpTypeVoid : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeVoid inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeVoid inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeVoid(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeVoid(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeVoid, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeVoid(OpDataIndex odi) => new(odi);
}

public struct OpTypeBool : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeBool inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeBool inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeBool(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeBool(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeBool, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeBool(OpDataIndex odi) => new(odi);
}

public struct OpTypeInt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeInt inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeInt inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Signedness
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeInt(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "width")
                Width = o.To<LiteralInteger>();
            if (o.Name == "signedness")
                Signedness = o.To<LiteralInteger>();
        }
    }

    public OpTypeInt(int resultId, int width, int signedness)
    {
        ResultId = resultId;
        Width = width;
        Signedness = signedness;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeInt, ..ResultId.AsSpirvSpan(), ..Width.AsSpirvSpan(), ..Signedness.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeInt(OpDataIndex odi) => new(odi);
}

public struct OpTypeFloat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeFloat inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeFloat inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public FPEncoding? FloatingPointEncoding
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeFloat(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "width")
                Width = o.To<LiteralInteger>();
            if (o.Name == "floatingPointEncoding")
                FloatingPointEncoding = o.ToEnum<FPEncoding>();
        }
    }

    public OpTypeFloat(int resultId, int width, FPEncoding? floatingPointEncoding)
    {
        ResultId = resultId;
        Width = width;
        FloatingPointEncoding = floatingPointEncoding;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeFloat, ..ResultId.AsSpirvSpan(), ..Width.AsSpirvSpan(), ..FloatingPointEncoding.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeFloat(OpDataIndex odi) => new(odi);
}

public struct OpTypeVector : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeVector inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeVector inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ComponentCount
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeVector(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "componentType")
                ComponentType = o.To<IdRef>();
            if (o.Name == "componentCount")
                ComponentCount = o.To<LiteralInteger>();
        }
    }

    public OpTypeVector(int resultId, int componentType, int componentCount)
    {
        ResultId = resultId;
        ComponentType = componentType;
        ComponentCount = componentCount;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeVector, ..ResultId.AsSpirvSpan(), ..ComponentType.AsSpirvSpan(), ..ComponentCount.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeVector(OpDataIndex odi) => new(odi);
}

public struct OpTypeMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeMatrix inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeMatrix inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ColumnType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ColumnCount
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeMatrix(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "columnType")
                ColumnType = o.To<IdRef>();
            if (o.Name == "columnCount")
                ColumnCount = o.To<LiteralInteger>();
        }
    }

    public OpTypeMatrix(int resultId, int columnType, int columnCount)
    {
        ResultId = resultId;
        ColumnType = columnType;
        ColumnCount = columnCount;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeMatrix, ..ResultId.AsSpirvSpan(), ..ColumnType.AsSpirvSpan(), ..ColumnCount.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeMatrix(OpDataIndex odi) => new(odi);
}

public struct OpTypeImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeImage inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeImage inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public Dim Dim
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Depth
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Arrayed
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MS
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Sampled
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageFormat Imageformat
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public AccessQualifier? Accessqualifier
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeImage(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledType")
                SampledType = o.To<IdRef>();
            if (o.Name == "dim")
                Dim = o.ToEnum<Dim>();
            if (o.Name == "depth")
                Depth = o.To<LiteralInteger>();
            if (o.Name == "arrayed")
                Arrayed = o.To<LiteralInteger>();
            if (o.Name == "mS")
                MS = o.To<LiteralInteger>();
            if (o.Name == "sampled")
                Sampled = o.To<LiteralInteger>();
            if (o.Name == "imageformat")
                Imageformat = o.ToEnum<ImageFormat>();
            if (o.Name == "accessqualifier")
                Accessqualifier = o.ToEnum<AccessQualifier>();
        }
    }

    public OpTypeImage(int resultId, int sampledType, Dim dim, int depth, int arrayed, int mS, int sampled, ImageFormat imageformat, AccessQualifier? accessqualifier)
    {
        ResultId = resultId;
        SampledType = sampledType;
        Dim = dim;
        Depth = depth;
        Arrayed = arrayed;
        MS = mS;
        Sampled = sampled;
        Imageformat = imageformat;
        Accessqualifier = accessqualifier;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeImage, ..ResultId.AsSpirvSpan(), ..SampledType.AsSpirvSpan(), ..Dim.AsSpirvSpan(), ..Depth.AsSpirvSpan(), ..Arrayed.AsSpirvSpan(), ..MS.AsSpirvSpan(), ..Sampled.AsSpirvSpan(), ..Imageformat.AsSpirvSpan(), ..Accessqualifier.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeImage(OpDataIndex odi) => new(odi);
}

public struct OpTypeSampler : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeSampler inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeSampler inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeSampler(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeSampler(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeSampler, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeSampler(OpDataIndex odi) => new(odi);
}

public struct OpTypeSampledImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeSampledImage inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeSampledImage inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeSampledImage(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "imageType")
                ImageType = o.To<IdRef>();
        }
    }

    public OpTypeSampledImage(int resultId, int imageType)
    {
        ResultId = resultId;
        ImageType = imageType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeSampledImage, ..ResultId.AsSpirvSpan(), ..ImageType.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeSampledImage(OpDataIndex odi) => new(odi);
}

public struct OpTypeArray : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeArray inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeArray inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ElementType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Length
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeArray(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "elementType")
                ElementType = o.To<IdRef>();
            if (o.Name == "length")
                Length = o.To<IdRef>();
        }
    }

    public OpTypeArray(int resultId, int elementType, int length)
    {
        ResultId = resultId;
        ElementType = elementType;
        Length = length;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeArray, ..ResultId.AsSpirvSpan(), ..ElementType.AsSpirvSpan(), ..Length.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeArray(OpDataIndex odi) => new(odi);
}

public struct OpTypeRuntimeArray : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeRuntimeArray inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeRuntimeArray inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ElementType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeRuntimeArray(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "elementType")
                ElementType = o.To<IdRef>();
        }
    }

    public OpTypeRuntimeArray(int resultId, int elementType)
    {
        ResultId = resultId;
        ElementType = elementType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeRuntimeArray, ..ResultId.AsSpirvSpan(), ..ElementType.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeRuntimeArray(OpDataIndex odi) => new(odi);
}

public struct OpTypeStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeStruct inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeStruct inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTypeStruct(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTypeStruct(int resultId, LiteralArray<IdRef> values)
    {
        ResultId = resultId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeStruct, ..ResultId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeStruct(OpDataIndex odi) => new(odi);
}

public struct OpTypeOpaque : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeOpaque inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeOpaque inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Thenameoftheopaquetype
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeOpaque(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "thenameoftheopaquetype")
                Thenameoftheopaquetype = o.To<LiteralString>();
        }
    }

    public OpTypeOpaque(int resultId, LiteralString thenameoftheopaquetype)
    {
        ResultId = resultId;
        Thenameoftheopaquetype = thenameoftheopaquetype;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeOpaque, ..ResultId.AsSpirvSpan(), ..Thenameoftheopaquetype.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeOpaque(OpDataIndex odi) => new(odi);
}

public struct OpTypePointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypePointer inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypePointer inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypePointer(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
            if (o.Name == "type")
                Type = o.To<IdRef>();
        }
    }

    public OpTypePointer(int resultId, StorageClass storageclass, int type)
    {
        ResultId = resultId;
        Storageclass = storageclass;
        Type = type;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypePointer, ..ResultId.AsSpirvSpan(), ..Storageclass.AsSpirvSpan(), ..Type.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypePointer(OpDataIndex odi) => new(odi);
}

public struct OpTypeFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeFunction inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeFunction inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReturnType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTypeFunction(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "returnType")
                ReturnType = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTypeFunction(int resultId, int returnType, LiteralArray<IdRef> values)
    {
        ResultId = resultId;
        ReturnType = returnType;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeFunction, ..ResultId.AsSpirvSpan(), ..ReturnType.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeFunction(OpDataIndex odi) => new(odi);
}

public struct OpTypeEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeEvent inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeEvent inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeEvent(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeEvent(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeEvent, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeEvent(OpDataIndex odi) => new(odi);
}

public struct OpTypeDeviceEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeDeviceEvent inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeDeviceEvent inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeDeviceEvent(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeDeviceEvent(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeDeviceEvent, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeDeviceEvent(OpDataIndex odi) => new(odi);
}

public struct OpTypeReserveId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeReserveId inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeReserveId inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeReserveId(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeReserveId(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeReserveId, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeReserveId(OpDataIndex odi) => new(odi);
}

public struct OpTypeQueue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeQueue inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeQueue inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeQueue(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeQueue(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeQueue, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeQueue(OpDataIndex odi) => new(odi);
}

public struct OpTypePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypePipe inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypePipe inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public AccessQualifier Qualifier
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypePipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "qualifier")
                Qualifier = o.ToEnum<AccessQualifier>();
        }
    }

    public OpTypePipe(int resultId, AccessQualifier qualifier)
    {
        ResultId = resultId;
        Qualifier = qualifier;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypePipe, ..ResultId.AsSpirvSpan(), ..Qualifier.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypePipe(OpDataIndex odi) => new(odi);
}

public struct OpTypeForwardPointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int PointerType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeForwardPointer(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointerType")
                PointerType = o.To<IdRef>();
            if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
        }
    }

    public OpTypeForwardPointer(int pointerType, StorageClass storageclass)
    {
        PointerType = pointerType;
        Storageclass = storageclass;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeForwardPointer, ..PointerType.AsSpirvSpan(), ..Storageclass.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeForwardPointer(OpDataIndex odi) => new(odi);
}

public struct OpFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFunction inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFunction inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public FunctionControlMask Functioncontrol
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FunctionType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFunction(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "functioncontrol")
                Functioncontrol = o.ToEnum<FunctionControlMask>();
            if (o.Name == "functionType")
                FunctionType = o.To<IdRef>();
        }
    }

    public OpFunction(int resultType, int resultId, FunctionControlMask functioncontrol, int functionType)
    {
        ResultType = resultType;
        ResultId = resultId;
        Functioncontrol = functioncontrol;
        FunctionType = functionType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFunction, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Functioncontrol.AsSpirvSpan(), ..FunctionType.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFunction(OpDataIndex odi) => new(odi);
}

public struct OpFunctionParameter : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFunctionParameter inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFunctionParameter inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFunctionParameter(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpFunctionParameter(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFunctionParameter, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFunctionParameter(OpDataIndex odi) => new(odi);
}

public struct OpFunctionEnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionEnd(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpFunctionEnd(OpDataIndex odi) => new(odi);
}

public struct OpFunctionCall : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFunctionCall inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFunctionCall inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Function
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpFunctionCall(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "function")
                Function = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpFunctionCall(int resultType, int resultId, int function, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Function = function;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFunctionCall, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Function.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFunctionCall(OpDataIndex odi) => new(odi);
}

public struct OpVariable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpVariable inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpVariable inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Initializer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpVariable(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
            if (o.Name == "initializer")
                Initializer = o.To<IdRef>();
        }
    }

    public OpVariable(int resultType, int resultId, StorageClass storageclass, int? initializer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        Initializer = initializer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpVariable, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Storageclass.AsSpirvSpan(), ..Initializer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVariable(OpDataIndex odi) => new(odi);
}

public struct OpImageTexelPointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageTexelPointer inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageTexelPointer inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Sample
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageTexelPointer(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "sample")
                Sample = o.To<IdRef>();
        }
    }

    public OpImageTexelPointer(int resultType, int resultId, int image, int coordinate, int sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageTexelPointer, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Sample.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageTexelPointer(OpDataIndex odi) => new(odi);
}

public struct OpLoad : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpLoad inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpLoad inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLoad(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memoryaccess")
                Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }
    }

    public OpLoad(int resultType, int resultId, int pointer, MemoryAccessMask? memoryaccess)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLoad, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memoryaccess.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLoad(OpDataIndex odi) => new(odi);
}

public struct OpStore : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpStore(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "objectId")
                ObjectId = o.To<IdRef>();
            if (o.Name == "memoryaccess")
                Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }
    }

    public OpStore(int pointer, int objectId, MemoryAccessMask? memoryaccess)
    {
        Pointer = pointer;
        ObjectId = objectId;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpStore, ..Pointer.AsSpirvSpan(), ..ObjectId.AsSpirvSpan(), ..Memoryaccess.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpStore(OpDataIndex odi) => new(odi);
}

public struct OpAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAccessChain inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAccessChain inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpAccessChain(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpAccessChain(int resultType, int resultId, int baseId, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAccessChain, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAccessChain(OpDataIndex odi) => new(odi);
}

public struct OpInBoundsAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpInBoundsAccessChain inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpInBoundsAccessChain inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpInBoundsAccessChain(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpInBoundsAccessChain(int resultType, int resultId, int baseId, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpInBoundsAccessChain, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpInBoundsAccessChain(OpDataIndex odi) => new(odi);
}

public struct OpPtrAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpPtrAccessChain inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpPtrAccessChain inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpPtrAccessChain(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "element")
                Element = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpPtrAccessChain(int resultType, int resultId, int baseId, int element, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Element = element;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpPtrAccessChain, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Element.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrAccessChain(OpDataIndex odi) => new(odi);
}

public struct OpArrayLength : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArrayLength inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArrayLength inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Structure
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Arraymember
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArrayLength(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "structure")
                Structure = o.To<IdRef>();
            if (o.Name == "arraymember")
                Arraymember = o.To<LiteralInteger>();
        }
    }

    public OpArrayLength(int resultType, int resultId, int structure, int arraymember)
    {
        ResultType = resultType;
        ResultId = resultId;
        Structure = structure;
        Arraymember = arraymember;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArrayLength, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Structure.AsSpirvSpan(), ..Arraymember.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArrayLength(OpDataIndex odi) => new(odi);
}

public struct OpGenericPtrMemSemantics : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGenericPtrMemSemantics inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGenericPtrMemSemantics inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGenericPtrMemSemantics(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
        }
    }

    public OpGenericPtrMemSemantics(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGenericPtrMemSemantics, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGenericPtrMemSemantics(OpDataIndex odi) => new(odi);
}

public struct OpInBoundsPtrAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpInBoundsPtrAccessChain inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpInBoundsPtrAccessChain inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpInBoundsPtrAccessChain(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "element")
                Element = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpInBoundsPtrAccessChain(int resultType, int resultId, int baseId, int element, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Element = element;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpInBoundsPtrAccessChain, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Element.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpInBoundsPtrAccessChain(OpDataIndex odi) => new(odi);
}

public struct OpDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDecorate(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "target")
                Target = o.To<IdRef>();
            if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
        }
    }

    public OpDecorate(int target, Decoration decoration)
    {
        Target = target;
        Decoration = decoration;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDecorate, ..Target.AsSpirvSpan(), ..Decoration.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDecorate(OpDataIndex odi) => new(odi);
}

public struct OpMemberDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int StructureType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMemberDecorate(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "structureType")
                StructureType = o.To<IdRef>();
            if (o.Name == "member")
                Member = o.To<LiteralInteger>();
            if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
        }
    }

    public OpMemberDecorate(int structureType, int member, Decoration decoration)
    {
        StructureType = structureType;
        Member = member;
        Decoration = decoration;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMemberDecorate, ..StructureType.AsSpirvSpan(), ..Member.AsSpirvSpan(), ..Decoration.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemberDecorate(OpDataIndex odi) => new(odi);
}

public struct OpDecorationGroup : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDecorationGroup inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDecorationGroup inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDecorationGroup(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpDecorationGroup(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDecorationGroup, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDecorationGroup(OpDataIndex odi) => new(odi);
}

public struct OpGroupDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int DecorationGroup
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpGroupDecorate(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "decorationGroup")
                DecorationGroup = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpGroupDecorate(int decorationGroup, LiteralArray<IdRef> values)
    {
        DecorationGroup = decorationGroup;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupDecorate, ..DecorationGroup.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupDecorate(OpDataIndex odi) => new(odi);
}

public struct OpGroupMemberDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int DecorationGroup
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<PairIdRefLiteralInteger> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpGroupMemberDecorate(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "decorationGroup")
                DecorationGroup = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<PairIdRefLiteralInteger>>();
        }
    }

    public OpGroupMemberDecorate(int decorationGroup, LiteralArray<PairIdRefLiteralInteger> values)
    {
        DecorationGroup = decorationGroup;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupMemberDecorate, ..DecorationGroup.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupMemberDecorate(OpDataIndex odi) => new(odi);
}

public struct OpVectorExtractDynamic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpVectorExtractDynamic inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpVectorExtractDynamic inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpVectorExtractDynamic(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector")
                Vector = o.To<IdRef>();
            if (o.Name == "index")
                Index = o.To<IdRef>();
        }
    }

    public OpVectorExtractDynamic(int resultType, int resultId, int vector, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpVectorExtractDynamic, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector.AsSpirvSpan(), ..Index.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorExtractDynamic(OpDataIndex odi) => new(odi);
}

public struct OpVectorInsertDynamic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpVectorInsertDynamic inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpVectorInsertDynamic inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpVectorInsertDynamic(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector")
                Vector = o.To<IdRef>();
            if (o.Name == "component")
                Component = o.To<IdRef>();
            if (o.Name == "index")
                Index = o.To<IdRef>();
        }
    }

    public OpVectorInsertDynamic(int resultType, int resultId, int vector, int component, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Component = component;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpVectorInsertDynamic, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector.AsSpirvSpan(), ..Component.AsSpirvSpan(), ..Index.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorInsertDynamic(OpDataIndex odi) => new(odi);
}

public struct OpVectorShuffle : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpVectorShuffle inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpVectorShuffle inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<LiteralInteger> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpVectorShuffle(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<LiteralInteger>>();
        }
    }

    public OpVectorShuffle(int resultType, int resultId, int vector1, int vector2, LiteralArray<LiteralInteger> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpVectorShuffle, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorShuffle(OpDataIndex odi) => new(odi);
}

public struct OpCompositeConstruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCompositeConstruct inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCompositeConstruct inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpCompositeConstruct(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpCompositeConstruct(int resultType, int resultId, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCompositeConstruct, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeConstruct(OpDataIndex odi) => new(odi);
}

public struct OpCompositeExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCompositeExtract inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCompositeExtract inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Composite
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<LiteralInteger> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpCompositeExtract(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "composite")
                Composite = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<LiteralInteger>>();
        }
    }

    public OpCompositeExtract(int resultType, int resultId, int composite, LiteralArray<LiteralInteger> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Composite = composite;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCompositeExtract, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Composite.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeExtract(OpDataIndex odi) => new(odi);
}

public struct OpCompositeInsert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCompositeInsert inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCompositeInsert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Composite
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<LiteralInteger> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpCompositeInsert(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "objectId")
                ObjectId = o.To<IdRef>();
            if (o.Name == "composite")
                Composite = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<LiteralInteger>>();
        }
    }

    public OpCompositeInsert(int resultType, int resultId, int objectId, int composite, LiteralArray<LiteralInteger> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        ObjectId = objectId;
        Composite = composite;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCompositeInsert, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ObjectId.AsSpirvSpan(), ..Composite.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeInsert(OpDataIndex odi) => new(odi);
}

public struct OpCopyObject : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCopyObject inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCopyObject inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCopyObject(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpCopyObject(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCopyObject, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCopyObject(OpDataIndex odi) => new(odi);
}

public struct OpTranspose : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTranspose inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTranspose inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTranspose(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "matrix")
                Matrix = o.To<IdRef>();
        }
    }

    public OpTranspose(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTranspose, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Matrix.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTranspose(OpDataIndex odi) => new(odi);
}

public struct OpSampledImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSampledImage inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSampledImage inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Sampler
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSampledImage(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "sampler")
                Sampler = o.To<IdRef>();
        }
    }

    public OpSampledImage(int resultType, int resultId, int image, int sampler)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Sampler = sampler;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSampledImage, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Sampler.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSampledImage(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleImplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleImplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleImplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleExplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleExplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleExplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleDrefImplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleDrefImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleDrefImplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleDrefImplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleDrefImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleDrefExplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleDrefExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleDrefExplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleDrefExplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleDrefExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleProjImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleProjImplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleProjImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleProjImplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleProjImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleProjImplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleProjImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleProjExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleProjExplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleProjExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleProjExplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleProjExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleProjExplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleProjExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleProjDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleProjDrefImplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleProjDrefImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleProjDrefImplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleProjDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleProjDrefImplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleProjDrefImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleProjDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleProjDrefExplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleProjDrefExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleProjDrefExplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleProjDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleProjDrefExplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleProjDrefExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageFetch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageFetch inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageFetch inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageFetch(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageFetch(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageFetch, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageFetch(OpDataIndex odi) => new(odi);
}

public struct OpImageGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageGather inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageGather inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageGather(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "component")
                Component = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageGather(int resultType, int resultId, int sampledImage, int coordinate, int component, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Component = component;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageGather, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Component.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageGather(OpDataIndex odi) => new(odi);
}

public struct OpImageDrefGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageDrefGather inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageDrefGather inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageDrefGather(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageDrefGather(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageDrefGather, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageDrefGather(OpDataIndex odi) => new(odi);
}

public struct OpImageRead : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageRead inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageRead inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageRead(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageRead(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageRead, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageRead(OpDataIndex odi) => new(odi);
}

public struct OpImageWrite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Texel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageWrite(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "texel")
                Texel = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageWrite(int image, int coordinate, int texel, ImageOperandsMask? imageoperands)
    {
        Image = image;
        Coordinate = coordinate;
        Texel = texel;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageWrite, ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Texel.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageWrite(OpDataIndex odi) => new(odi);
}

public struct OpImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImage inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImage inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImage(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
        }
    }

    public OpImage(int resultType, int resultId, int sampledImage)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImage, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImage(OpDataIndex odi) => new(odi);
}

public struct OpImageQueryFormat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageQueryFormat inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageQueryFormat inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageQueryFormat(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
        }
    }

    public OpImageQueryFormat(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageQueryFormat, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQueryFormat(OpDataIndex odi) => new(odi);
}

public struct OpImageQueryOrder : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageQueryOrder inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageQueryOrder inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageQueryOrder(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
        }
    }

    public OpImageQueryOrder(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageQueryOrder, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQueryOrder(OpDataIndex odi) => new(odi);
}

public struct OpImageQuerySizeLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageQuerySizeLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageQuerySizeLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LevelofDetail
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageQuerySizeLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "levelofDetail")
                LevelofDetail = o.To<IdRef>();
        }
    }

    public OpImageQuerySizeLod(int resultType, int resultId, int image, int levelofDetail)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        LevelofDetail = levelofDetail;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageQuerySizeLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..LevelofDetail.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQuerySizeLod(OpDataIndex odi) => new(odi);
}

public struct OpImageQuerySize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageQuerySize inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageQuerySize inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageQuerySize(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
        }
    }

    public OpImageQuerySize(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageQuerySize, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQuerySize(OpDataIndex odi) => new(odi);
}

public struct OpImageQueryLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageQueryLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageQueryLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageQueryLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
        }
    }

    public OpImageQueryLod(int resultType, int resultId, int sampledImage, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageQueryLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQueryLod(OpDataIndex odi) => new(odi);
}

public struct OpImageQueryLevels : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageQueryLevels inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageQueryLevels inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageQueryLevels(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
        }
    }

    public OpImageQueryLevels(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageQueryLevels, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQueryLevels(OpDataIndex odi) => new(odi);
}

public struct OpImageQuerySamples : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageQuerySamples inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageQuerySamples inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageQuerySamples(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
        }
    }

    public OpImageQuerySamples(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageQuerySamples, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageQuerySamples(OpDataIndex odi) => new(odi);
}

public struct OpConvertFToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertFToU inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertFToU inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertFToU(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "floatValue")
                FloatValue = o.To<IdRef>();
        }
    }

    public OpConvertFToU(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertFToU, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..FloatValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertFToU(OpDataIndex odi) => new(odi);
}

public struct OpConvertFToS : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertFToS inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertFToS inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertFToS(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "floatValue")
                FloatValue = o.To<IdRef>();
        }
    }

    public OpConvertFToS(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertFToS, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..FloatValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertFToS(OpDataIndex odi) => new(odi);
}

public struct OpConvertSToF : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertSToF inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertSToF inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertSToF(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "signedValue")
                SignedValue = o.To<IdRef>();
        }
    }

    public OpConvertSToF(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertSToF, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SignedValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertSToF(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToF : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertUToF inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertUToF inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertUToF(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "unsignedValue")
                UnsignedValue = o.To<IdRef>();
        }
    }

    public OpConvertUToF(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertUToF, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..UnsignedValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToF(OpDataIndex odi) => new(odi);
}

public struct OpUConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUConvert inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUConvert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUConvert(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "unsignedValue")
                UnsignedValue = o.To<IdRef>();
        }
    }

    public OpUConvert(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUConvert, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..UnsignedValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUConvert(OpDataIndex odi) => new(odi);
}

public struct OpSConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSConvert inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSConvert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSConvert(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "signedValue")
                SignedValue = o.To<IdRef>();
        }
    }

    public OpSConvert(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSConvert, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SignedValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSConvert(OpDataIndex odi) => new(odi);
}

public struct OpFConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFConvert inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFConvert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFConvert(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "floatValue")
                FloatValue = o.To<IdRef>();
        }
    }

    public OpFConvert(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFConvert, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..FloatValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFConvert(OpDataIndex odi) => new(odi);
}

public struct OpQuantizeToF16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpQuantizeToF16 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpQuantizeToF16 inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpQuantizeToF16(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpQuantizeToF16(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpQuantizeToF16, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpQuantizeToF16(OpDataIndex odi) => new(odi);
}

public struct OpConvertPtrToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertPtrToU inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertPtrToU inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertPtrToU(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
        }
    }

    public OpConvertPtrToU(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertPtrToU, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertPtrToU(OpDataIndex odi) => new(odi);
}

public struct OpSatConvertSToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSatConvertSToU inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSatConvertSToU inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSatConvertSToU(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "signedValue")
                SignedValue = o.To<IdRef>();
        }
    }

    public OpSatConvertSToU(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSatConvertSToU, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SignedValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSatConvertSToU(OpDataIndex odi) => new(odi);
}

public struct OpSatConvertUToS : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSatConvertUToS inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSatConvertUToS inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSatConvertUToS(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "unsignedValue")
                UnsignedValue = o.To<IdRef>();
        }
    }

    public OpSatConvertUToS(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSatConvertUToS, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..UnsignedValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSatConvertUToS(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToPtr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertUToPtr inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertUToPtr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int IntegerValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertUToPtr(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "integerValue")
                IntegerValue = o.To<IdRef>();
        }
    }

    public OpConvertUToPtr(int resultType, int resultId, int integerValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        IntegerValue = integerValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertUToPtr, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..IntegerValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToPtr(OpDataIndex odi) => new(odi);
}

public struct OpPtrCastToGeneric : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpPtrCastToGeneric inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpPtrCastToGeneric inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpPtrCastToGeneric(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
        }
    }

    public OpPtrCastToGeneric(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpPtrCastToGeneric, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrCastToGeneric(OpDataIndex odi) => new(odi);
}

public struct OpGenericCastToPtr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGenericCastToPtr inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGenericCastToPtr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGenericCastToPtr(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
        }
    }

    public OpGenericCastToPtr(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGenericCastToPtr, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGenericCastToPtr(OpDataIndex odi) => new(odi);
}

public struct OpGenericCastToPtrExplicit : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGenericCastToPtrExplicit inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGenericCastToPtrExplicit inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public StorageClass Storage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGenericCastToPtrExplicit(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "storage")
                Storage = o.ToEnum<StorageClass>();
        }
    }

    public OpGenericCastToPtrExplicit(int resultType, int resultId, int pointer, StorageClass storage)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Storage = storage;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGenericCastToPtrExplicit, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Storage.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGenericCastToPtrExplicit(OpDataIndex odi) => new(odi);
}

public struct OpBitcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitcast inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitcast inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitcast(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpBitcast(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitcast, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitcast(OpDataIndex odi) => new(odi);
}

public struct OpSNegate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSNegate inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSNegate inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSNegate(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpSNegate(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSNegate, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSNegate(OpDataIndex odi) => new(odi);
}

public struct OpFNegate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFNegate inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFNegate inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFNegate(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpFNegate(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFNegate, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFNegate(OpDataIndex odi) => new(odi);
}

public struct OpIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIAdd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIAdd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpIAdd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIAdd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAdd(OpDataIndex odi) => new(odi);
}

public struct OpFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFAdd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFAdd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFAdd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFAdd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFAdd(OpDataIndex odi) => new(odi);
}

public struct OpISub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpISub inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpISub inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpISub(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpISub(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpISub, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpISub(OpDataIndex odi) => new(odi);
}

public struct OpFSub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFSub inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFSub inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFSub(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFSub(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFSub, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFSub(OpDataIndex odi) => new(odi);
}

public struct OpIMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIMul inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIMul inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIMul(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpIMul(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIMul, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIMul(OpDataIndex odi) => new(odi);
}

public struct OpFMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFMul inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFMul inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFMul(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFMul(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFMul, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFMul(OpDataIndex odi) => new(odi);
}

public struct OpUDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUDiv inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUDiv inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUDiv(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUDiv, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUDiv(OpDataIndex odi) => new(odi);
}

public struct OpSDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSDiv inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSDiv inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDiv(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpSDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDiv, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDiv(OpDataIndex odi) => new(odi);
}

public struct OpFDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFDiv inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFDiv inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFDiv(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFDiv, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFDiv(OpDataIndex odi) => new(odi);
}

public struct OpUMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUMod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUMod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUMod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUMod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUMod(OpDataIndex odi) => new(odi);
}

public struct OpSRem : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSRem inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSRem inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSRem(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpSRem(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSRem, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSRem(OpDataIndex odi) => new(odi);
}

public struct OpSMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSMod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSMod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSMod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpSMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSMod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSMod(OpDataIndex odi) => new(odi);
}

public struct OpFRem : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFRem inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFRem inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFRem(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFRem(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFRem, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFRem(OpDataIndex odi) => new(odi);
}

public struct OpFMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFMod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFMod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFMod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFMod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFMod(OpDataIndex odi) => new(odi);
}

public struct OpVectorTimesScalar : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpVectorTimesScalar inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpVectorTimesScalar inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Scalar
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpVectorTimesScalar(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector")
                Vector = o.To<IdRef>();
            if (o.Name == "scalar")
                Scalar = o.To<IdRef>();
        }
    }

    public OpVectorTimesScalar(int resultType, int resultId, int vector, int scalar)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Scalar = scalar;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpVectorTimesScalar, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector.AsSpirvSpan(), ..Scalar.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorTimesScalar(OpDataIndex odi) => new(odi);
}

public struct OpMatrixTimesScalar : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpMatrixTimesScalar inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpMatrixTimesScalar inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Scalar
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMatrixTimesScalar(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "matrix")
                Matrix = o.To<IdRef>();
            if (o.Name == "scalar")
                Scalar = o.To<IdRef>();
        }
    }

    public OpMatrixTimesScalar(int resultType, int resultId, int matrix, int scalar)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Scalar = scalar;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMatrixTimesScalar, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Matrix.AsSpirvSpan(), ..Scalar.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMatrixTimesScalar(OpDataIndex odi) => new(odi);
}

public struct OpVectorTimesMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpVectorTimesMatrix inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpVectorTimesMatrix inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpVectorTimesMatrix(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector")
                Vector = o.To<IdRef>();
            if (o.Name == "matrix")
                Matrix = o.To<IdRef>();
        }
    }

    public OpVectorTimesMatrix(int resultType, int resultId, int vector, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Matrix = matrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpVectorTimesMatrix, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector.AsSpirvSpan(), ..Matrix.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVectorTimesMatrix(OpDataIndex odi) => new(odi);
}

public struct OpMatrixTimesVector : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpMatrixTimesVector inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpMatrixTimesVector inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMatrixTimesVector(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "matrix")
                Matrix = o.To<IdRef>();
            if (o.Name == "vector")
                Vector = o.To<IdRef>();
        }
    }

    public OpMatrixTimesVector(int resultType, int resultId, int matrix, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Vector = vector;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMatrixTimesVector, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Matrix.AsSpirvSpan(), ..Vector.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMatrixTimesVector(OpDataIndex odi) => new(odi);
}

public struct OpMatrixTimesMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpMatrixTimesMatrix inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpMatrixTimesMatrix inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LeftMatrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RightMatrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMatrixTimesMatrix(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "leftMatrix")
                LeftMatrix = o.To<IdRef>();
            if (o.Name == "rightMatrix")
                RightMatrix = o.To<IdRef>();
        }
    }

    public OpMatrixTimesMatrix(int resultType, int resultId, int leftMatrix, int rightMatrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        LeftMatrix = leftMatrix;
        RightMatrix = rightMatrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMatrixTimesMatrix, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..LeftMatrix.AsSpirvSpan(), ..RightMatrix.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMatrixTimesMatrix(OpDataIndex odi) => new(odi);
}

public struct OpOuterProduct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpOuterProduct inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpOuterProduct inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpOuterProduct(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
        }
    }

    public OpOuterProduct(int resultType, int resultId, int vector1, int vector2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpOuterProduct, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpOuterProduct(OpDataIndex odi) => new(odi);
}

public struct OpDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDot inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDot(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
        }
    }

    public OpDot(int resultType, int resultId, int vector1, int vector2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDot, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDot(OpDataIndex odi) => new(odi);
}

public struct OpIAddCarry : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIAddCarry inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIAddCarry inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIAddCarry(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpIAddCarry(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIAddCarry, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAddCarry(OpDataIndex odi) => new(odi);
}

public struct OpISubBorrow : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpISubBorrow inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpISubBorrow inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpISubBorrow(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpISubBorrow(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpISubBorrow, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpISubBorrow(OpDataIndex odi) => new(odi);
}

public struct OpUMulExtended : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUMulExtended inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUMulExtended inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUMulExtended(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUMulExtended(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUMulExtended, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUMulExtended(OpDataIndex odi) => new(odi);
}

public struct OpSMulExtended : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSMulExtended inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSMulExtended inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSMulExtended(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpSMulExtended(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSMulExtended, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSMulExtended(OpDataIndex odi) => new(odi);
}

public struct OpAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAny inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAny inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAny(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector")
                Vector = o.To<IdRef>();
        }
    }

    public OpAny(int resultType, int resultId, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAny, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAny(OpDataIndex odi) => new(odi);
}

public struct OpAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAll inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAll inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAll(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector")
                Vector = o.To<IdRef>();
        }
    }

    public OpAll(int resultType, int resultId, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAll, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAll(OpDataIndex odi) => new(odi);
}

public struct OpIsNan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIsNan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIsNan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIsNan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpIsNan(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIsNan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsNan(OpDataIndex odi) => new(odi);
}

public struct OpIsInf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIsInf inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIsInf inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIsInf(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpIsInf(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIsInf, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsInf(OpDataIndex odi) => new(odi);
}

public struct OpIsFinite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIsFinite inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIsFinite inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIsFinite(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpIsFinite(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIsFinite, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsFinite(OpDataIndex odi) => new(odi);
}

public struct OpIsNormal : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIsNormal inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIsNormal inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIsNormal(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpIsNormal(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIsNormal, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsNormal(OpDataIndex odi) => new(odi);
}

public struct OpSignBitSet : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSignBitSet inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSignBitSet inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSignBitSet(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpSignBitSet(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSignBitSet, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSignBitSet(OpDataIndex odi) => new(odi);
}

public struct OpLessOrGreater : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpLessOrGreater inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpLessOrGreater inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLessOrGreater(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public OpLessOrGreater(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLessOrGreater, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLessOrGreater(OpDataIndex odi) => new(odi);
}

public struct OpOrdered : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpOrdered inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpOrdered inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpOrdered(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public OpOrdered(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpOrdered, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpOrdered(OpDataIndex odi) => new(odi);
}

public struct OpUnordered : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUnordered inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUnordered inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUnordered(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public OpUnordered(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUnordered, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUnordered(OpDataIndex odi) => new(odi);
}

public struct OpLogicalEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpLogicalEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpLogicalEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLogicalEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpLogicalEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLogicalEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalEqual(OpDataIndex odi) => new(odi);
}

public struct OpLogicalNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpLogicalNotEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpLogicalNotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLogicalNotEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpLogicalNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLogicalNotEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalNotEqual(OpDataIndex odi) => new(odi);
}

public struct OpLogicalOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpLogicalOr inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpLogicalOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLogicalOr(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpLogicalOr(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLogicalOr, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalOr(OpDataIndex odi) => new(odi);
}

public struct OpLogicalAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpLogicalAnd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpLogicalAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLogicalAnd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpLogicalAnd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLogicalAnd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalAnd(OpDataIndex odi) => new(odi);
}

public struct OpLogicalNot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpLogicalNot inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpLogicalNot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLogicalNot(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpLogicalNot(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLogicalNot, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLogicalNot(OpDataIndex odi) => new(odi);
}

public struct OpSelect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSelect inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSelect inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Object1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Object2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSelect(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "condition")
                Condition = o.To<IdRef>();
            if (o.Name == "object1")
                Object1 = o.To<IdRef>();
            if (o.Name == "object2")
                Object2 = o.To<IdRef>();
        }
    }

    public OpSelect(int resultType, int resultId, int condition, int object1, int object2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Condition = condition;
        Object1 = object1;
        Object2 = object2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSelect, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Condition.AsSpirvSpan(), ..Object1.AsSpirvSpan(), ..Object2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSelect(OpDataIndex odi) => new(odi);
}

public struct OpIEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpIEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIEqual(OpDataIndex odi) => new(odi);
}

public struct OpINotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpINotEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpINotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpINotEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpINotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpINotEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpINotEqual(OpDataIndex odi) => new(odi);
}

public struct OpUGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUGreaterThan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUGreaterThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUGreaterThan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUGreaterThan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUGreaterThan(OpDataIndex odi) => new(odi);
}

public struct OpSGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSGreaterThan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSGreaterThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSGreaterThan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpSGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSGreaterThan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSGreaterThan(OpDataIndex odi) => new(odi);
}

public struct OpUGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUGreaterThanEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUGreaterThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUGreaterThanEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUGreaterThanEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpSGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSGreaterThanEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSGreaterThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSGreaterThanEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpSGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSGreaterThanEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpULessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpULessThan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpULessThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpULessThan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpULessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpULessThan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpULessThan(OpDataIndex odi) => new(odi);
}

public struct OpSLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSLessThan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSLessThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSLessThan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpSLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSLessThan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSLessThan(OpDataIndex odi) => new(odi);
}

public struct OpULessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpULessThanEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpULessThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpULessThanEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpULessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpULessThanEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpULessThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpSLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSLessThanEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSLessThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSLessThanEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpSLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSLessThanEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSLessThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpFOrdEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFOrdEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFOrdEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFOrdEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFOrdEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFOrdEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdEqual(OpDataIndex odi) => new(odi);
}

public struct OpFUnordEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFUnordEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFUnordEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFUnordEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFUnordEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFUnordEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordEqual(OpDataIndex odi) => new(odi);
}

public struct OpFOrdNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFOrdNotEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFOrdNotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFOrdNotEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFOrdNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFOrdNotEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdNotEqual(OpDataIndex odi) => new(odi);
}

public struct OpFUnordNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFUnordNotEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFUnordNotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFUnordNotEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFUnordNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFUnordNotEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordNotEqual(OpDataIndex odi) => new(odi);
}

public struct OpFOrdLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFOrdLessThan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFOrdLessThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFOrdLessThan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFOrdLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFOrdLessThan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdLessThan(OpDataIndex odi) => new(odi);
}

public struct OpFUnordLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFUnordLessThan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFUnordLessThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFUnordLessThan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFUnordLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFUnordLessThan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordLessThan(OpDataIndex odi) => new(odi);
}

public struct OpFOrdGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFOrdGreaterThan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFOrdGreaterThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFOrdGreaterThan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFOrdGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFOrdGreaterThan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdGreaterThan(OpDataIndex odi) => new(odi);
}

public struct OpFUnordGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFUnordGreaterThan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFUnordGreaterThan inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFUnordGreaterThan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFUnordGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFUnordGreaterThan, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordGreaterThan(OpDataIndex odi) => new(odi);
}

public struct OpFOrdLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFOrdLessThanEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFOrdLessThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFOrdLessThanEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFOrdLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFOrdLessThanEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdLessThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpFUnordLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFUnordLessThanEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFUnordLessThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFUnordLessThanEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFUnordLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFUnordLessThanEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordLessThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpFOrdGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFOrdGreaterThanEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFOrdGreaterThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFOrdGreaterThanEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFOrdGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFOrdGreaterThanEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFOrdGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpFUnordGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFUnordGreaterThanEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFUnordGreaterThanEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFUnordGreaterThanEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpFUnordGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFUnordGreaterThanEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFUnordGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public struct OpShiftRightLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpShiftRightLogical inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpShiftRightLogical inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpShiftRightLogical(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "shift")
                Shift = o.To<IdRef>();
        }
    }

    public OpShiftRightLogical(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpShiftRightLogical, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Shift.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpShiftRightLogical(OpDataIndex odi) => new(odi);
}

public struct OpShiftRightArithmetic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpShiftRightArithmetic inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpShiftRightArithmetic inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpShiftRightArithmetic(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "shift")
                Shift = o.To<IdRef>();
        }
    }

    public OpShiftRightArithmetic(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpShiftRightArithmetic, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Shift.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpShiftRightArithmetic(OpDataIndex odi) => new(odi);
}

public struct OpShiftLeftLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpShiftLeftLogical inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpShiftLeftLogical inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpShiftLeftLogical(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "shift")
                Shift = o.To<IdRef>();
        }
    }

    public OpShiftLeftLogical(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpShiftLeftLogical, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Shift.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpShiftLeftLogical(OpDataIndex odi) => new(odi);
}

public struct OpBitwiseOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitwiseOr inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitwiseOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitwiseOr(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpBitwiseOr(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitwiseOr, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitwiseOr(OpDataIndex odi) => new(odi);
}

public struct OpBitwiseXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitwiseXor inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitwiseXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitwiseXor(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpBitwiseXor(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitwiseXor, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitwiseXor(OpDataIndex odi) => new(odi);
}

public struct OpBitwiseAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitwiseAnd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitwiseAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitwiseAnd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpBitwiseAnd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitwiseAnd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitwiseAnd(OpDataIndex odi) => new(odi);
}

public struct OpNot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpNot inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpNot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpNot(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpNot(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpNot, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpNot(OpDataIndex odi) => new(odi);
}

public struct OpBitFieldInsert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitFieldInsert inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitFieldInsert inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Insert
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitFieldInsert(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "insert")
                Insert = o.To<IdRef>();
            if (o.Name == "offset")
                Offset = o.To<IdRef>();
            if (o.Name == "count")
                Count = o.To<IdRef>();
        }
    }

    public OpBitFieldInsert(int resultType, int resultId, int baseId, int insert, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Insert = insert;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitFieldInsert, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Insert.AsSpirvSpan(), ..Offset.AsSpirvSpan(), ..Count.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitFieldInsert(OpDataIndex odi) => new(odi);
}

public struct OpBitFieldSExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitFieldSExtract inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitFieldSExtract inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitFieldSExtract(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "offset")
                Offset = o.To<IdRef>();
            if (o.Name == "count")
                Count = o.To<IdRef>();
        }
    }

    public OpBitFieldSExtract(int resultType, int resultId, int baseId, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitFieldSExtract, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Offset.AsSpirvSpan(), ..Count.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitFieldSExtract(OpDataIndex odi) => new(odi);
}

public struct OpBitFieldUExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitFieldUExtract inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitFieldUExtract inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitFieldUExtract(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "offset")
                Offset = o.To<IdRef>();
            if (o.Name == "count")
                Count = o.To<IdRef>();
        }
    }

    public OpBitFieldUExtract(int resultType, int resultId, int baseId, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitFieldUExtract, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Offset.AsSpirvSpan(), ..Count.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitFieldUExtract(OpDataIndex odi) => new(odi);
}

public struct OpBitReverse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitReverse inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitReverse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitReverse(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
        }
    }

    public OpBitReverse(int resultType, int resultId, int baseId)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitReverse, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitReverse(OpDataIndex odi) => new(odi);
}

public struct OpBitCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBitCount inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBitCount inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBitCount(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
        }
    }

    public OpBitCount(int resultType, int resultId, int baseId)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBitCount, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBitCount(OpDataIndex odi) => new(odi);
}

public struct OpDPdx : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDPdx inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDPdx inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDPdx(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpDPdx(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDPdx, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdx(OpDataIndex odi) => new(odi);
}

public struct OpDPdy : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDPdy inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDPdy inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDPdy(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpDPdy(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDPdy, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdy(OpDataIndex odi) => new(odi);
}

public struct OpFwidth : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFwidth inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFwidth inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFwidth(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpFwidth(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFwidth, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFwidth(OpDataIndex odi) => new(odi);
}

public struct OpDPdxFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDPdxFine inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDPdxFine inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDPdxFine(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpDPdxFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDPdxFine, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdxFine(OpDataIndex odi) => new(odi);
}

public struct OpDPdyFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDPdyFine inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDPdyFine inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDPdyFine(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpDPdyFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDPdyFine, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdyFine(OpDataIndex odi) => new(odi);
}

public struct OpFwidthFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFwidthFine inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFwidthFine inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFwidthFine(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpFwidthFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFwidthFine, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFwidthFine(OpDataIndex odi) => new(odi);
}

public struct OpDPdxCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDPdxCoarse inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDPdxCoarse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDPdxCoarse(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpDPdxCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDPdxCoarse, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdxCoarse(OpDataIndex odi) => new(odi);
}

public struct OpDPdyCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDPdyCoarse inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDPdyCoarse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDPdyCoarse(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpDPdyCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDPdyCoarse, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDPdyCoarse(OpDataIndex odi) => new(odi);
}

public struct OpFwidthCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFwidthCoarse inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFwidthCoarse inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFwidthCoarse(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public OpFwidthCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFwidthCoarse, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFwidthCoarse(OpDataIndex odi) => new(odi);
}

public struct OpEmitVertex : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitVertex(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpEmitVertex(OpDataIndex odi) => new(odi);
}

public struct OpEndPrimitive : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndPrimitive(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpEndPrimitive(OpDataIndex odi) => new(odi);
}

public struct OpEmitStreamVertex : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Stream
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpEmitStreamVertex(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "stream")
                Stream = o.To<IdRef>();
        }
    }

    public OpEmitStreamVertex(int stream)
    {
        Stream = stream;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpEmitStreamVertex, ..Stream.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEmitStreamVertex(OpDataIndex odi) => new(odi);
}

public struct OpEndStreamPrimitive : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Stream
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpEndStreamPrimitive(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "stream")
                Stream = o.To<IdRef>();
        }
    }

    public OpEndStreamPrimitive(int stream)
    {
        Stream = stream;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpEndStreamPrimitive, ..Stream.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEndStreamPrimitive(OpDataIndex odi) => new(odi);
}

public struct OpControlBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpControlBarrier(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpControlBarrier(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpControlBarrier, ..Execution.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpControlBarrier(OpDataIndex odi) => new(odi);
}

public struct OpMemoryBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMemoryBarrier(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpMemoryBarrier(int memory, int semantics)
    {
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMemoryBarrier, ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemoryBarrier(OpDataIndex odi) => new(odi);
}

public struct OpAtomicLoad : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicLoad inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicLoad inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicLoad(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpAtomicLoad(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicLoad, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicLoad(OpDataIndex odi) => new(odi);
}

public struct OpAtomicStore : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicStore(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicStore(int pointer, int memory, int semantics, int value)
    {
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicStore, ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicStore(OpDataIndex odi) => new(odi);
}

public struct OpAtomicExchange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicExchange inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicExchange inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicExchange(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicExchange(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicExchange, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicExchange(OpDataIndex odi) => new(odi);
}

public struct OpAtomicCompareExchange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicCompareExchange inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicCompareExchange inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Equal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Unequal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Comparator
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicCompareExchange(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "equal")
                Equal = o.To<IdMemorySemantics>();
            if (o.Name == "unequal")
                Unequal = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "comparator")
                Comparator = o.To<IdRef>();
        }
    }

    public OpAtomicCompareExchange(int resultType, int resultId, int pointer, int memory, int equal, int unequal, int value, int comparator)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Equal = equal;
        Unequal = unequal;
        Value = value;
        Comparator = comparator;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicCompareExchange, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Equal.AsSpirvSpan(), ..Unequal.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Comparator.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicCompareExchange(OpDataIndex odi) => new(odi);
}

public struct OpAtomicCompareExchangeWeak : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicCompareExchangeWeak inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicCompareExchangeWeak inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Equal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Unequal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Comparator
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicCompareExchangeWeak(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "equal")
                Equal = o.To<IdMemorySemantics>();
            if (o.Name == "unequal")
                Unequal = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "comparator")
                Comparator = o.To<IdRef>();
        }
    }

    public OpAtomicCompareExchangeWeak(int resultType, int resultId, int pointer, int memory, int equal, int unequal, int value, int comparator)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Equal = equal;
        Unequal = unequal;
        Value = value;
        Comparator = comparator;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicCompareExchangeWeak, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Equal.AsSpirvSpan(), ..Unequal.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Comparator.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicCompareExchangeWeak(OpDataIndex odi) => new(odi);
}

public struct OpAtomicIIncrement : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicIIncrement inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicIIncrement inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicIIncrement(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpAtomicIIncrement(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicIIncrement, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicIIncrement(OpDataIndex odi) => new(odi);
}

public struct OpAtomicIDecrement : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicIDecrement inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicIDecrement inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicIDecrement(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpAtomicIDecrement(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicIDecrement, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicIDecrement(OpDataIndex odi) => new(odi);
}

public struct OpAtomicIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicIAdd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicIAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicIAdd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicIAdd(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicIAdd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicIAdd(OpDataIndex odi) => new(odi);
}

public struct OpAtomicISub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicISub inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicISub inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicISub(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicISub(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicISub, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicISub(OpDataIndex odi) => new(odi);
}

public struct OpAtomicSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicSMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicSMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicSMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicSMin(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicSMin, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicSMin(OpDataIndex odi) => new(odi);
}

public struct OpAtomicUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicUMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicUMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicUMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicUMin(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicUMin, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicUMin(OpDataIndex odi) => new(odi);
}

public struct OpAtomicSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicSMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicSMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicSMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicSMax(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicSMax, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicSMax(OpDataIndex odi) => new(odi);
}

public struct OpAtomicUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicUMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicUMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicUMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicUMax(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicUMax, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicUMax(OpDataIndex odi) => new(odi);
}

public struct OpAtomicAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicAnd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicAnd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicAnd(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicAnd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicAnd(OpDataIndex odi) => new(odi);
}

public struct OpAtomicOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicOr inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicOr(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicOr(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicOr, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicOr(OpDataIndex odi) => new(odi);
}

public struct OpAtomicXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicXor inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicXor(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicXor(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicXor, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicXor(OpDataIndex odi) => new(odi);
}

public struct OpPhi : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpPhi inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpPhi inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<PairIdRefIdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpPhi(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<PairIdRefIdRef>>();
        }
    }

    public OpPhi(int resultType, int resultId, LiteralArray<PairIdRefIdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpPhi, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPhi(OpDataIndex odi) => new(odi);
}

public struct OpLoopMerge : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int MergeBlock
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ContinueTarget
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LoopControlMask Loopcontrol
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLoopMerge(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "mergeBlock")
                MergeBlock = o.To<IdRef>();
            if (o.Name == "continueTarget")
                ContinueTarget = o.To<IdRef>();
            if (o.Name == "loopcontrol")
                Loopcontrol = o.ToEnum<LoopControlMask>();
        }
    }

    public OpLoopMerge(int mergeBlock, int continueTarget, LoopControlMask loopcontrol)
    {
        MergeBlock = mergeBlock;
        ContinueTarget = continueTarget;
        Loopcontrol = loopcontrol;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLoopMerge, ..MergeBlock.AsSpirvSpan(), ..ContinueTarget.AsSpirvSpan(), ..Loopcontrol.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLoopMerge(OpDataIndex odi) => new(odi);
}

public struct OpSelectionMerge : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int MergeBlock
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public SelectionControlMask Selectioncontrol
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSelectionMerge(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "mergeBlock")
                MergeBlock = o.To<IdRef>();
            if (o.Name == "selectioncontrol")
                Selectioncontrol = o.ToEnum<SelectionControlMask>();
        }
    }

    public OpSelectionMerge(int mergeBlock, SelectionControlMask selectioncontrol)
    {
        MergeBlock = mergeBlock;
        Selectioncontrol = selectioncontrol;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSelectionMerge, ..MergeBlock.AsSpirvSpan(), ..Selectioncontrol.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSelectionMerge(OpDataIndex odi) => new(odi);
}

public struct OpLabel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpLabel inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpLabel inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLabel(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpLabel(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLabel, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLabel(OpDataIndex odi) => new(odi);
}

public struct OpBranch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int TargetLabel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBranch(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "targetLabel")
                TargetLabel = o.To<IdRef>();
        }
    }

    public OpBranch(int targetLabel)
    {
        TargetLabel = targetLabel;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBranch, ..TargetLabel.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBranch(OpDataIndex odi) => new(odi);
}

public struct OpBranchConditional : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TrueLabel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FalseLabel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<LiteralInteger> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpBranchConditional(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "condition")
                Condition = o.To<IdRef>();
            if (o.Name == "trueLabel")
                TrueLabel = o.To<IdRef>();
            if (o.Name == "falseLabel")
                FalseLabel = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<LiteralInteger>>();
        }
    }

    public OpBranchConditional(int condition, int trueLabel, int falseLabel, LiteralArray<LiteralInteger> values)
    {
        Condition = condition;
        TrueLabel = trueLabel;
        FalseLabel = falseLabel;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBranchConditional, ..Condition.AsSpirvSpan(), ..TrueLabel.AsSpirvSpan(), ..FalseLabel.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBranchConditional(OpDataIndex odi) => new(odi);
}

public struct OpSwitch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Selector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int DefaultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<PairLiteralIntegerIdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpSwitch(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "selector")
                Selector = o.To<IdRef>();
            if (o.Name == "defaultId")
                DefaultId = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<PairLiteralIntegerIdRef>>();
        }
    }

    public OpSwitch(int selector, int defaultId, LiteralArray<PairLiteralIntegerIdRef> values)
    {
        Selector = selector;
        DefaultId = defaultId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSwitch, ..Selector.AsSpirvSpan(), ..DefaultId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSwitch(OpDataIndex odi) => new(odi);
}

public struct OpKill : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpKill(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpKill(OpDataIndex odi) => new(odi);
}

public struct OpReturn : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReturn(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpReturn(OpDataIndex odi) => new(odi);
}

public struct OpReturnValue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReturnValue(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpReturnValue(int value)
    {
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReturnValue, ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReturnValue(OpDataIndex odi) => new(odi);
}

public struct OpUnreachable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnreachable(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpUnreachable(OpDataIndex odi) => new(odi);
}

public struct OpLifetimeStart : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Size
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLifetimeStart(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "size")
                Size = o.To<LiteralInteger>();
        }
    }

    public OpLifetimeStart(int pointer, int size)
    {
        Pointer = pointer;
        Size = size;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLifetimeStart, ..Pointer.AsSpirvSpan(), ..Size.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLifetimeStart(OpDataIndex odi) => new(odi);
}

public struct OpLifetimeStop : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Size
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpLifetimeStop(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "size")
                Size = o.To<LiteralInteger>();
        }
    }

    public OpLifetimeStop(int pointer, int size)
    {
        Pointer = pointer;
        Size = size;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLifetimeStop, ..Pointer.AsSpirvSpan(), ..Size.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLifetimeStop(OpDataIndex odi) => new(odi);
}

public struct OpGroupAsyncCopy : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupAsyncCopy inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupAsyncCopy inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Destination
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Source
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumElements
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupAsyncCopy(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "destination")
                Destination = o.To<IdRef>();
            if (o.Name == "source")
                Source = o.To<IdRef>();
            if (o.Name == "numElements")
                NumElements = o.To<IdRef>();
            if (o.Name == "stride")
                Stride = o.To<IdRef>();
            if (o.Name == "eventId")
                EventId = o.To<IdRef>();
        }
    }

    public OpGroupAsyncCopy(int resultType, int resultId, int execution, int destination, int source, int numElements, int stride, int eventId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Destination = destination;
        Source = source;
        NumElements = numElements;
        Stride = stride;
        EventId = eventId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupAsyncCopy, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Destination.AsSpirvSpan(), ..Source.AsSpirvSpan(), ..NumElements.AsSpirvSpan(), ..Stride.AsSpirvSpan(), ..EventId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupAsyncCopy(OpDataIndex odi) => new(odi);
}

public struct OpGroupWaitEvents : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EventsList
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupWaitEvents(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "numEvents")
                NumEvents = o.To<IdRef>();
            if (o.Name == "eventsList")
                EventsList = o.To<IdRef>();
        }
    }

    public OpGroupWaitEvents(int execution, int numEvents, int eventsList)
    {
        Execution = execution;
        NumEvents = numEvents;
        EventsList = eventsList;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupWaitEvents, ..Execution.AsSpirvSpan(), ..NumEvents.AsSpirvSpan(), ..EventsList.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupWaitEvents(OpDataIndex odi) => new(odi);
}

public struct OpGroupAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupAll inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupAll inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupAll(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpGroupAll(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupAll, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupAll(OpDataIndex odi) => new(odi);
}

public struct OpGroupAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupAny inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupAny inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupAny(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpGroupAny(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupAny, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupAny(OpDataIndex odi) => new(odi);
}

public struct OpGroupBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupBroadcast inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupBroadcast inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LocalId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupBroadcast(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "localId")
                LocalId = o.To<IdRef>();
        }
    }

    public OpGroupBroadcast(int resultType, int resultId, int execution, int value, int localId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        LocalId = localId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupBroadcast, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..LocalId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupBroadcast(OpDataIndex odi) => new(odi);
}

public struct OpGroupIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupIAdd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupIAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupIAdd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupIAdd(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupIAdd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupIAdd(OpDataIndex odi) => new(odi);
}

public struct OpGroupFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupFAdd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupFAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupFAdd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupFAdd(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupFAdd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFAdd(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupFMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupFMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupFMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupFMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupFMin, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupUMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupUMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupUMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupUMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupUMin, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupUMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupSMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupSMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupSMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupSMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupSMin, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupSMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupFMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupFMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupFMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupFMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupFMax, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupUMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupUMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupUMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupUMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupUMax, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupUMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupSMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupSMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupSMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupSMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupSMax, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupSMax(OpDataIndex odi) => new(odi);
}

public struct OpReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpReadPipe inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpReadPipe inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReadPipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpReadPipe(int resultType, int resultId, int pipe, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReadPipe, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReadPipe(OpDataIndex odi) => new(odi);
}

public struct OpWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpWritePipe inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpWritePipe inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpWritePipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpWritePipe(int resultType, int resultId, int pipe, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpWritePipe, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpWritePipe(OpDataIndex odi) => new(odi);
}

public struct OpReservedReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpReservedReadPipe inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpReservedReadPipe inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReservedReadPipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "reserveId")
                ReserveId = o.To<IdRef>();
            if (o.Name == "index")
                Index = o.To<IdRef>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpReservedReadPipe(int resultType, int resultId, int pipe, int reserveId, int index, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        ReserveId = reserveId;
        Index = index;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReservedReadPipe, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..ReserveId.AsSpirvSpan(), ..Index.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReservedReadPipe(OpDataIndex odi) => new(odi);
}

public struct OpReservedWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpReservedWritePipe inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpReservedWritePipe inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReservedWritePipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "reserveId")
                ReserveId = o.To<IdRef>();
            if (o.Name == "index")
                Index = o.To<IdRef>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpReservedWritePipe(int resultType, int resultId, int pipe, int reserveId, int index, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        ReserveId = reserveId;
        Index = index;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReservedWritePipe, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..ReserveId.AsSpirvSpan(), ..Index.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReservedWritePipe(OpDataIndex odi) => new(odi);
}

public struct OpReserveReadPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpReserveReadPipePackets inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpReserveReadPipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReserveReadPipePackets(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "numPackets")
                NumPackets = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpReserveReadPipePackets(int resultType, int resultId, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReserveReadPipePackets, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..NumPackets.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReserveReadPipePackets(OpDataIndex odi) => new(odi);
}

public struct OpReserveWritePipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpReserveWritePipePackets inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpReserveWritePipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReserveWritePipePackets(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "numPackets")
                NumPackets = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpReserveWritePipePackets(int resultType, int resultId, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReserveWritePipePackets, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..NumPackets.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReserveWritePipePackets(OpDataIndex odi) => new(odi);
}

public struct OpCommitReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCommitReadPipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "reserveId")
                ReserveId = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpCommitReadPipe(int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCommitReadPipe, ..Pipe.AsSpirvSpan(), ..ReserveId.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCommitReadPipe(OpDataIndex odi) => new(odi);
}

public struct OpCommitWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCommitWritePipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "reserveId")
                ReserveId = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpCommitWritePipe(int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCommitWritePipe, ..Pipe.AsSpirvSpan(), ..ReserveId.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCommitWritePipe(OpDataIndex odi) => new(odi);
}

public struct OpIsValidReserveId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIsValidReserveId inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIsValidReserveId inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIsValidReserveId(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "reserveId")
                ReserveId = o.To<IdRef>();
        }
    }

    public OpIsValidReserveId(int resultType, int resultId, int reserveId)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReserveId = reserveId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIsValidReserveId, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ReserveId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsValidReserveId(OpDataIndex odi) => new(odi);
}

public struct OpGetNumPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetNumPipePackets inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetNumPipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetNumPipePackets(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpGetNumPipePackets(int resultType, int resultId, int pipe, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetNumPipePackets, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetNumPipePackets(OpDataIndex odi) => new(odi);
}

public struct OpGetMaxPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetMaxPipePackets inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetMaxPipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetMaxPipePackets(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpGetMaxPipePackets(int resultType, int resultId, int pipe, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetMaxPipePackets, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetMaxPipePackets(OpDataIndex odi) => new(odi);
}

public struct OpGroupReserveReadPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupReserveReadPipePackets inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupReserveReadPipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupReserveReadPipePackets(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "numPackets")
                NumPackets = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpGroupReserveReadPipePackets(int resultType, int resultId, int execution, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupReserveReadPipePackets, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..NumPackets.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupReserveReadPipePackets(OpDataIndex odi) => new(odi);
}

public struct OpGroupReserveWritePipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupReserveWritePipePackets inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupReserveWritePipePackets inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupReserveWritePipePackets(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "numPackets")
                NumPackets = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpGroupReserveWritePipePackets(int resultType, int resultId, int execution, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupReserveWritePipePackets, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..NumPackets.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupReserveWritePipePackets(OpDataIndex odi) => new(odi);
}

public struct OpGroupCommitReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupCommitReadPipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "reserveId")
                ReserveId = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpGroupCommitReadPipe(int execution, int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Execution = execution;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupCommitReadPipe, ..Execution.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..ReserveId.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupCommitReadPipe(OpDataIndex odi) => new(odi);
}

public struct OpGroupCommitWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupCommitWritePipe(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "pipe")
                Pipe = o.To<IdRef>();
            if (o.Name == "reserveId")
                ReserveId = o.To<IdRef>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpGroupCommitWritePipe(int execution, int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Execution = execution;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupCommitWritePipe, ..Execution.AsSpirvSpan(), ..Pipe.AsSpirvSpan(), ..ReserveId.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupCommitWritePipe(OpDataIndex odi) => new(odi);
}

public struct OpEnqueueMarker : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpEnqueueMarker inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpEnqueueMarker inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Queue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int WaitEvents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RetEvent
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpEnqueueMarker(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "queue")
                Queue = o.To<IdRef>();
            if (o.Name == "numEvents")
                NumEvents = o.To<IdRef>();
            if (o.Name == "waitEvents")
                WaitEvents = o.To<IdRef>();
            if (o.Name == "retEvent")
                RetEvent = o.To<IdRef>();
        }
    }

    public OpEnqueueMarker(int resultType, int resultId, int queue, int numEvents, int waitEvents, int retEvent)
    {
        ResultType = resultType;
        ResultId = resultId;
        Queue = queue;
        NumEvents = numEvents;
        WaitEvents = waitEvents;
        RetEvent = retEvent;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpEnqueueMarker, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Queue.AsSpirvSpan(), ..NumEvents.AsSpirvSpan(), ..WaitEvents.AsSpirvSpan(), ..RetEvent.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEnqueueMarker(OpDataIndex odi) => new(odi);
}

public struct OpEnqueueKernel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpEnqueueKernel inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpEnqueueKernel inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Queue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Flags
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int WaitEvents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RetEvent
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpEnqueueKernel(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "queue")
                Queue = o.To<IdRef>();
            if (o.Name == "flags")
                Flags = o.To<IdRef>();
            if (o.Name == "nDRange")
                NDRange = o.To<IdRef>();
            if (o.Name == "numEvents")
                NumEvents = o.To<IdRef>();
            if (o.Name == "waitEvents")
                WaitEvents = o.To<IdRef>();
            if (o.Name == "retEvent")
                RetEvent = o.To<IdRef>();
            if (o.Name == "invoke")
                Invoke = o.To<IdRef>();
            if (o.Name == "param")
                Param = o.To<IdRef>();
            if (o.Name == "paramSize")
                ParamSize = o.To<IdRef>();
            if (o.Name == "paramAlign")
                ParamAlign = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpEnqueueKernel(int resultType, int resultId, int queue, int flags, int nDRange, int numEvents, int waitEvents, int retEvent, int invoke, int param, int paramSize, int paramAlign, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Queue = queue;
        Flags = flags;
        NDRange = nDRange;
        NumEvents = numEvents;
        WaitEvents = waitEvents;
        RetEvent = retEvent;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpEnqueueKernel, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Queue.AsSpirvSpan(), ..Flags.AsSpirvSpan(), ..NDRange.AsSpirvSpan(), ..NumEvents.AsSpirvSpan(), ..WaitEvents.AsSpirvSpan(), ..RetEvent.AsSpirvSpan(), ..Invoke.AsSpirvSpan(), ..Param.AsSpirvSpan(), ..ParamSize.AsSpirvSpan(), ..ParamAlign.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEnqueueKernel(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelNDrangeSubGroupCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetKernelNDrangeSubGroupCount inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetKernelNDrangeSubGroupCount inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetKernelNDrangeSubGroupCount(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "nDRange")
                NDRange = o.To<IdRef>();
            if (o.Name == "invoke")
                Invoke = o.To<IdRef>();
            if (o.Name == "param")
                Param = o.To<IdRef>();
            if (o.Name == "paramSize")
                ParamSize = o.To<IdRef>();
            if (o.Name == "paramAlign")
                ParamAlign = o.To<IdRef>();
        }
    }

    public OpGetKernelNDrangeSubGroupCount(int resultType, int resultId, int nDRange, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        NDRange = nDRange;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetKernelNDrangeSubGroupCount, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..NDRange.AsSpirvSpan(), ..Invoke.AsSpirvSpan(), ..Param.AsSpirvSpan(), ..ParamSize.AsSpirvSpan(), ..ParamAlign.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelNDrangeSubGroupCount(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelNDrangeMaxSubGroupSize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetKernelNDrangeMaxSubGroupSize inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetKernelNDrangeMaxSubGroupSize inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetKernelNDrangeMaxSubGroupSize(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "nDRange")
                NDRange = o.To<IdRef>();
            if (o.Name == "invoke")
                Invoke = o.To<IdRef>();
            if (o.Name == "param")
                Param = o.To<IdRef>();
            if (o.Name == "paramSize")
                ParamSize = o.To<IdRef>();
            if (o.Name == "paramAlign")
                ParamAlign = o.To<IdRef>();
        }
    }

    public OpGetKernelNDrangeMaxSubGroupSize(int resultType, int resultId, int nDRange, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        NDRange = nDRange;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetKernelNDrangeMaxSubGroupSize, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..NDRange.AsSpirvSpan(), ..Invoke.AsSpirvSpan(), ..Param.AsSpirvSpan(), ..ParamSize.AsSpirvSpan(), ..ParamAlign.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelNDrangeMaxSubGroupSize(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelWorkGroupSize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetKernelWorkGroupSize inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetKernelWorkGroupSize inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetKernelWorkGroupSize(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "invoke")
                Invoke = o.To<IdRef>();
            if (o.Name == "param")
                Param = o.To<IdRef>();
            if (o.Name == "paramSize")
                ParamSize = o.To<IdRef>();
            if (o.Name == "paramAlign")
                ParamAlign = o.To<IdRef>();
        }
    }

    public OpGetKernelWorkGroupSize(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetKernelWorkGroupSize, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Invoke.AsSpirvSpan(), ..Param.AsSpirvSpan(), ..ParamSize.AsSpirvSpan(), ..ParamAlign.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelWorkGroupSize(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelPreferredWorkGroupSizeMultiple : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetKernelPreferredWorkGroupSizeMultiple inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetKernelPreferredWorkGroupSizeMultiple inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "invoke")
                Invoke = o.To<IdRef>();
            if (o.Name == "param")
                Param = o.To<IdRef>();
            if (o.Name == "paramSize")
                ParamSize = o.To<IdRef>();
            if (o.Name == "paramAlign")
                ParamAlign = o.To<IdRef>();
        }
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetKernelPreferredWorkGroupSizeMultiple, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Invoke.AsSpirvSpan(), ..Param.AsSpirvSpan(), ..ParamSize.AsSpirvSpan(), ..ParamAlign.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelPreferredWorkGroupSizeMultiple(OpDataIndex odi) => new(odi);
}

public struct OpRetainEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRetainEvent(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "eventId")
                EventId = o.To<IdRef>();
        }
    }

    public OpRetainEvent(int eventId)
    {
        EventId = eventId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRetainEvent, ..EventId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRetainEvent(OpDataIndex odi) => new(odi);
}

public struct OpReleaseEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReleaseEvent(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "eventId")
                EventId = o.To<IdRef>();
        }
    }

    public OpReleaseEvent(int eventId)
    {
        EventId = eventId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReleaseEvent, ..EventId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReleaseEvent(OpDataIndex odi) => new(odi);
}

public struct OpCreateUserEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCreateUserEvent inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCreateUserEvent inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCreateUserEvent(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpCreateUserEvent(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCreateUserEvent, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCreateUserEvent(OpDataIndex odi) => new(odi);
}

public struct OpIsValidEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIsValidEvent inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIsValidEvent inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIsValidEvent(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "eventId")
                EventId = o.To<IdRef>();
        }
    }

    public OpIsValidEvent(int resultType, int resultId, int eventId)
    {
        ResultType = resultType;
        ResultId = resultId;
        EventId = eventId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIsValidEvent, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..EventId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsValidEvent(OpDataIndex odi) => new(odi);
}

public struct OpSetUserEventStatus : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Status
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSetUserEventStatus(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "eventId")
                EventId = o.To<IdRef>();
            if (o.Name == "status")
                Status = o.To<IdRef>();
        }
    }

    public OpSetUserEventStatus(int eventId, int status)
    {
        EventId = eventId;
        Status = status;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSetUserEventStatus, ..EventId.AsSpirvSpan(), ..Status.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSetUserEventStatus(OpDataIndex odi) => new(odi);
}

public struct OpCaptureEventProfilingInfo : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ProfilingInfo
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCaptureEventProfilingInfo(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "eventId")
                EventId = o.To<IdRef>();
            if (o.Name == "profilingInfo")
                ProfilingInfo = o.To<IdRef>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpCaptureEventProfilingInfo(int eventId, int profilingInfo, int value)
    {
        EventId = eventId;
        ProfilingInfo = profilingInfo;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCaptureEventProfilingInfo, ..EventId.AsSpirvSpan(), ..ProfilingInfo.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCaptureEventProfilingInfo(OpDataIndex odi) => new(odi);
}

public struct OpGetDefaultQueue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetDefaultQueue inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetDefaultQueue inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetDefaultQueue(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpGetDefaultQueue(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetDefaultQueue, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetDefaultQueue(OpDataIndex odi) => new(odi);
}

public struct OpBuildNDRange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpBuildNDRange inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpBuildNDRange inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GlobalWorkSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LocalWorkSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GlobalWorkOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpBuildNDRange(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "globalWorkSize")
                GlobalWorkSize = o.To<IdRef>();
            if (o.Name == "localWorkSize")
                LocalWorkSize = o.To<IdRef>();
            if (o.Name == "globalWorkOffset")
                GlobalWorkOffset = o.To<IdRef>();
        }
    }

    public OpBuildNDRange(int resultType, int resultId, int globalWorkSize, int localWorkSize, int globalWorkOffset)
    {
        ResultType = resultType;
        ResultId = resultId;
        GlobalWorkSize = globalWorkSize;
        LocalWorkSize = localWorkSize;
        GlobalWorkOffset = globalWorkOffset;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpBuildNDRange, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..GlobalWorkSize.AsSpirvSpan(), ..LocalWorkSize.AsSpirvSpan(), ..GlobalWorkOffset.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpBuildNDRange(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseSampleImplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleImplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseSampleImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseSampleImplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseSampleExplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleExplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseSampleExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseSampleExplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseSampleDrefImplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleDrefImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleDrefImplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseSampleDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseSampleDrefImplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleDrefImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseSampleDrefExplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleDrefExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleDrefExplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseSampleDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseSampleDrefExplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleDrefExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleProjImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseSampleProjImplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleProjImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleProjImplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseSampleProjImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseSampleProjImplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleProjImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleProjExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseSampleProjExplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleProjExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleProjExplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseSampleProjExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseSampleProjExplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleProjExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleProjDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseSampleProjDrefImplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleProjDrefImplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleProjDrefImplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseSampleProjDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseSampleProjDrefImplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleProjDrefImplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseSampleProjDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseSampleProjDrefExplicitLod inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseSampleProjDrefExplicitLod inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseSampleProjDrefExplicitLod(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseSampleProjDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseSampleProjDrefExplicitLod, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseSampleProjDrefExplicitLod(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseFetch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseFetch inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseFetch inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseFetch(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseFetch(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseFetch, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseFetch(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseGather inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseGather inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseGather(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "component")
                Component = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseGather(int resultType, int resultId, int sampledImage, int coordinate, int component, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Component = component;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseGather, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Component.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseGather(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseDrefGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseDrefGather inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseDrefGather inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseDrefGather(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "dref")
                Dref = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseDrefGather(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseDrefGather, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Dref.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseDrefGather(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseTexelsResident : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseTexelsResident inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseTexelsResident inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResidentCode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseTexelsResident(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "residentCode")
                ResidentCode = o.To<IdRef>();
        }
    }

    public OpImageSparseTexelsResident(int resultType, int resultId, int residentCode)
    {
        ResultType = resultType;
        ResultId = resultId;
        ResidentCode = residentCode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseTexelsResident, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ResidentCode.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseTexelsResident(OpDataIndex odi) => new(odi);
}

public struct OpNoLine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNoLine(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpNoLine(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFlagTestAndSet : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicFlagTestAndSet inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicFlagTestAndSet inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicFlagTestAndSet(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpAtomicFlagTestAndSet(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicFlagTestAndSet, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFlagTestAndSet(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFlagClear : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicFlagClear(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpAtomicFlagClear(int pointer, int memory, int semantics)
    {
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicFlagClear, ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFlagClear(OpDataIndex odi) => new(odi);
}

public struct OpImageSparseRead : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSparseRead inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSparseRead inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSparseRead(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSparseRead(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSparseRead, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSparseRead(OpDataIndex odi) => new(odi);
}

public struct OpSizeOf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSizeOf inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSizeOf inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSizeOf(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
        }
    }

    public OpSizeOf(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSizeOf, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSizeOf(OpDataIndex odi) => new(odi);
}

public struct OpTypePipeStorage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypePipeStorage inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypePipeStorage inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypePipeStorage(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypePipeStorage(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypePipeStorage, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypePipeStorage(OpDataIndex odi) => new(odi);
}

public struct OpCreatePipeFromPipeStorage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCreatePipeFromPipeStorage inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCreatePipeFromPipeStorage inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PipeStorage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCreatePipeFromPipeStorage(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pipeStorage")
                PipeStorage = o.To<IdRef>();
        }
    }

    public OpCreatePipeFromPipeStorage(int resultType, int resultId, int pipeStorage)
    {
        ResultType = resultType;
        ResultId = resultId;
        PipeStorage = pipeStorage;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCreatePipeFromPipeStorage, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PipeStorage.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCreatePipeFromPipeStorage(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelLocalSizeForSubgroupCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetKernelLocalSizeForSubgroupCount inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetKernelLocalSizeForSubgroupCount inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SubgroupCount
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetKernelLocalSizeForSubgroupCount(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "subgroupCount")
                SubgroupCount = o.To<IdRef>();
            if (o.Name == "invoke")
                Invoke = o.To<IdRef>();
            if (o.Name == "param")
                Param = o.To<IdRef>();
            if (o.Name == "paramSize")
                ParamSize = o.To<IdRef>();
            if (o.Name == "paramAlign")
                ParamAlign = o.To<IdRef>();
        }
    }

    public OpGetKernelLocalSizeForSubgroupCount(int resultType, int resultId, int subgroupCount, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        SubgroupCount = subgroupCount;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetKernelLocalSizeForSubgroupCount, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SubgroupCount.AsSpirvSpan(), ..Invoke.AsSpirvSpan(), ..Param.AsSpirvSpan(), ..ParamSize.AsSpirvSpan(), ..ParamAlign.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelLocalSizeForSubgroupCount(OpDataIndex odi) => new(odi);
}

public struct OpGetKernelMaxNumSubgroups : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGetKernelMaxNumSubgroups inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGetKernelMaxNumSubgroups inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGetKernelMaxNumSubgroups(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "invoke")
                Invoke = o.To<IdRef>();
            if (o.Name == "param")
                Param = o.To<IdRef>();
            if (o.Name == "paramSize")
                ParamSize = o.To<IdRef>();
            if (o.Name == "paramAlign")
                ParamAlign = o.To<IdRef>();
        }
    }

    public OpGetKernelMaxNumSubgroups(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGetKernelMaxNumSubgroups, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Invoke.AsSpirvSpan(), ..Param.AsSpirvSpan(), ..ParamSize.AsSpirvSpan(), ..ParamAlign.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGetKernelMaxNumSubgroups(OpDataIndex odi) => new(odi);
}

public struct OpTypeNamedBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeNamedBarrier inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeNamedBarrier inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeNamedBarrier(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeNamedBarrier(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeNamedBarrier, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeNamedBarrier(OpDataIndex odi) => new(odi);
}

public struct OpNamedBarrierInitialize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpNamedBarrierInitialize inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpNamedBarrierInitialize inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SubgroupCount
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpNamedBarrierInitialize(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "subgroupCount")
                SubgroupCount = o.To<IdRef>();
        }
    }

    public OpNamedBarrierInitialize(int resultType, int resultId, int subgroupCount)
    {
        ResultType = resultType;
        ResultId = resultId;
        SubgroupCount = subgroupCount;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpNamedBarrierInitialize, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SubgroupCount.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpNamedBarrierInitialize(OpDataIndex odi) => new(odi);
}

public struct OpMemoryNamedBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int NamedBarrier
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMemoryNamedBarrier(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "namedBarrier")
                NamedBarrier = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpMemoryNamedBarrier(int namedBarrier, int memory, int semantics)
    {
        NamedBarrier = namedBarrier;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMemoryNamedBarrier, ..NamedBarrier.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemoryNamedBarrier(OpDataIndex odi) => new(odi);
}

public struct OpModuleProcessed : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public LiteralString Process
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpModuleProcessed(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "process")
                Process = o.To<LiteralString>();
        }
    }

    public OpModuleProcessed(LiteralString process)
    {
        Process = process;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpModuleProcessed, ..Process.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpModuleProcessed(OpDataIndex odi) => new(odi);
}

public struct OpExecutionModeId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ExecutionMode Mode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpExecutionModeId(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "entryPoint")
                EntryPoint = o.To<IdRef>();
            if (o.Name == "mode")
                Mode = o.ToEnum<ExecutionMode>();
        }
    }

    public OpExecutionModeId(int entryPoint, ExecutionMode mode)
    {
        EntryPoint = entryPoint;
        Mode = mode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExecutionModeId, ..EntryPoint.AsSpirvSpan(), ..Mode.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExecutionModeId(OpDataIndex odi) => new(odi);
}

public struct OpDecorateId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDecorateId(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "target")
                Target = o.To<IdRef>();
            if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
        }
    }

    public OpDecorateId(int target, Decoration decoration)
    {
        Target = target;
        Decoration = decoration;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDecorateId, ..Target.AsSpirvSpan(), ..Decoration.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDecorateId(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformElect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformElect inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformElect inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformElect(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
        }
    }

    public OpGroupNonUniformElect(int resultType, int resultId, int execution)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformElect, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformElect(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformAll inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformAll inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformAll(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformAll(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformAll, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformAll(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformAny inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformAny inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformAny(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformAny(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformAny, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformAny(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformAllEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformAllEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformAllEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformAllEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformAllEqual(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformAllEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformAllEqual(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBroadcast inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBroadcast inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Id
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBroadcast(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "id")
                Id = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBroadcast(int resultType, int resultId, int execution, int value, int id)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Id = id;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBroadcast, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Id.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBroadcast(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBroadcastFirst : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBroadcastFirst inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBroadcastFirst inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBroadcastFirst(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBroadcastFirst(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBroadcastFirst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBroadcastFirst(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBallot inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallot(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBallot(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBallot, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallot(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformInverseBallot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformInverseBallot inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformInverseBallot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformInverseBallot(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformInverseBallot(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformInverseBallot, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformInverseBallot(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallotBitExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBallotBitExtract inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallotBitExtract inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallotBitExtract(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "index")
                Index = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBallotBitExtract(int resultType, int resultId, int execution, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBallotBitExtract, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Index.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallotBitExtract(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallotBitCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBallotBitCount inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallotBitCount inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallotBitCount(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBallotBitCount(int resultType, int resultId, int execution, GroupOperation operation, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBallotBitCount, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallotBitCount(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallotFindLSB : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBallotFindLSB inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallotFindLSB inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallotFindLSB(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBallotFindLSB(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBallotFindLSB, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallotFindLSB(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBallotFindMSB : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBallotFindMSB inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBallotFindMSB inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBallotFindMSB(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBallotFindMSB(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBallotFindMSB, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBallotFindMSB(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformShuffle : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformShuffle inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformShuffle inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Id
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformShuffle(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "id")
                Id = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformShuffle(int resultType, int resultId, int execution, int value, int id)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Id = id;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformShuffle, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Id.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformShuffle(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformShuffleXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformShuffleXor inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformShuffleXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformShuffleXor(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "mask")
                Mask = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformShuffleXor(int resultType, int resultId, int execution, int value, int mask)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Mask = mask;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformShuffleXor, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Mask.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformShuffleXor(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformShuffleUp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformShuffleUp inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformShuffleUp inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformShuffleUp(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "delta")
                Delta = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformShuffleUp(int resultType, int resultId, int execution, int value, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformShuffleUp, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Delta.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformShuffleUp(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformShuffleDown : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformShuffleDown inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformShuffleDown inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformShuffleDown(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "delta")
                Delta = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformShuffleDown(int resultType, int resultId, int execution, int value, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformShuffleDown, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Delta.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformShuffleDown(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformIAdd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformIAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformIAdd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformIAdd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformIAdd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformIAdd(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformFAdd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformFAdd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformFAdd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformFAdd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformFAdd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformFAdd(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformIMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformIMul inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformIMul inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformIMul(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformIMul(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformIMul, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformIMul(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformFMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformFMul inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformFMul inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformFMul(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformFMul(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformFMul, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformFMul(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformSMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformSMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformSMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformSMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformSMin, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformSMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformUMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformUMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformUMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformUMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformUMin, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformUMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformFMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformFMin inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformFMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformFMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformFMin, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformFMin(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformSMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformSMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformSMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformSMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformSMax, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformSMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformUMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformUMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformUMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformUMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformUMax, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformUMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformFMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformFMax inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformFMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformFMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformFMax, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformFMax(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBitwiseAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBitwiseAnd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBitwiseAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBitwiseAnd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBitwiseAnd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBitwiseAnd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseAnd(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBitwiseOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBitwiseOr inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBitwiseOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBitwiseOr(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBitwiseOr(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBitwiseOr, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseOr(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformBitwiseXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformBitwiseXor inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformBitwiseXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformBitwiseXor(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformBitwiseXor(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformBitwiseXor, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseXor(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformLogicalAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformLogicalAnd inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformLogicalAnd inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformLogicalAnd(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformLogicalAnd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformLogicalAnd, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformLogicalAnd(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformLogicalOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformLogicalOr inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformLogicalOr inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformLogicalOr(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformLogicalOr(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformLogicalOr, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformLogicalOr(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformLogicalXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformLogicalXor inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformLogicalXor inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformLogicalXor(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformLogicalXor(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformLogicalXor, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformLogicalXor(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformQuadBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformQuadBroadcast inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformQuadBroadcast inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformQuadBroadcast(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "index")
                Index = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformQuadBroadcast(int resultType, int resultId, int execution, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformQuadBroadcast, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Index.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformQuadBroadcast(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformQuadSwap : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformQuadSwap inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformQuadSwap inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformQuadSwap(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformQuadSwap(int resultType, int resultId, int execution, int value, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformQuadSwap, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Direction.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformQuadSwap(OpDataIndex odi) => new(odi);
}

public struct OpCopyLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCopyLogical inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCopyLogical inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCopyLogical(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpCopyLogical(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCopyLogical, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCopyLogical(OpDataIndex odi) => new(odi);
}

public struct OpPtrEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpPtrEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpPtrEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpPtrEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpPtrEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpPtrEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrEqual(OpDataIndex odi) => new(odi);
}

public struct OpPtrNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpPtrNotEqual inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpPtrNotEqual inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpPtrNotEqual(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpPtrNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpPtrNotEqual, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrNotEqual(OpDataIndex odi) => new(odi);
}

public struct OpPtrDiff : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpPtrDiff inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpPtrDiff inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpPtrDiff(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpPtrDiff(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpPtrDiff, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrDiff(OpDataIndex odi) => new(odi);
}

public struct OpColorAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpColorAttachmentReadEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpColorAttachmentReadEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Attachment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpColorAttachmentReadEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "attachment")
                Attachment = o.To<IdRef>();
            if (o.Name == "sample")
                Sample = o.To<IdRef>();
        }
    }

    public OpColorAttachmentReadEXT(int resultType, int resultId, int attachment, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Attachment = attachment;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpColorAttachmentReadEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Attachment.AsSpirvSpan(), ..Sample.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpColorAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public struct OpDepthAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpDepthAttachmentReadEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpDepthAttachmentReadEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDepthAttachmentReadEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sample")
                Sample = o.To<IdRef>();
        }
    }

    public OpDepthAttachmentReadEXT(int resultType, int resultId, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDepthAttachmentReadEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Sample.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDepthAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public struct OpStencilAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpStencilAttachmentReadEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpStencilAttachmentReadEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpStencilAttachmentReadEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sample")
                Sample = o.To<IdRef>();
        }
    }

    public OpStencilAttachmentReadEXT(int resultType, int resultId, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpStencilAttachmentReadEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Sample.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpStencilAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public struct OpTerminateInvocation : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateInvocation(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpTerminateInvocation(OpDataIndex odi) => new(odi);
}

public struct OpTypeUntypedPointerKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeUntypedPointerKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeUntypedPointerKHR inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeUntypedPointerKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
        }
    }

    public OpTypeUntypedPointerKHR(int resultId, StorageClass storageclass)
    {
        ResultId = resultId;
        Storageclass = storageclass;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeUntypedPointerKHR, ..ResultId.AsSpirvSpan(), ..Storageclass.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeUntypedPointerKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedVariableKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUntypedVariableKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUntypedVariableKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? DataType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Initializer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUntypedVariableKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "storageclass")
                Storageclass = o.ToEnum<StorageClass>();
            if (o.Name == "dataType")
                DataType = o.To<IdRef>();
            if (o.Name == "initializer")
                Initializer = o.To<IdRef>();
        }
    }

    public OpUntypedVariableKHR(int resultType, int resultId, StorageClass storageclass, int? dataType, int? initializer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        DataType = dataType;
        Initializer = initializer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUntypedVariableKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Storageclass.AsSpirvSpan(), ..DataType.AsSpirvSpan(), ..Initializer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedVariableKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUntypedAccessChainKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUntypedAccessChainKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpUntypedAccessChainKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseType")
                BaseType = o.To<IdRef>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpUntypedAccessChainKHR(int resultType, int resultId, int baseType, int baseId, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUntypedAccessChainKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseType.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedAccessChainKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedInBoundsAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUntypedInBoundsAccessChainKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUntypedInBoundsAccessChainKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpUntypedInBoundsAccessChainKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseType")
                BaseType = o.To<IdRef>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpUntypedInBoundsAccessChainKHR(int resultType, int resultId, int baseType, int baseId, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUntypedInBoundsAccessChainKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseType.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedInBoundsAccessChainKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupBallotKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupBallotKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupBallotKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupBallotKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpSubgroupBallotKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupBallotKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupBallotKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupFirstInvocationKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupFirstInvocationKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupFirstInvocationKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupFirstInvocationKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpSubgroupFirstInvocationKHR(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupFirstInvocationKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupFirstInvocationKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedPtrAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUntypedPtrAccessChainKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUntypedPtrAccessChainKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpUntypedPtrAccessChainKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseType")
                BaseType = o.To<IdRef>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "element")
                Element = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpUntypedPtrAccessChainKHR(int resultType, int resultId, int baseType, int baseId, int element, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Element = element;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUntypedPtrAccessChainKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseType.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Element.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedPtrAccessChainKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedInBoundsPtrAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUntypedInBoundsPtrAccessChainKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUntypedInBoundsPtrAccessChainKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpUntypedInBoundsPtrAccessChainKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseType")
                BaseType = o.To<IdRef>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "element")
                Element = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpUntypedInBoundsPtrAccessChainKHR(int resultType, int resultId, int baseType, int baseId, int element, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Element = element;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUntypedInBoundsPtrAccessChainKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseType.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Element.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedInBoundsPtrAccessChainKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedArrayLengthKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUntypedArrayLengthKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUntypedArrayLengthKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Structure
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Arraymember
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUntypedArrayLengthKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "structure")
                Structure = o.To<IdRef>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "arraymember")
                Arraymember = o.To<LiteralInteger>();
        }
    }

    public OpUntypedArrayLengthKHR(int resultType, int resultId, int structure, int pointer, int arraymember)
    {
        ResultType = resultType;
        ResultId = resultId;
        Structure = structure;
        Pointer = pointer;
        Arraymember = arraymember;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUntypedArrayLengthKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Structure.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Arraymember.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedArrayLengthKHR(OpDataIndex odi) => new(odi);
}

public struct OpUntypedPrefetchKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int PointerType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumBytes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? RW
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Locality
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? CacheType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUntypedPrefetchKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointerType")
                PointerType = o.To<IdRef>();
            if (o.Name == "numBytes")
                NumBytes = o.To<IdRef>();
            if (o.Name == "rW")
                RW = o.To<IdRef>();
            if (o.Name == "locality")
                Locality = o.To<IdRef>();
            if (o.Name == "cacheType")
                CacheType = o.To<IdRef>();
        }
    }

    public OpUntypedPrefetchKHR(int pointerType, int numBytes, int? rW, int? locality, int? cacheType)
    {
        PointerType = pointerType;
        NumBytes = numBytes;
        RW = rW;
        Locality = locality;
        CacheType = cacheType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUntypedPrefetchKHR, ..PointerType.AsSpirvSpan(), ..NumBytes.AsSpirvSpan(), ..RW.AsSpirvSpan(), ..Locality.AsSpirvSpan(), ..CacheType.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUntypedPrefetchKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAllKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAllKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAllKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAllKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpSubgroupAllKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAllKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAllKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAnyKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAnyKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAnyKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAnyKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpSubgroupAnyKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAnyKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAnyKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAllEqualKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAllEqualKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAllEqualKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAllEqualKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpSubgroupAllEqualKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAllEqualKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAllEqualKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformRotateKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformRotateKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformRotateKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformRotateKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "delta")
                Delta = o.To<IdRef>();
            if (o.Name == "clusterSize")
                ClusterSize = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformRotateKHR(int resultType, int resultId, int execution, int value, int delta, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformRotateKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Delta.AsSpirvSpan(), ..ClusterSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformRotateKHR(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupReadInvocationKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupReadInvocationKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupReadInvocationKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupReadInvocationKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "index")
                Index = o.To<IdRef>();
        }
    }

    public OpSubgroupReadInvocationKHR(int resultType, int resultId, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupReadInvocationKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..Index.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupReadInvocationKHR(OpDataIndex odi) => new(odi);
}

public struct OpExtInstWithForwardRefsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpExtInstWithForwardRefsKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpExtInstWithForwardRefsKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Instruction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpExtInstWithForwardRefsKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "instruction")
                Instruction = o.To<LiteralExtInstInteger>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpExtInstWithForwardRefsKHR(int resultType, int resultId, int set, int instruction, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Instruction = instruction;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInstWithForwardRefsKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExtInstWithForwardRefsKHR(OpDataIndex odi) => new(odi);
}

public struct OpTraceRayKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTraceRayKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "accel")
                Accel = o.To<IdRef>();
            if (o.Name == "rayFlags")
                RayFlags = o.To<IdRef>();
            if (o.Name == "cullMask")
                CullMask = o.To<IdRef>();
            if (o.Name == "sBTOffset")
                SBTOffset = o.To<IdRef>();
            if (o.Name == "sBTStride")
                SBTStride = o.To<IdRef>();
            if (o.Name == "missIndex")
                MissIndex = o.To<IdRef>();
            if (o.Name == "rayOrigin")
                RayOrigin = o.To<IdRef>();
            if (o.Name == "rayTmin")
                RayTmin = o.To<IdRef>();
            if (o.Name == "rayDirection")
                RayDirection = o.To<IdRef>();
            if (o.Name == "rayTmax")
                RayTmax = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpTraceRayKHR(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int payload)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTraceRayKHR, ..Accel.AsSpirvSpan(), ..RayFlags.AsSpirvSpan(), ..CullMask.AsSpirvSpan(), ..SBTOffset.AsSpirvSpan(), ..SBTStride.AsSpirvSpan(), ..MissIndex.AsSpirvSpan(), ..RayOrigin.AsSpirvSpan(), ..RayTmin.AsSpirvSpan(), ..RayDirection.AsSpirvSpan(), ..RayTmax.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTraceRayKHR(OpDataIndex odi) => new(odi);
}

public struct OpExecuteCallableKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CallableData
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpExecuteCallableKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "sBTIndex")
                SBTIndex = o.To<IdRef>();
            if (o.Name == "callableData")
                CallableData = o.To<IdRef>();
        }
    }

    public OpExecuteCallableKHR(int sBTIndex, int callableData)
    {
        SBTIndex = sBTIndex;
        CallableData = callableData;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExecuteCallableKHR, ..SBTIndex.AsSpirvSpan(), ..CallableData.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExecuteCallableKHR(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToAccelerationStructureKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertUToAccelerationStructureKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertUToAccelerationStructureKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertUToAccelerationStructureKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "accel")
                Accel = o.To<IdRef>();
        }
    }

    public OpConvertUToAccelerationStructureKHR(int resultType, int resultId, int accel)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertUToAccelerationStructureKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Accel.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToAccelerationStructureKHR(OpDataIndex odi) => new(odi);
}

public struct OpIgnoreIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIgnoreIntersectionKHR(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpIgnoreIntersectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpTerminateRayKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateRayKHR(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpTerminateRayKHR(OpDataIndex odi) => new(odi);
}

public struct OpSDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSDot inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSDot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDot(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
            if (o.Name == "packedVectorFormat")
                PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }
    }

    public OpSDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDot, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan(), ..PackedVectorFormat.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDot(OpDataIndex odi) => new(odi);
}

public struct OpUDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUDot inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUDot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUDot(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
            if (o.Name == "packedVectorFormat")
                PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }
    }

    public OpUDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUDot, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan(), ..PackedVectorFormat.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUDot(OpDataIndex odi) => new(odi);
}

public struct OpSUDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSUDot inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSUDot inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSUDot(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
            if (o.Name == "packedVectorFormat")
                PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }
    }

    public OpSUDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSUDot, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan(), ..PackedVectorFormat.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSUDot(OpDataIndex odi) => new(odi);
}

public struct OpSDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSDotAccSat inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSDotAccSat inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSDotAccSat(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
            if (o.Name == "accumulator")
                Accumulator = o.To<IdRef>();
            if (o.Name == "packedVectorFormat")
                PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }
    }

    public OpSDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSDotAccSat, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan(), ..Accumulator.AsSpirvSpan(), ..PackedVectorFormat.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSDotAccSat(OpDataIndex odi) => new(odi);
}

public struct OpUDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUDotAccSat inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUDotAccSat inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUDotAccSat(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
            if (o.Name == "accumulator")
                Accumulator = o.To<IdRef>();
            if (o.Name == "packedVectorFormat")
                PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }
    }

    public OpUDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUDotAccSat, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan(), ..Accumulator.AsSpirvSpan(), ..PackedVectorFormat.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUDotAccSat(OpDataIndex odi) => new(odi);
}

public struct OpSUDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSUDotAccSat inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSUDotAccSat inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSUDotAccSat(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "vector1")
                Vector1 = o.To<IdRef>();
            if (o.Name == "vector2")
                Vector2 = o.To<IdRef>();
            if (o.Name == "accumulator")
                Accumulator = o.To<IdRef>();
            if (o.Name == "packedVectorFormat")
                PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
        }
    }

    public OpSUDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSUDotAccSat, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Vector1.AsSpirvSpan(), ..Vector2.AsSpirvSpan(), ..Accumulator.AsSpirvSpan(), ..PackedVectorFormat.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSUDotAccSat(OpDataIndex odi) => new(odi);
}

public struct OpTypeCooperativeMatrixKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeCooperativeMatrixKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeCooperativeMatrixKHR inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Scope
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Rows
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Columns
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Use
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeCooperativeMatrixKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "componentType")
                ComponentType = o.To<IdRef>();
            if (o.Name == "scope")
                Scope = o.To<IdScope>();
            if (o.Name == "rows")
                Rows = o.To<IdRef>();
            if (o.Name == "columns")
                Columns = o.To<IdRef>();
            if (o.Name == "use")
                Use = o.To<IdRef>();
        }
    }

    public OpTypeCooperativeMatrixKHR(int resultId, int componentType, int scope, int rows, int columns, int use)
    {
        ResultId = resultId;
        ComponentType = componentType;
        Scope = scope;
        Rows = rows;
        Columns = columns;
        Use = use;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeCooperativeMatrixKHR, ..ResultId.AsSpirvSpan(), ..ComponentType.AsSpirvSpan(), ..Scope.AsSpirvSpan(), ..Rows.AsSpirvSpan(), ..Columns.AsSpirvSpan(), ..Use.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeCooperativeMatrixKHR(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLoadKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixLoadKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLoadKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MemoryLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Stride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? MemoryOperand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLoadKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memoryLayout")
                MemoryLayout = o.To<IdRef>();
            if (o.Name == "stride")
                Stride = o.To<IdRef>();
            if (o.Name == "memoryOperand")
                MemoryOperand = o.ToEnum<MemoryAccessMask>();
        }
    }

    public OpCooperativeMatrixLoadKHR(int resultType, int resultId, int pointer, int memoryLayout, int? stride, MemoryAccessMask? memoryOperand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        MemoryLayout = memoryLayout;
        Stride = stride;
        MemoryOperand = memoryOperand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixLoadKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..MemoryLayout.AsSpirvSpan(), ..Stride.AsSpirvSpan(), ..MemoryOperand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLoadKHR(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixStoreKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MemoryLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Stride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? MemoryOperand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "objectId")
                ObjectId = o.To<IdRef>();
            if (o.Name == "memoryLayout")
                MemoryLayout = o.To<IdRef>();
            if (o.Name == "stride")
                Stride = o.To<IdRef>();
            if (o.Name == "memoryOperand")
                MemoryOperand = o.ToEnum<MemoryAccessMask>();
        }
    }

    public OpCooperativeMatrixStoreKHR(int pointer, int objectId, int memoryLayout, int? stride, MemoryAccessMask? memoryOperand)
    {
        Pointer = pointer;
        ObjectId = objectId;
        MemoryLayout = memoryLayout;
        Stride = stride;
        MemoryOperand = memoryOperand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixStoreKHR, ..Pointer.AsSpirvSpan(), ..ObjectId.AsSpirvSpan(), ..MemoryLayout.AsSpirvSpan(), ..Stride.AsSpirvSpan(), ..MemoryOperand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixStoreKHR(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixMulAddKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixMulAddKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixMulAddKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public CooperativeMatrixOperandsMask? CooperativeMatrixOperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixMulAddKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "c")
                C = o.To<IdRef>();
            if (o.Name == "cooperativeMatrixOperands")
                CooperativeMatrixOperands = o.ToEnum<CooperativeMatrixOperandsMask>();
        }
    }

    public OpCooperativeMatrixMulAddKHR(int resultType, int resultId, int a, int b, int c, CooperativeMatrixOperandsMask? cooperativeMatrixOperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        B = b;
        C = c;
        CooperativeMatrixOperands = cooperativeMatrixOperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixMulAddKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..B.AsSpirvSpan(), ..C.AsSpirvSpan(), ..CooperativeMatrixOperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixMulAddKHR(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLengthKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixLengthKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLengthKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLengthKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "type")
                Type = o.To<IdRef>();
        }
    }

    public OpCooperativeMatrixLengthKHR(int resultType, int resultId, int type)
    {
        ResultType = resultType;
        ResultId = resultId;
        Type = type;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixLengthKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Type.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLengthKHR(OpDataIndex odi) => new(odi);
}

public struct OpCompositeConstructReplicateEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCompositeConstructReplicateEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCompositeConstructReplicateEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCompositeConstructReplicateEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpCompositeConstructReplicateEXT(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCompositeConstructReplicateEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeConstructReplicateEXT(OpDataIndex odi) => new(odi);
}

public struct OpTypeRayQueryKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeRayQueryKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeRayQueryKHR inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeRayQueryKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeRayQueryKHR(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeRayQueryKHR, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeRayQueryKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryInitializeKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryInitializeKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "accel")
                Accel = o.To<IdRef>();
            if (o.Name == "rayFlags")
                RayFlags = o.To<IdRef>();
            if (o.Name == "cullMask")
                CullMask = o.To<IdRef>();
            if (o.Name == "rayOrigin")
                RayOrigin = o.To<IdRef>();
            if (o.Name == "rayTMin")
                RayTMin = o.To<IdRef>();
            if (o.Name == "rayDirection")
                RayDirection = o.To<IdRef>();
            if (o.Name == "rayTMax")
                RayTMax = o.To<IdRef>();
        }
    }

    public OpRayQueryInitializeKHR(int rayQuery, int accel, int rayFlags, int cullMask, int rayOrigin, int rayTMin, int rayDirection, int rayTMax)
    {
        RayQuery = rayQuery;
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        RayOrigin = rayOrigin;
        RayTMin = rayTMin;
        RayDirection = rayDirection;
        RayTMax = rayTMax;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryInitializeKHR, ..RayQuery.AsSpirvSpan(), ..Accel.AsSpirvSpan(), ..RayFlags.AsSpirvSpan(), ..CullMask.AsSpirvSpan(), ..RayOrigin.AsSpirvSpan(), ..RayTMin.AsSpirvSpan(), ..RayDirection.AsSpirvSpan(), ..RayTMax.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryInitializeKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryTerminateKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryTerminateKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
        }
    }

    public OpRayQueryTerminateKHR(int rayQuery)
    {
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryTerminateKHR, ..RayQuery.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryTerminateKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGenerateIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitT
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGenerateIntersectionKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "hitT")
                HitT = o.To<IdRef>();
        }
    }

    public OpRayQueryGenerateIntersectionKHR(int rayQuery, int hitT)
    {
        RayQuery = rayQuery;
        HitT = hitT;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGenerateIntersectionKHR, ..RayQuery.AsSpirvSpan(), ..HitT.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGenerateIntersectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryConfirmIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryConfirmIntersectionKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
        }
    }

    public OpRayQueryConfirmIntersectionKHR(int rayQuery)
    {
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryConfirmIntersectionKHR, ..RayQuery.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryConfirmIntersectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryProceedKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryProceedKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryProceedKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryProceedKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
        }
    }

    public OpRayQueryProceedKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryProceedKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryProceedKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionTypeKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionTypeKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionTypeKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionTypeKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionTypeKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionTypeKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTypeKHR(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleWeightedQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleWeightedQCOM inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleWeightedQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Texture
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Weights
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleWeightedQCOM(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "texture")
                Texture = o.To<IdRef>();
            if (o.Name == "coordinates")
                Coordinates = o.To<IdRef>();
            if (o.Name == "weights")
                Weights = o.To<IdRef>();
        }
    }

    public OpImageSampleWeightedQCOM(int resultType, int resultId, int texture, int coordinates, int weights)
    {
        ResultType = resultType;
        ResultId = resultId;
        Texture = texture;
        Coordinates = coordinates;
        Weights = weights;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleWeightedQCOM, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Texture.AsSpirvSpan(), ..Coordinates.AsSpirvSpan(), ..Weights.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleWeightedQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBoxFilterQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageBoxFilterQCOM inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageBoxFilterQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Texture
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BoxSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageBoxFilterQCOM(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "texture")
                Texture = o.To<IdRef>();
            if (o.Name == "coordinates")
                Coordinates = o.To<IdRef>();
            if (o.Name == "boxSize")
                BoxSize = o.To<IdRef>();
        }
    }

    public OpImageBoxFilterQCOM(int resultType, int resultId, int texture, int coordinates, int boxSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Texture = texture;
        Coordinates = coordinates;
        BoxSize = boxSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageBoxFilterQCOM, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Texture.AsSpirvSpan(), ..Coordinates.AsSpirvSpan(), ..BoxSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBoxFilterQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageBlockMatchSSDQCOM inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchSSDQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Reference
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchSSDQCOM(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "target")
                Target = o.To<IdRef>();
            if (o.Name == "targetCoordinates")
                TargetCoordinates = o.To<IdRef>();
            if (o.Name == "reference")
                Reference = o.To<IdRef>();
            if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.To<IdRef>();
            if (o.Name == "blockSize")
                BlockSize = o.To<IdRef>();
        }
    }

    public OpImageBlockMatchSSDQCOM(int resultType, int resultId, int target, int targetCoordinates, int reference, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        TargetCoordinates = targetCoordinates;
        Reference = reference;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageBlockMatchSSDQCOM, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Target.AsSpirvSpan(), ..TargetCoordinates.AsSpirvSpan(), ..Reference.AsSpirvSpan(), ..ReferenceCoordinates.AsSpirvSpan(), ..BlockSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchSSDQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageBlockMatchSADQCOM inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchSADQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Reference
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchSADQCOM(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "target")
                Target = o.To<IdRef>();
            if (o.Name == "targetCoordinates")
                TargetCoordinates = o.To<IdRef>();
            if (o.Name == "reference")
                Reference = o.To<IdRef>();
            if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.To<IdRef>();
            if (o.Name == "blockSize")
                BlockSize = o.To<IdRef>();
        }
    }

    public OpImageBlockMatchSADQCOM(int resultType, int resultId, int target, int targetCoordinates, int reference, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        TargetCoordinates = targetCoordinates;
        Reference = reference;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageBlockMatchSADQCOM, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Target.AsSpirvSpan(), ..TargetCoordinates.AsSpirvSpan(), ..Reference.AsSpirvSpan(), ..ReferenceCoordinates.AsSpirvSpan(), ..BlockSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchSADQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchWindowSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageBlockMatchWindowSSDQCOM inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchWindowSSDQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchWindowSSDQCOM(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "targetSampledImage")
                TargetSampledImage = o.To<IdRef>();
            if (o.Name == "targetCoordinates")
                TargetCoordinates = o.To<IdRef>();
            if (o.Name == "referenceSampledImage")
                ReferenceSampledImage = o.To<IdRef>();
            if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.To<IdRef>();
            if (o.Name == "blockSize")
                BlockSize = o.To<IdRef>();
        }
    }

    public OpImageBlockMatchWindowSSDQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageBlockMatchWindowSSDQCOM, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TargetSampledImage.AsSpirvSpan(), ..TargetCoordinates.AsSpirvSpan(), ..ReferenceSampledImage.AsSpirvSpan(), ..ReferenceCoordinates.AsSpirvSpan(), ..BlockSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchWindowSSDQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchWindowSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageBlockMatchWindowSADQCOM inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchWindowSADQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchWindowSADQCOM(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "targetSampledImage")
                TargetSampledImage = o.To<IdRef>();
            if (o.Name == "targetCoordinates")
                TargetCoordinates = o.To<IdRef>();
            if (o.Name == "referenceSampledImage")
                ReferenceSampledImage = o.To<IdRef>();
            if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.To<IdRef>();
            if (o.Name == "blockSize")
                BlockSize = o.To<IdRef>();
        }
    }

    public OpImageBlockMatchWindowSADQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageBlockMatchWindowSADQCOM, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TargetSampledImage.AsSpirvSpan(), ..TargetCoordinates.AsSpirvSpan(), ..ReferenceSampledImage.AsSpirvSpan(), ..ReferenceCoordinates.AsSpirvSpan(), ..BlockSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchWindowSADQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchGatherSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageBlockMatchGatherSSDQCOM inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchGatherSSDQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchGatherSSDQCOM(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "targetSampledImage")
                TargetSampledImage = o.To<IdRef>();
            if (o.Name == "targetCoordinates")
                TargetCoordinates = o.To<IdRef>();
            if (o.Name == "referenceSampledImage")
                ReferenceSampledImage = o.To<IdRef>();
            if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.To<IdRef>();
            if (o.Name == "blockSize")
                BlockSize = o.To<IdRef>();
        }
    }

    public OpImageBlockMatchGatherSSDQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageBlockMatchGatherSSDQCOM, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TargetSampledImage.AsSpirvSpan(), ..TargetCoordinates.AsSpirvSpan(), ..ReferenceSampledImage.AsSpirvSpan(), ..ReferenceCoordinates.AsSpirvSpan(), ..BlockSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchGatherSSDQCOM(OpDataIndex odi) => new(odi);
}

public struct OpImageBlockMatchGatherSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageBlockMatchGatherSADQCOM inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageBlockMatchGatherSADQCOM inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageBlockMatchGatherSADQCOM(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "targetSampledImage")
                TargetSampledImage = o.To<IdRef>();
            if (o.Name == "targetCoordinates")
                TargetCoordinates = o.To<IdRef>();
            if (o.Name == "referenceSampledImage")
                ReferenceSampledImage = o.To<IdRef>();
            if (o.Name == "referenceCoordinates")
                ReferenceCoordinates = o.To<IdRef>();
            if (o.Name == "blockSize")
                BlockSize = o.To<IdRef>();
        }
    }

    public OpImageBlockMatchGatherSADQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageBlockMatchGatherSADQCOM, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TargetSampledImage.AsSpirvSpan(), ..TargetCoordinates.AsSpirvSpan(), ..ReferenceSampledImage.AsSpirvSpan(), ..ReferenceCoordinates.AsSpirvSpan(), ..BlockSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageBlockMatchGatherSADQCOM(OpDataIndex odi) => new(odi);
}

public struct OpGroupIAddNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupIAddNonUniformAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupIAddNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupIAddNonUniformAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupIAddNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupIAddNonUniformAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupIAddNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupFAddNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupFAddNonUniformAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupFAddNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupFAddNonUniformAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupFAddNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupFAddNonUniformAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFAddNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupFMinNonUniformAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupFMinNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupFMinNonUniformAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupFMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupFMinNonUniformAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupUMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupUMinNonUniformAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupUMinNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupUMinNonUniformAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupUMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupUMinNonUniformAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupUMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupSMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupSMinNonUniformAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupSMinNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupSMinNonUniformAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupSMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupSMinNonUniformAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupSMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupFMaxNonUniformAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupFMaxNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupFMaxNonUniformAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupFMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupFMaxNonUniformAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupUMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupUMaxNonUniformAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupUMaxNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupUMaxNonUniformAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupUMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupUMaxNonUniformAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupUMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpGroupSMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupSMaxNonUniformAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupSMaxNonUniformAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupSMaxNonUniformAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupSMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupSMaxNonUniformAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupSMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public struct OpFragmentMaskFetchAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFragmentMaskFetchAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFragmentMaskFetchAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFragmentMaskFetchAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
        }
    }

    public OpFragmentMaskFetchAMD(int resultType, int resultId, int image, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFragmentMaskFetchAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFragmentMaskFetchAMD(OpDataIndex odi) => new(odi);
}

public struct OpFragmentFetchAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFragmentFetchAMD inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFragmentFetchAMD inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FragmentIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFragmentFetchAMD(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "fragmentIndex")
                FragmentIndex = o.To<IdRef>();
        }
    }

    public OpFragmentFetchAMD(int resultType, int resultId, int image, int coordinate, int fragmentIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        FragmentIndex = fragmentIndex;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFragmentFetchAMD, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..FragmentIndex.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFragmentFetchAMD(OpDataIndex odi) => new(odi);
}

public struct OpReadClockKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpReadClockKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpReadClockKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Scope
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReadClockKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "scope")
                Scope = o.To<IdScope>();
        }
    }

    public OpReadClockKHR(int resultType, int resultId, int scope)
    {
        ResultType = resultType;
        ResultId = resultId;
        Scope = scope;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReadClockKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Scope.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReadClockKHR(OpDataIndex odi) => new(odi);
}

public struct OpAllocateNodePayloadsAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAllocateNodePayloadsAMDX inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAllocateNodePayloadsAMDX inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Visibility
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PayloadCount
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NodeIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAllocateNodePayloadsAMDX(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "visibility")
                Visibility = o.To<IdScope>();
            if (o.Name == "payloadCount")
                PayloadCount = o.To<IdRef>();
            if (o.Name == "nodeIndex")
                NodeIndex = o.To<IdRef>();
        }
    }

    public OpAllocateNodePayloadsAMDX(int resultType, int resultId, int visibility, int payloadCount, int nodeIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        Visibility = visibility;
        PayloadCount = payloadCount;
        NodeIndex = nodeIndex;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAllocateNodePayloadsAMDX, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Visibility.AsSpirvSpan(), ..PayloadCount.AsSpirvSpan(), ..NodeIndex.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAllocateNodePayloadsAMDX(OpDataIndex odi) => new(odi);
}

public struct OpEnqueueNodePayloadsAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int PayloadArray
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpEnqueueNodePayloadsAMDX(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "payloadArray")
                PayloadArray = o.To<IdRef>();
        }
    }

    public OpEnqueueNodePayloadsAMDX(int payloadArray)
    {
        PayloadArray = payloadArray;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpEnqueueNodePayloadsAMDX, ..PayloadArray.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEnqueueNodePayloadsAMDX(OpDataIndex odi) => new(odi);
}

public struct OpTypeNodePayloadArrayAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeNodePayloadArrayAMDX inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeNodePayloadArrayAMDX inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PayloadType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeNodePayloadArrayAMDX(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payloadType")
                PayloadType = o.To<IdRef>();
        }
    }

    public OpTypeNodePayloadArrayAMDX(int resultId, int payloadType)
    {
        ResultId = resultId;
        PayloadType = payloadType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeNodePayloadArrayAMDX, ..ResultId.AsSpirvSpan(), ..PayloadType.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeNodePayloadArrayAMDX(OpDataIndex odi) => new(odi);
}

public struct OpFinishWritingNodePayloadAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFinishWritingNodePayloadAMDX inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFinishWritingNodePayloadAMDX inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFinishWritingNodePayloadAMDX(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpFinishWritingNodePayloadAMDX(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFinishWritingNodePayloadAMDX, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFinishWritingNodePayloadAMDX(OpDataIndex odi) => new(odi);
}

public struct OpNodePayloadArrayLengthAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpNodePayloadArrayLengthAMDX inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpNodePayloadArrayLengthAMDX inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PayloadArray
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpNodePayloadArrayLengthAMDX(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payloadArray")
                PayloadArray = o.To<IdRef>();
        }
    }

    public OpNodePayloadArrayLengthAMDX(int resultType, int resultId, int payloadArray)
    {
        ResultType = resultType;
        ResultId = resultId;
        PayloadArray = payloadArray;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpNodePayloadArrayLengthAMDX, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PayloadArray.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpNodePayloadArrayLengthAMDX(OpDataIndex odi) => new(odi);
}

public struct OpIsNodePayloadValidAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIsNodePayloadValidAMDX inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIsNodePayloadValidAMDX inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PayloadType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NodeIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIsNodePayloadValidAMDX(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payloadType")
                PayloadType = o.To<IdRef>();
            if (o.Name == "nodeIndex")
                NodeIndex = o.To<IdRef>();
        }
    }

    public OpIsNodePayloadValidAMDX(int resultType, int resultId, int payloadType, int nodeIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        PayloadType = payloadType;
        NodeIndex = nodeIndex;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIsNodePayloadValidAMDX, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PayloadType.AsSpirvSpan(), ..NodeIndex.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsNodePayloadValidAMDX(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformQuadAllKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformQuadAllKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformQuadAllKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformQuadAllKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformQuadAllKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformQuadAllKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformQuadAllKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformQuadAnyKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformQuadAnyKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformQuadAnyKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformQuadAnyKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "predicate")
                Predicate = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformQuadAnyKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformQuadAnyKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Predicate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformQuadAnyKHR(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordHitMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitMotionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "accelerationStructure")
                AccelerationStructure = o.To<IdRef>();
            if (o.Name == "instanceId")
                InstanceId = o.To<IdRef>();
            if (o.Name == "primitiveId")
                PrimitiveId = o.To<IdRef>();
            if (o.Name == "geometryIndex")
                GeometryIndex = o.To<IdRef>();
            if (o.Name == "hitKind")
                HitKind = o.To<IdRef>();
            if (o.Name == "sBTRecordOffset")
                SBTRecordOffset = o.To<IdRef>();
            if (o.Name == "sBTRecordStride")
                SBTRecordStride = o.To<IdRef>();
            if (o.Name == "origin")
                Origin = o.To<IdRef>();
            if (o.Name == "tMin")
                TMin = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "tMax")
                TMax = o.To<IdRef>();
            if (o.Name == "currentTime")
                CurrentTime = o.To<IdRef>();
            if (o.Name == "hitObjectAttributes")
                HitObjectAttributes = o.To<IdRef>();
        }
    }

    public OpHitObjectRecordHitMotionNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordOffset, int sBTRecordStride, int origin, int tMin, int direction, int tMax, int currentTime, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectRecordHitMotionNV, ..HitObject.AsSpirvSpan(), ..AccelerationStructure.AsSpirvSpan(), ..InstanceId.AsSpirvSpan(), ..PrimitiveId.AsSpirvSpan(), ..GeometryIndex.AsSpirvSpan(), ..HitKind.AsSpirvSpan(), ..SBTRecordOffset.AsSpirvSpan(), ..SBTRecordStride.AsSpirvSpan(), ..Origin.AsSpirvSpan(), ..TMin.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..TMax.AsSpirvSpan(), ..CurrentTime.AsSpirvSpan(), ..HitObjectAttributes.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordHitMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordHitWithIndexMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitWithIndexMotionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "accelerationStructure")
                AccelerationStructure = o.To<IdRef>();
            if (o.Name == "instanceId")
                InstanceId = o.To<IdRef>();
            if (o.Name == "primitiveId")
                PrimitiveId = o.To<IdRef>();
            if (o.Name == "geometryIndex")
                GeometryIndex = o.To<IdRef>();
            if (o.Name == "hitKind")
                HitKind = o.To<IdRef>();
            if (o.Name == "sBTRecordIndex")
                SBTRecordIndex = o.To<IdRef>();
            if (o.Name == "origin")
                Origin = o.To<IdRef>();
            if (o.Name == "tMin")
                TMin = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "tMax")
                TMax = o.To<IdRef>();
            if (o.Name == "currentTime")
                CurrentTime = o.To<IdRef>();
            if (o.Name == "hitObjectAttributes")
                HitObjectAttributes = o.To<IdRef>();
        }
    }

    public OpHitObjectRecordHitWithIndexMotionNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordIndex, int origin, int tMin, int direction, int tMax, int currentTime, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordIndex = sBTRecordIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectRecordHitWithIndexMotionNV, ..HitObject.AsSpirvSpan(), ..AccelerationStructure.AsSpirvSpan(), ..InstanceId.AsSpirvSpan(), ..PrimitiveId.AsSpirvSpan(), ..GeometryIndex.AsSpirvSpan(), ..HitKind.AsSpirvSpan(), ..SBTRecordIndex.AsSpirvSpan(), ..Origin.AsSpirvSpan(), ..TMin.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..TMax.AsSpirvSpan(), ..CurrentTime.AsSpirvSpan(), ..HitObjectAttributes.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordHitWithIndexMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordMissMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordMissMotionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "sBTIndex")
                SBTIndex = o.To<IdRef>();
            if (o.Name == "origin")
                Origin = o.To<IdRef>();
            if (o.Name == "tMin")
                TMin = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "tMax")
                TMax = o.To<IdRef>();
            if (o.Name == "currentTime")
                CurrentTime = o.To<IdRef>();
        }
    }

    public OpHitObjectRecordMissMotionNV(int hitObject, int sBTIndex, int origin, int tMin, int direction, int tMax, int currentTime)
    {
        HitObject = hitObject;
        SBTIndex = sBTIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectRecordMissMotionNV, ..HitObject.AsSpirvSpan(), ..SBTIndex.AsSpirvSpan(), ..Origin.AsSpirvSpan(), ..TMin.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..TMax.AsSpirvSpan(), ..CurrentTime.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordMissMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetWorldToObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetWorldToObjectNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetWorldToObjectNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetWorldToObjectNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetWorldToObjectNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetWorldToObjectNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetWorldToObjectNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetObjectToWorldNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetObjectToWorldNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetObjectToWorldNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetObjectToWorldNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetObjectToWorldNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetObjectToWorldNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetObjectToWorldNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetObjectRayDirectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetObjectRayDirectionNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetObjectRayDirectionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetObjectRayDirectionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetObjectRayDirectionNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetObjectRayDirectionNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetObjectRayDirectionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetObjectRayOriginNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetObjectRayOriginNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetObjectRayOriginNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetObjectRayOriginNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetObjectRayOriginNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetObjectRayOriginNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetObjectRayOriginNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectTraceRayMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Cullmask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectTraceRayMotionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "accelerationStructure")
                AccelerationStructure = o.To<IdRef>();
            if (o.Name == "rayFlags")
                RayFlags = o.To<IdRef>();
            if (o.Name == "cullmask")
                Cullmask = o.To<IdRef>();
            if (o.Name == "sBTRecordOffset")
                SBTRecordOffset = o.To<IdRef>();
            if (o.Name == "sBTRecordStride")
                SBTRecordStride = o.To<IdRef>();
            if (o.Name == "missIndex")
                MissIndex = o.To<IdRef>();
            if (o.Name == "origin")
                Origin = o.To<IdRef>();
            if (o.Name == "tMin")
                TMin = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "tMax")
                TMax = o.To<IdRef>();
            if (o.Name == "time")
                Time = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpHitObjectTraceRayMotionNV(int hitObject, int accelerationStructure, int rayFlags, int cullmask, int sBTRecordOffset, int sBTRecordStride, int missIndex, int origin, int tMin, int direction, int tMax, int time, int payload)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        RayFlags = rayFlags;
        Cullmask = cullmask;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        MissIndex = missIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        Time = time;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectTraceRayMotionNV, ..HitObject.AsSpirvSpan(), ..AccelerationStructure.AsSpirvSpan(), ..RayFlags.AsSpirvSpan(), ..Cullmask.AsSpirvSpan(), ..SBTRecordOffset.AsSpirvSpan(), ..SBTRecordStride.AsSpirvSpan(), ..MissIndex.AsSpirvSpan(), ..Origin.AsSpirvSpan(), ..TMin.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..TMax.AsSpirvSpan(), ..Time.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectTraceRayMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetShaderRecordBufferHandleNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetShaderRecordBufferHandleNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetShaderRecordBufferHandleNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetShaderRecordBufferHandleNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetShaderRecordBufferHandleNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetShaderRecordBufferHandleNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetShaderRecordBufferHandleNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetShaderBindingTableRecordIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetShaderBindingTableRecordIndexNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetShaderBindingTableRecordIndexNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetShaderBindingTableRecordIndexNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetShaderBindingTableRecordIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordEmptyNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordEmptyNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectRecordEmptyNV(int hitObject)
    {
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectRecordEmptyNV, ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordEmptyNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectTraceRayNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Cullmask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectTraceRayNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "accelerationStructure")
                AccelerationStructure = o.To<IdRef>();
            if (o.Name == "rayFlags")
                RayFlags = o.To<IdRef>();
            if (o.Name == "cullmask")
                Cullmask = o.To<IdRef>();
            if (o.Name == "sBTRecordOffset")
                SBTRecordOffset = o.To<IdRef>();
            if (o.Name == "sBTRecordStride")
                SBTRecordStride = o.To<IdRef>();
            if (o.Name == "missIndex")
                MissIndex = o.To<IdRef>();
            if (o.Name == "origin")
                Origin = o.To<IdRef>();
            if (o.Name == "tMin")
                TMin = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "tMax")
                TMax = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpHitObjectTraceRayNV(int hitObject, int accelerationStructure, int rayFlags, int cullmask, int sBTRecordOffset, int sBTRecordStride, int missIndex, int origin, int tMin, int direction, int tMax, int payload)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        RayFlags = rayFlags;
        Cullmask = cullmask;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        MissIndex = missIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectTraceRayNV, ..HitObject.AsSpirvSpan(), ..AccelerationStructure.AsSpirvSpan(), ..RayFlags.AsSpirvSpan(), ..Cullmask.AsSpirvSpan(), ..SBTRecordOffset.AsSpirvSpan(), ..SBTRecordStride.AsSpirvSpan(), ..MissIndex.AsSpirvSpan(), ..Origin.AsSpirvSpan(), ..TMin.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..TMax.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectTraceRayNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordHitNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "accelerationStructure")
                AccelerationStructure = o.To<IdRef>();
            if (o.Name == "instanceId")
                InstanceId = o.To<IdRef>();
            if (o.Name == "primitiveId")
                PrimitiveId = o.To<IdRef>();
            if (o.Name == "geometryIndex")
                GeometryIndex = o.To<IdRef>();
            if (o.Name == "hitKind")
                HitKind = o.To<IdRef>();
            if (o.Name == "sBTRecordOffset")
                SBTRecordOffset = o.To<IdRef>();
            if (o.Name == "sBTRecordStride")
                SBTRecordStride = o.To<IdRef>();
            if (o.Name == "origin")
                Origin = o.To<IdRef>();
            if (o.Name == "tMin")
                TMin = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "tMax")
                TMax = o.To<IdRef>();
            if (o.Name == "hitObjectAttributes")
                HitObjectAttributes = o.To<IdRef>();
        }
    }

    public OpHitObjectRecordHitNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordOffset, int sBTRecordStride, int origin, int tMin, int direction, int tMax, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectRecordHitNV, ..HitObject.AsSpirvSpan(), ..AccelerationStructure.AsSpirvSpan(), ..InstanceId.AsSpirvSpan(), ..PrimitiveId.AsSpirvSpan(), ..GeometryIndex.AsSpirvSpan(), ..HitKind.AsSpirvSpan(), ..SBTRecordOffset.AsSpirvSpan(), ..SBTRecordStride.AsSpirvSpan(), ..Origin.AsSpirvSpan(), ..TMin.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..TMax.AsSpirvSpan(), ..HitObjectAttributes.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordHitNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordHitWithIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTRecordIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitWithIndexNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "accelerationStructure")
                AccelerationStructure = o.To<IdRef>();
            if (o.Name == "instanceId")
                InstanceId = o.To<IdRef>();
            if (o.Name == "primitiveId")
                PrimitiveId = o.To<IdRef>();
            if (o.Name == "geometryIndex")
                GeometryIndex = o.To<IdRef>();
            if (o.Name == "hitKind")
                HitKind = o.To<IdRef>();
            if (o.Name == "sBTRecordIndex")
                SBTRecordIndex = o.To<IdRef>();
            if (o.Name == "origin")
                Origin = o.To<IdRef>();
            if (o.Name == "tMin")
                TMin = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "tMax")
                TMax = o.To<IdRef>();
            if (o.Name == "hitObjectAttributes")
                HitObjectAttributes = o.To<IdRef>();
        }
    }

    public OpHitObjectRecordHitWithIndexNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordIndex, int origin, int tMin, int direction, int tMax, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordIndex = sBTRecordIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectRecordHitWithIndexNV, ..HitObject.AsSpirvSpan(), ..AccelerationStructure.AsSpirvSpan(), ..InstanceId.AsSpirvSpan(), ..PrimitiveId.AsSpirvSpan(), ..GeometryIndex.AsSpirvSpan(), ..HitKind.AsSpirvSpan(), ..SBTRecordIndex.AsSpirvSpan(), ..Origin.AsSpirvSpan(), ..TMin.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..TMax.AsSpirvSpan(), ..HitObjectAttributes.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordHitWithIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectRecordMissNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordMissNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "sBTIndex")
                SBTIndex = o.To<IdRef>();
            if (o.Name == "origin")
                Origin = o.To<IdRef>();
            if (o.Name == "tMin")
                TMin = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "tMax")
                TMax = o.To<IdRef>();
        }
    }

    public OpHitObjectRecordMissNV(int hitObject, int sBTIndex, int origin, int tMin, int direction, int tMax)
    {
        HitObject = hitObject;
        SBTIndex = sBTIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectRecordMissNV, ..HitObject.AsSpirvSpan(), ..SBTIndex.AsSpirvSpan(), ..Origin.AsSpirvSpan(), ..TMin.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..TMax.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectRecordMissNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectExecuteShaderNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectExecuteShaderNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpHitObjectExecuteShaderNV(int hitObject, int payload)
    {
        HitObject = hitObject;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectExecuteShaderNV, ..HitObject.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectExecuteShaderNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetCurrentTimeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetCurrentTimeNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetCurrentTimeNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetCurrentTimeNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetCurrentTimeNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetCurrentTimeNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetCurrentTimeNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetAttributesNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObjectAttribute
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetAttributesNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "hitObjectAttribute")
                HitObjectAttribute = o.To<IdRef>();
        }
    }

    public OpHitObjectGetAttributesNV(int hitObject, int hitObjectAttribute)
    {
        HitObject = hitObject;
        HitObjectAttribute = hitObjectAttribute;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetAttributesNV, ..HitObject.AsSpirvSpan(), ..HitObjectAttribute.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetAttributesNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetHitKindNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetHitKindNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetHitKindNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetHitKindNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetHitKindNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetHitKindNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetHitKindNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetPrimitiveIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetPrimitiveIndexNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetPrimitiveIndexNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetPrimitiveIndexNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetPrimitiveIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetPrimitiveIndexNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetPrimitiveIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetGeometryIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetGeometryIndexNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetGeometryIndexNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetGeometryIndexNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetGeometryIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetGeometryIndexNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetGeometryIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetInstanceIdNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetInstanceIdNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetInstanceIdNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetInstanceIdNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetInstanceIdNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetInstanceIdNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetInstanceIdNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetInstanceCustomIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetInstanceCustomIndexNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetInstanceCustomIndexNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetInstanceCustomIndexNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetInstanceCustomIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetInstanceCustomIndexNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetInstanceCustomIndexNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetWorldRayDirectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetWorldRayDirectionNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetWorldRayDirectionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetWorldRayDirectionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetWorldRayDirectionNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetWorldRayDirectionNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetWorldRayDirectionNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetWorldRayOriginNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetWorldRayOriginNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetWorldRayOriginNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetWorldRayOriginNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetWorldRayOriginNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetWorldRayOriginNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetWorldRayOriginNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetRayTMaxNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetRayTMaxNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetRayTMaxNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetRayTMaxNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetRayTMaxNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetRayTMaxNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetRayTMaxNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectGetRayTMinNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectGetRayTMinNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectGetRayTMinNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetRayTMinNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectGetRayTMinNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectGetRayTMinNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectGetRayTMinNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectIsEmptyNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectIsEmptyNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectIsEmptyNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectIsEmptyNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectIsEmptyNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectIsEmptyNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectIsEmptyNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectIsHitNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectIsHitNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectIsHitNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectIsHitNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectIsHitNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectIsHitNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectIsHitNV(OpDataIndex odi) => new(odi);
}

public struct OpHitObjectIsMissNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpHitObjectIsMissNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpHitObjectIsMissNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpHitObjectIsMissNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
        }
    }

    public OpHitObjectIsMissNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpHitObjectIsMissNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..HitObject.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpHitObjectIsMissNV(OpDataIndex odi) => new(odi);
}

public struct OpReorderThreadWithHitObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Hint
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Bits
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReorderThreadWithHitObjectNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hitObject")
                HitObject = o.To<IdRef>();
            if (o.Name == "hint")
                Hint = o.To<IdRef>();
            if (o.Name == "bits")
                Bits = o.To<IdRef>();
        }
    }

    public OpReorderThreadWithHitObjectNV(int hitObject, int? hint, int? bits)
    {
        HitObject = hitObject;
        Hint = hint;
        Bits = bits;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReorderThreadWithHitObjectNV, ..HitObject.AsSpirvSpan(), ..Hint.AsSpirvSpan(), ..Bits.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReorderThreadWithHitObjectNV(OpDataIndex odi) => new(odi);
}

public struct OpReorderThreadWithHintNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Hint
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Bits
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReorderThreadWithHintNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "hint")
                Hint = o.To<IdRef>();
            if (o.Name == "bits")
                Bits = o.To<IdRef>();
        }
    }

    public OpReorderThreadWithHintNV(int hint, int bits)
    {
        Hint = hint;
        Bits = bits;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReorderThreadWithHintNV, ..Hint.AsSpirvSpan(), ..Bits.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReorderThreadWithHintNV(OpDataIndex odi) => new(odi);
}

public struct OpTypeHitObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeHitObjectNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeHitObjectNV inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeHitObjectNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeHitObjectNV(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeHitObjectNV, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeHitObjectNV(OpDataIndex odi) => new(odi);
}

public struct OpImageSampleFootprintNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpImageSampleFootprintNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpImageSampleFootprintNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Granularity
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coarse
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpImageSampleFootprintNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sampledImage")
                SampledImage = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "granularity")
                Granularity = o.To<IdRef>();
            if (o.Name == "coarse")
                Coarse = o.To<IdRef>();
            if (o.Name == "imageoperands")
                Imageoperands = o.ToEnum<ImageOperandsMask>();
        }
    }

    public OpImageSampleFootprintNV(int resultType, int resultId, int sampledImage, int coordinate, int granularity, int coarse, ImageOperandsMask? imageoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Granularity = granularity;
        Coarse = coarse;
        Imageoperands = imageoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpImageSampleFootprintNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SampledImage.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Granularity.AsSpirvSpan(), ..Coarse.AsSpirvSpan(), ..Imageoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpImageSampleFootprintNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixConvertNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixConvertNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixConvertNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixConvertNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "matrix")
                Matrix = o.To<IdRef>();
        }
    }

    public OpCooperativeMatrixConvertNV(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixConvertNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Matrix.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixConvertNV(OpDataIndex odi) => new(odi);
}

public struct OpEmitMeshTasksEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int GroupCountX
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GroupCountY
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GroupCountZ
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpEmitMeshTasksEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "groupCountX")
                GroupCountX = o.To<IdRef>();
            if (o.Name == "groupCountY")
                GroupCountY = o.To<IdRef>();
            if (o.Name == "groupCountZ")
                GroupCountZ = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpEmitMeshTasksEXT(int groupCountX, int groupCountY, int groupCountZ, int? payload)
    {
        GroupCountX = groupCountX;
        GroupCountY = groupCountY;
        GroupCountZ = groupCountZ;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpEmitMeshTasksEXT, ..GroupCountX.AsSpirvSpan(), ..GroupCountY.AsSpirvSpan(), ..GroupCountZ.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpEmitMeshTasksEXT(OpDataIndex odi) => new(odi);
}

public struct OpSetMeshOutputsEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int VertexCount
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PrimitiveCount
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSetMeshOutputsEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "vertexCount")
                VertexCount = o.To<IdRef>();
            if (o.Name == "primitiveCount")
                PrimitiveCount = o.To<IdRef>();
        }
    }

    public OpSetMeshOutputsEXT(int vertexCount, int primitiveCount)
    {
        VertexCount = vertexCount;
        PrimitiveCount = primitiveCount;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSetMeshOutputsEXT, ..VertexCount.AsSpirvSpan(), ..PrimitiveCount.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSetMeshOutputsEXT(OpDataIndex odi) => new(odi);
}

public struct OpGroupNonUniformPartitionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupNonUniformPartitionNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupNonUniformPartitionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupNonUniformPartitionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpGroupNonUniformPartitionNV(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupNonUniformPartitionNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupNonUniformPartitionNV(OpDataIndex odi) => new(odi);
}

public struct OpWritePackedPrimitiveIndices4x8NV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int IndexOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedIndices
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpWritePackedPrimitiveIndices4x8NV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "indexOffset")
                IndexOffset = o.To<IdRef>();
            if (o.Name == "packedIndices")
                PackedIndices = o.To<IdRef>();
        }
    }

    public OpWritePackedPrimitiveIndices4x8NV(int indexOffset, int packedIndices)
    {
        IndexOffset = indexOffset;
        PackedIndices = packedIndices;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpWritePackedPrimitiveIndices4x8NV, ..IndexOffset.AsSpirvSpan(), ..PackedIndices.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpWritePackedPrimitiveIndices4x8NV(OpDataIndex odi) => new(odi);
}

public struct OpFetchMicroTriangleVertexPositionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFetchMicroTriangleVertexPositionNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFetchMicroTriangleVertexPositionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PrimitiveIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Barycentric
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFetchMicroTriangleVertexPositionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "accel")
                Accel = o.To<IdRef>();
            if (o.Name == "instanceId")
                InstanceId = o.To<IdRef>();
            if (o.Name == "geometryIndex")
                GeometryIndex = o.To<IdRef>();
            if (o.Name == "primitiveIndex")
                PrimitiveIndex = o.To<IdRef>();
            if (o.Name == "barycentric")
                Barycentric = o.To<IdRef>();
        }
    }

    public OpFetchMicroTriangleVertexPositionNV(int resultType, int resultId, int accel, int instanceId, int geometryIndex, int primitiveIndex, int barycentric)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        InstanceId = instanceId;
        GeometryIndex = geometryIndex;
        PrimitiveIndex = primitiveIndex;
        Barycentric = barycentric;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFetchMicroTriangleVertexPositionNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Accel.AsSpirvSpan(), ..InstanceId.AsSpirvSpan(), ..GeometryIndex.AsSpirvSpan(), ..PrimitiveIndex.AsSpirvSpan(), ..Barycentric.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFetchMicroTriangleVertexPositionNV(OpDataIndex odi) => new(odi);
}

public struct OpFetchMicroTriangleVertexBarycentricNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFetchMicroTriangleVertexBarycentricNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFetchMicroTriangleVertexBarycentricNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PrimitiveIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Barycentric
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFetchMicroTriangleVertexBarycentricNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "accel")
                Accel = o.To<IdRef>();
            if (o.Name == "instanceId")
                InstanceId = o.To<IdRef>();
            if (o.Name == "geometryIndex")
                GeometryIndex = o.To<IdRef>();
            if (o.Name == "primitiveIndex")
                PrimitiveIndex = o.To<IdRef>();
            if (o.Name == "barycentric")
                Barycentric = o.To<IdRef>();
        }
    }

    public OpFetchMicroTriangleVertexBarycentricNV(int resultType, int resultId, int accel, int instanceId, int geometryIndex, int primitiveIndex, int barycentric)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        InstanceId = instanceId;
        GeometryIndex = geometryIndex;
        PrimitiveIndex = primitiveIndex;
        Barycentric = barycentric;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFetchMicroTriangleVertexBarycentricNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Accel.AsSpirvSpan(), ..InstanceId.AsSpirvSpan(), ..GeometryIndex.AsSpirvSpan(), ..PrimitiveIndex.AsSpirvSpan(), ..Barycentric.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFetchMicroTriangleVertexBarycentricNV(OpDataIndex odi) => new(odi);
}

public struct OpReportIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpReportIntersectionKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpReportIntersectionKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Hit
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReportIntersectionKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "hit")
                Hit = o.To<IdRef>();
            if (o.Name == "hitKind")
                HitKind = o.To<IdRef>();
        }
    }

    public OpReportIntersectionKHR(int resultType, int resultId, int hit, int hitKind)
    {
        ResultType = resultType;
        ResultId = resultId;
        Hit = hit;
        HitKind = hitKind;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReportIntersectionKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Hit.AsSpirvSpan(), ..HitKind.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReportIntersectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpIgnoreIntersectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIgnoreIntersectionNV(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpIgnoreIntersectionNV(OpDataIndex odi) => new(odi);
}

public struct OpTerminateRayNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateRayNV(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpTerminateRayNV(OpDataIndex odi) => new(odi);
}

public struct OpTraceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PayloadId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTraceNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "accel")
                Accel = o.To<IdRef>();
            if (o.Name == "rayFlags")
                RayFlags = o.To<IdRef>();
            if (o.Name == "cullMask")
                CullMask = o.To<IdRef>();
            if (o.Name == "sBTOffset")
                SBTOffset = o.To<IdRef>();
            if (o.Name == "sBTStride")
                SBTStride = o.To<IdRef>();
            if (o.Name == "missIndex")
                MissIndex = o.To<IdRef>();
            if (o.Name == "rayOrigin")
                RayOrigin = o.To<IdRef>();
            if (o.Name == "rayTmin")
                RayTmin = o.To<IdRef>();
            if (o.Name == "rayDirection")
                RayDirection = o.To<IdRef>();
            if (o.Name == "rayTmax")
                RayTmax = o.To<IdRef>();
            if (o.Name == "payloadId")
                PayloadId = o.To<IdRef>();
        }
    }

    public OpTraceNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int payloadId)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        PayloadId = payloadId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTraceNV, ..Accel.AsSpirvSpan(), ..RayFlags.AsSpirvSpan(), ..CullMask.AsSpirvSpan(), ..SBTOffset.AsSpirvSpan(), ..SBTStride.AsSpirvSpan(), ..MissIndex.AsSpirvSpan(), ..RayOrigin.AsSpirvSpan(), ..RayTmin.AsSpirvSpan(), ..RayDirection.AsSpirvSpan(), ..RayTmax.AsSpirvSpan(), ..PayloadId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTraceNV(OpDataIndex odi) => new(odi);
}

public struct OpTraceMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PayloadId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTraceMotionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "accel")
                Accel = o.To<IdRef>();
            if (o.Name == "rayFlags")
                RayFlags = o.To<IdRef>();
            if (o.Name == "cullMask")
                CullMask = o.To<IdRef>();
            if (o.Name == "sBTOffset")
                SBTOffset = o.To<IdRef>();
            if (o.Name == "sBTStride")
                SBTStride = o.To<IdRef>();
            if (o.Name == "missIndex")
                MissIndex = o.To<IdRef>();
            if (o.Name == "rayOrigin")
                RayOrigin = o.To<IdRef>();
            if (o.Name == "rayTmin")
                RayTmin = o.To<IdRef>();
            if (o.Name == "rayDirection")
                RayDirection = o.To<IdRef>();
            if (o.Name == "rayTmax")
                RayTmax = o.To<IdRef>();
            if (o.Name == "time")
                Time = o.To<IdRef>();
            if (o.Name == "payloadId")
                PayloadId = o.To<IdRef>();
        }
    }

    public OpTraceMotionNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int time, int payloadId)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Time = time;
        PayloadId = payloadId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTraceMotionNV, ..Accel.AsSpirvSpan(), ..RayFlags.AsSpirvSpan(), ..CullMask.AsSpirvSpan(), ..SBTOffset.AsSpirvSpan(), ..SBTStride.AsSpirvSpan(), ..MissIndex.AsSpirvSpan(), ..RayOrigin.AsSpirvSpan(), ..RayTmin.AsSpirvSpan(), ..RayDirection.AsSpirvSpan(), ..RayTmax.AsSpirvSpan(), ..Time.AsSpirvSpan(), ..PayloadId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTraceMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpTraceRayMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTraceRayMotionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "accel")
                Accel = o.To<IdRef>();
            if (o.Name == "rayFlags")
                RayFlags = o.To<IdRef>();
            if (o.Name == "cullMask")
                CullMask = o.To<IdRef>();
            if (o.Name == "sBTOffset")
                SBTOffset = o.To<IdRef>();
            if (o.Name == "sBTStride")
                SBTStride = o.To<IdRef>();
            if (o.Name == "missIndex")
                MissIndex = o.To<IdRef>();
            if (o.Name == "rayOrigin")
                RayOrigin = o.To<IdRef>();
            if (o.Name == "rayTmin")
                RayTmin = o.To<IdRef>();
            if (o.Name == "rayDirection")
                RayDirection = o.To<IdRef>();
            if (o.Name == "rayTmax")
                RayTmax = o.To<IdRef>();
            if (o.Name == "time")
                Time = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpTraceRayMotionNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int time, int payload)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Time = time;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTraceRayMotionNV, ..Accel.AsSpirvSpan(), ..RayFlags.AsSpirvSpan(), ..CullMask.AsSpirvSpan(), ..SBTOffset.AsSpirvSpan(), ..SBTStride.AsSpirvSpan(), ..MissIndex.AsSpirvSpan(), ..RayOrigin.AsSpirvSpan(), ..RayTmin.AsSpirvSpan(), ..RayDirection.AsSpirvSpan(), ..RayTmax.AsSpirvSpan(), ..Time.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTraceRayMotionNV(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionTriangleVertexPositionsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionTriangleVertexPositionsKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionTriangleVertexPositionsKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionTriangleVertexPositionsKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpDataIndex odi) => new(odi);
}

public struct OpTypeAccelerationStructureKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAccelerationStructureKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAccelerationStructureKHR inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAccelerationStructureKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAccelerationStructureKHR(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAccelerationStructureKHR, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAccelerationStructureKHR(OpDataIndex odi) => new(odi);
}

public struct OpExecuteCallableNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CallableDataId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpExecuteCallableNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "sBTIndex")
                SBTIndex = o.To<IdRef>();
            if (o.Name == "callableDataId")
                CallableDataId = o.To<IdRef>();
        }
    }

    public OpExecuteCallableNV(int sBTIndex, int callableDataId)
    {
        SBTIndex = sBTIndex;
        CallableDataId = callableDataId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExecuteCallableNV, ..SBTIndex.AsSpirvSpan(), ..CallableDataId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExecuteCallableNV(OpDataIndex odi) => new(odi);
}

public struct OpTypeCooperativeMatrixNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeCooperativeMatrixNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeCooperativeMatrixNV inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Rows
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Columns
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeCooperativeMatrixNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "componentType")
                ComponentType = o.To<IdRef>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "rows")
                Rows = o.To<IdRef>();
            if (o.Name == "columns")
                Columns = o.To<IdRef>();
        }
    }

    public OpTypeCooperativeMatrixNV(int resultId, int componentType, int execution, int rows, int columns)
    {
        ResultId = resultId;
        ComponentType = componentType;
        Execution = execution;
        Rows = rows;
        Columns = columns;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeCooperativeMatrixNV, ..ResultId.AsSpirvSpan(), ..ComponentType.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Rows.AsSpirvSpan(), ..Columns.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeCooperativeMatrixNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLoadNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixLoadNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLoadNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ColumnMajor
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLoadNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "stride")
                Stride = o.To<IdRef>();
            if (o.Name == "columnMajor")
                ColumnMajor = o.To<IdRef>();
            if (o.Name == "memoryaccess")
                Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }
    }

    public OpCooperativeMatrixLoadNV(int resultType, int resultId, int pointer, int stride, int columnMajor, MemoryAccessMask? memoryaccess)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Stride = stride;
        ColumnMajor = columnMajor;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixLoadNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Stride.AsSpirvSpan(), ..ColumnMajor.AsSpirvSpan(), ..Memoryaccess.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLoadNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixStoreNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ColumnMajor
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "objectId")
                ObjectId = o.To<IdRef>();
            if (o.Name == "stride")
                Stride = o.To<IdRef>();
            if (o.Name == "columnMajor")
                ColumnMajor = o.To<IdRef>();
            if (o.Name == "memoryaccess")
                Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }
    }

    public OpCooperativeMatrixStoreNV(int pointer, int objectId, int stride, int columnMajor, MemoryAccessMask? memoryaccess)
    {
        Pointer = pointer;
        ObjectId = objectId;
        Stride = stride;
        ColumnMajor = columnMajor;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixStoreNV, ..Pointer.AsSpirvSpan(), ..ObjectId.AsSpirvSpan(), ..Stride.AsSpirvSpan(), ..ColumnMajor.AsSpirvSpan(), ..Memoryaccess.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixStoreNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixMulAddNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixMulAddNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixMulAddNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixMulAddNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "c")
                C = o.To<IdRef>();
        }
    }

    public OpCooperativeMatrixMulAddNV(int resultType, int resultId, int a, int b, int c)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        B = b;
        C = c;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixMulAddNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..B.AsSpirvSpan(), ..C.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixMulAddNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLengthNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixLengthNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLengthNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLengthNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "type")
                Type = o.To<IdRef>();
        }
    }

    public OpCooperativeMatrixLengthNV(int resultType, int resultId, int type)
    {
        ResultType = resultType;
        ResultId = resultId;
        Type = type;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixLengthNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Type.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLengthNV(OpDataIndex odi) => new(odi);
}

public struct OpBeginInvocationInterlockEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBeginInvocationInterlockEXT(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpBeginInvocationInterlockEXT(OpDataIndex odi) => new(odi);
}

public struct OpEndInvocationInterlockEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndInvocationInterlockEXT(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpEndInvocationInterlockEXT(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixReduceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixReduceNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixReduceNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public CooperativeMatrixReduceMask Reduce
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CombineFunc
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixReduceNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "matrix")
                Matrix = o.To<IdRef>();
            if (o.Name == "reduce")
                Reduce = o.ToEnum<CooperativeMatrixReduceMask>();
            if (o.Name == "combineFunc")
                CombineFunc = o.To<IdRef>();
        }
    }

    public OpCooperativeMatrixReduceNV(int resultType, int resultId, int matrix, CooperativeMatrixReduceMask reduce, int combineFunc)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Reduce = reduce;
        CombineFunc = combineFunc;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixReduceNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Matrix.AsSpirvSpan(), ..Reduce.AsSpirvSpan(), ..CombineFunc.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixReduceNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixLoadTensorNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixLoadTensorNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixLoadTensorNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask MemoryOperand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public TensorAddressingOperandsMask TensorAddressingOperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixLoadTensorNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "objectId")
                ObjectId = o.To<IdRef>();
            if (o.Name == "tensorLayout")
                TensorLayout = o.To<IdRef>();
            if (o.Name == "memoryOperand")
                MemoryOperand = o.ToEnum<MemoryAccessMask>();
            if (o.Name == "tensorAddressingOperands")
                TensorAddressingOperands = o.ToEnum<TensorAddressingOperandsMask>();
        }
    }

    public OpCooperativeMatrixLoadTensorNV(int resultType, int resultId, int pointer, int objectId, int tensorLayout, MemoryAccessMask memoryOperand, TensorAddressingOperandsMask tensorAddressingOperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        ObjectId = objectId;
        TensorLayout = tensorLayout;
        MemoryOperand = memoryOperand;
        TensorAddressingOperands = tensorAddressingOperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixLoadTensorNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..ObjectId.AsSpirvSpan(), ..TensorLayout.AsSpirvSpan(), ..MemoryOperand.AsSpirvSpan(), ..TensorAddressingOperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixLoadTensorNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixStoreTensorNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask MemoryOperand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public TensorAddressingOperandsMask TensorAddressingOperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreTensorNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "objectId")
                ObjectId = o.To<IdRef>();
            if (o.Name == "tensorLayout")
                TensorLayout = o.To<IdRef>();
            if (o.Name == "memoryOperand")
                MemoryOperand = o.ToEnum<MemoryAccessMask>();
            if (o.Name == "tensorAddressingOperands")
                TensorAddressingOperands = o.ToEnum<TensorAddressingOperandsMask>();
        }
    }

    public OpCooperativeMatrixStoreTensorNV(int pointer, int objectId, int tensorLayout, MemoryAccessMask memoryOperand, TensorAddressingOperandsMask tensorAddressingOperands)
    {
        Pointer = pointer;
        ObjectId = objectId;
        TensorLayout = tensorLayout;
        MemoryOperand = memoryOperand;
        TensorAddressingOperands = tensorAddressingOperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixStoreTensorNV, ..Pointer.AsSpirvSpan(), ..ObjectId.AsSpirvSpan(), ..TensorLayout.AsSpirvSpan(), ..MemoryOperand.AsSpirvSpan(), ..TensorAddressingOperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixStoreTensorNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixPerElementOpNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixPerElementOpNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixPerElementOpNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Func
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixPerElementOpNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "matrix")
                Matrix = o.To<IdRef>();
            if (o.Name == "func")
                Func = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpCooperativeMatrixPerElementOpNV(int resultType, int resultId, int matrix, int func, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Func = func;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixPerElementOpNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Matrix.AsSpirvSpan(), ..Func.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixPerElementOpNV(OpDataIndex odi) => new(odi);
}

public struct OpTypeTensorLayoutNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeTensorLayoutNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeTensorLayoutNV inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dim
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ClampMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeTensorLayoutNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "dim")
                Dim = o.To<IdRef>();
            if (o.Name == "clampMode")
                ClampMode = o.To<IdRef>();
        }
    }

    public OpTypeTensorLayoutNV(int resultId, int dim, int clampMode)
    {
        ResultId = resultId;
        Dim = dim;
        ClampMode = clampMode;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeTensorLayoutNV, ..ResultId.AsSpirvSpan(), ..Dim.AsSpirvSpan(), ..ClampMode.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeTensorLayoutNV(OpDataIndex odi) => new(odi);
}

public struct OpTypeTensorViewNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeTensorViewNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeTensorViewNV inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Dim
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int HasDimensions
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTypeTensorViewNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "dim")
                Dim = o.To<IdRef>();
            if (o.Name == "hasDimensions")
                HasDimensions = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTypeTensorViewNV(int resultId, int dim, int hasDimensions, LiteralArray<IdRef> values)
    {
        ResultId = resultId;
        Dim = dim;
        HasDimensions = hasDimensions;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeTensorViewNV, ..ResultId.AsSpirvSpan(), ..Dim.AsSpirvSpan(), ..HasDimensions.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeTensorViewNV(OpDataIndex odi) => new(odi);
}

public struct OpCreateTensorLayoutNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCreateTensorLayoutNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCreateTensorLayoutNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCreateTensorLayoutNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpCreateTensorLayoutNV(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCreateTensorLayoutNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCreateTensorLayoutNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSetDimensionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTensorLayoutSetDimensionNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSetDimensionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSetDimensionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "tensorLayout")
                TensorLayout = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTensorLayoutSetDimensionNV(int resultType, int resultId, int tensorLayout, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTensorLayoutSetDimensionNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TensorLayout.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSetDimensionNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSetStrideNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTensorLayoutSetStrideNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSetStrideNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSetStrideNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "tensorLayout")
                TensorLayout = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTensorLayoutSetStrideNV(int resultType, int resultId, int tensorLayout, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTensorLayoutSetStrideNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TensorLayout.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSetStrideNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSliceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTensorLayoutSliceNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSliceNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSliceNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "tensorLayout")
                TensorLayout = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTensorLayoutSliceNV(int resultType, int resultId, int tensorLayout, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTensorLayoutSliceNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TensorLayout.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSliceNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSetClampValueNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTensorLayoutSetClampValueNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSetClampValueNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSetClampValueNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "tensorLayout")
                TensorLayout = o.To<IdRef>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpTensorLayoutSetClampValueNV(int resultType, int resultId, int tensorLayout, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTensorLayoutSetClampValueNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TensorLayout.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSetClampValueNV(OpDataIndex odi) => new(odi);
}

public struct OpCreateTensorViewNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCreateTensorViewNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCreateTensorViewNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCreateTensorViewNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpCreateTensorViewNV(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCreateTensorViewNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCreateTensorViewNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorViewSetDimensionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTensorViewSetDimensionNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTensorViewSetDimensionNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTensorViewSetDimensionNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "tensorView")
                TensorView = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTensorViewSetDimensionNV(int resultType, int resultId, int tensorView, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTensorViewSetDimensionNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TensorView.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorViewSetDimensionNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorViewSetStrideNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTensorViewSetStrideNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTensorViewSetStrideNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTensorViewSetStrideNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "tensorView")
                TensorView = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTensorViewSetStrideNV(int resultType, int resultId, int tensorView, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTensorViewSetStrideNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TensorView.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorViewSetStrideNV(OpDataIndex odi) => new(odi);
}

public struct OpDemoteToHelperInvocation : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDemoteToHelperInvocation(OpDataIndex index)
    {
        DataIndex = index;
    }

    public void UpdateInstructionMemory()
    {
    }

    public static implicit operator OpDemoteToHelperInvocation(OpDataIndex odi) => new(odi);
}

public struct OpIsHelperInvocationEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIsHelperInvocationEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIsHelperInvocationEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIsHelperInvocationEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpIsHelperInvocationEXT(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIsHelperInvocationEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIsHelperInvocationEXT(OpDataIndex odi) => new(odi);
}

public struct OpTensorViewSetClipNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTensorViewSetClipNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTensorViewSetClipNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ClipRowOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ClipRowSpan
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ClipColOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ClipColSpan
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTensorViewSetClipNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "tensorView")
                TensorView = o.To<IdRef>();
            if (o.Name == "clipRowOffset")
                ClipRowOffset = o.To<IdRef>();
            if (o.Name == "clipRowSpan")
                ClipRowSpan = o.To<IdRef>();
            if (o.Name == "clipColOffset")
                ClipColOffset = o.To<IdRef>();
            if (o.Name == "clipColSpan")
                ClipColSpan = o.To<IdRef>();
        }
    }

    public OpTensorViewSetClipNV(int resultType, int resultId, int tensorView, int clipRowOffset, int clipRowSpan, int clipColOffset, int clipColSpan)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        ClipRowOffset = clipRowOffset;
        ClipRowSpan = clipRowSpan;
        ClipColOffset = clipColOffset;
        ClipColSpan = clipColSpan;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTensorViewSetClipNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TensorView.AsSpirvSpan(), ..ClipRowOffset.AsSpirvSpan(), ..ClipRowSpan.AsSpirvSpan(), ..ClipColOffset.AsSpirvSpan(), ..ClipColSpan.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorViewSetClipNV(OpDataIndex odi) => new(odi);
}

public struct OpTensorLayoutSetBlockSizeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTensorLayoutSetBlockSizeNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTensorLayoutSetBlockSizeNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTensorLayoutSetBlockSizeNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "tensorLayout")
                TensorLayout = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTensorLayoutSetBlockSizeNV(int resultType, int resultId, int tensorLayout, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTensorLayoutSetBlockSizeNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..TensorLayout.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTensorLayoutSetBlockSizeNV(OpDataIndex odi) => new(odi);
}

public struct OpCooperativeMatrixTransposeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCooperativeMatrixTransposeNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCooperativeMatrixTransposeNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixTransposeNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "matrix")
                Matrix = o.To<IdRef>();
        }
    }

    public OpCooperativeMatrixTransposeNV(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCooperativeMatrixTransposeNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Matrix.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCooperativeMatrixTransposeNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToImageNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertUToImageNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertUToImageNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertUToImageNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpConvertUToImageNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertUToImageNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToImageNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToSamplerNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertUToSamplerNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertUToSamplerNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertUToSamplerNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpConvertUToSamplerNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertUToSamplerNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToSamplerNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertImageToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertImageToUNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertImageToUNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertImageToUNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpConvertImageToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertImageToUNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertImageToUNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertSamplerToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertSamplerToUNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertSamplerToUNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertSamplerToUNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpConvertSamplerToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertSamplerToUNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertSamplerToUNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertUToSampledImageNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertUToSampledImageNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertUToSampledImageNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertUToSampledImageNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpConvertUToSampledImageNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertUToSampledImageNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertUToSampledImageNV(OpDataIndex odi) => new(odi);
}

public struct OpConvertSampledImageToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertSampledImageToUNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertSampledImageToUNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertSampledImageToUNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpConvertSampledImageToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertSampledImageToUNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertSampledImageToUNV(OpDataIndex odi) => new(odi);
}

public struct OpSamplerImageAddressingModeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int BitWidth
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSamplerImageAddressingModeNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "bitWidth")
                BitWidth = o.To<LiteralInteger>();
        }
    }

    public OpSamplerImageAddressingModeNV(int bitWidth)
    {
        BitWidth = bitWidth;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSamplerImageAddressingModeNV, ..BitWidth.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSamplerImageAddressingModeNV(OpDataIndex odi) => new(odi);
}

public struct OpRawAccessChainNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRawAccessChainNV inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRawAccessChainNV inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Bytestride
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Elementindex
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Byteoffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public RawAccessChainOperandsMask? Rawaccesschainoperands
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRawAccessChainNV(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "baseId")
                BaseId = o.To<IdRef>();
            if (o.Name == "bytestride")
                Bytestride = o.To<IdRef>();
            if (o.Name == "elementindex")
                Elementindex = o.To<IdRef>();
            if (o.Name == "byteoffset")
                Byteoffset = o.To<IdRef>();
            if (o.Name == "rawaccesschainoperands")
                Rawaccesschainoperands = o.ToEnum<RawAccessChainOperandsMask>();
        }
    }

    public OpRawAccessChainNV(int resultType, int resultId, int baseId, int bytestride, int elementindex, int byteoffset, RawAccessChainOperandsMask? rawaccesschainoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Bytestride = bytestride;
        Elementindex = elementindex;
        Byteoffset = byteoffset;
        Rawaccesschainoperands = rawaccesschainoperands;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRawAccessChainNV, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BaseId.AsSpirvSpan(), ..Bytestride.AsSpirvSpan(), ..Elementindex.AsSpirvSpan(), ..Byteoffset.AsSpirvSpan(), ..Rawaccesschainoperands.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRawAccessChainNV(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupShuffleINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupShuffleINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupShuffleINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InvocationId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupShuffleINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "data")
                Data = o.To<IdRef>();
            if (o.Name == "invocationId")
                InvocationId = o.To<IdRef>();
        }
    }

    public OpSubgroupShuffleINTEL(int resultType, int resultId, int data, int invocationId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Data = data;
        InvocationId = invocationId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupShuffleINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Data.AsSpirvSpan(), ..InvocationId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupShuffleINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupShuffleDownINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupShuffleDownINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupShuffleDownINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Current
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Next
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupShuffleDownINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "current")
                Current = o.To<IdRef>();
            if (o.Name == "next")
                Next = o.To<IdRef>();
            if (o.Name == "delta")
                Delta = o.To<IdRef>();
        }
    }

    public OpSubgroupShuffleDownINTEL(int resultType, int resultId, int current, int next, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Current = current;
        Next = next;
        Delta = delta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupShuffleDownINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Current.AsSpirvSpan(), ..Next.AsSpirvSpan(), ..Delta.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupShuffleDownINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupShuffleUpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupShuffleUpINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupShuffleUpINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Previous
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Current
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupShuffleUpINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "previous")
                Previous = o.To<IdRef>();
            if (o.Name == "current")
                Current = o.To<IdRef>();
            if (o.Name == "delta")
                Delta = o.To<IdRef>();
        }
    }

    public OpSubgroupShuffleUpINTEL(int resultType, int resultId, int previous, int current, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Previous = previous;
        Current = current;
        Delta = delta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupShuffleUpINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Previous.AsSpirvSpan(), ..Current.AsSpirvSpan(), ..Delta.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupShuffleUpINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupShuffleXorINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupShuffleXorINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupShuffleXorINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupShuffleXorINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "data")
                Data = o.To<IdRef>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpSubgroupShuffleXorINTEL(int resultType, int resultId, int data, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Data = data;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupShuffleXorINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Data.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupShuffleXorINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupBlockReadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupBlockReadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockReadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "ptr")
                Ptr = o.To<IdRef>();
        }
    }

    public OpSubgroupBlockReadINTEL(int resultType, int resultId, int ptr)
    {
        ResultType = resultType;
        ResultId = resultId;
        Ptr = ptr;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupBlockReadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Ptr.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockWriteINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "ptr")
                Ptr = o.To<IdRef>();
            if (o.Name == "data")
                Data = o.To<IdRef>();
        }
    }

    public OpSubgroupBlockWriteINTEL(int ptr, int data)
    {
        Ptr = ptr;
        Data = data;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupBlockWriteINTEL, ..Ptr.AsSpirvSpan(), ..Data.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupImageBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupImageBlockReadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupImageBlockReadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageBlockReadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
        }
    }

    public OpSubgroupImageBlockReadINTEL(int resultType, int resultId, int image, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupImageBlockReadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupImageBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupImageBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageBlockWriteINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "data")
                Data = o.To<IdRef>();
        }
    }

    public OpSubgroupImageBlockWriteINTEL(int image, int coordinate, int data)
    {
        Image = image;
        Coordinate = coordinate;
        Data = data;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupImageBlockWriteINTEL, ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Data.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupImageBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupImageMediaBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupImageMediaBlockReadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupImageMediaBlockReadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Height
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageMediaBlockReadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "width")
                Width = o.To<IdRef>();
            if (o.Name == "height")
                Height = o.To<IdRef>();
        }
    }

    public OpSubgroupImageMediaBlockReadINTEL(int resultType, int resultId, int image, int coordinate, int width, int height)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Width = width;
        Height = height;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupImageMediaBlockReadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Width.AsSpirvSpan(), ..Height.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupImageMediaBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupImageMediaBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Height
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageMediaBlockWriteINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "image")
                Image = o.To<IdRef>();
            if (o.Name == "coordinate")
                Coordinate = o.To<IdRef>();
            if (o.Name == "width")
                Width = o.To<IdRef>();
            if (o.Name == "height")
                Height = o.To<IdRef>();
            if (o.Name == "data")
                Data = o.To<IdRef>();
        }
    }

    public OpSubgroupImageMediaBlockWriteINTEL(int image, int coordinate, int width, int height, int data)
    {
        Image = image;
        Coordinate = coordinate;
        Width = width;
        Height = height;
        Data = data;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupImageMediaBlockWriteINTEL, ..Image.AsSpirvSpan(), ..Coordinate.AsSpirvSpan(), ..Width.AsSpirvSpan(), ..Height.AsSpirvSpan(), ..Data.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupImageMediaBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUCountLeadingZerosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUCountLeadingZerosINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUCountLeadingZerosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUCountLeadingZerosINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpUCountLeadingZerosINTEL(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUCountLeadingZerosINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUCountLeadingZerosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUCountTrailingZerosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUCountTrailingZerosINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUCountTrailingZerosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUCountTrailingZerosINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand")
                Operand = o.To<IdRef>();
        }
    }

    public OpUCountTrailingZerosINTEL(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUCountTrailingZerosINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUCountTrailingZerosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAbsISubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAbsISubINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAbsISubINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAbsISubINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpAbsISubINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAbsISubINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAbsISubINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAbsUSubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAbsUSubINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAbsUSubINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAbsUSubINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpAbsUSubINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAbsUSubINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAbsUSubINTEL(OpDataIndex odi) => new(odi);
}

public struct OpIAddSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIAddSatINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIAddSatINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIAddSatINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpIAddSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIAddSatINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAddSatINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUAddSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUAddSatINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUAddSatINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUAddSatINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUAddSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUAddSatINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUAddSatINTEL(OpDataIndex odi) => new(odi);
}

public struct OpIAverageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIAverageINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIAverageINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIAverageINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpIAverageINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIAverageINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAverageINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUAverageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUAverageINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUAverageINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUAverageINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUAverageINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUAverageINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUAverageINTEL(OpDataIndex odi) => new(odi);
}

public struct OpIAverageRoundedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIAverageRoundedINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIAverageRoundedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIAverageRoundedINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpIAverageRoundedINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIAverageRoundedINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIAverageRoundedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUAverageRoundedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUAverageRoundedINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUAverageRoundedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUAverageRoundedINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUAverageRoundedINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUAverageRoundedINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUAverageRoundedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpISubSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpISubSatINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpISubSatINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpISubSatINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpISubSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpISubSatINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpISubSatINTEL(OpDataIndex odi) => new(odi);
}

public struct OpUSubSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUSubSatINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUSubSatINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUSubSatINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUSubSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUSubSatINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUSubSatINTEL(OpDataIndex odi) => new(odi);
}

public struct OpIMul32x16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpIMul32x16INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpIMul32x16INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpIMul32x16INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpIMul32x16INTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpIMul32x16INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpIMul32x16INTEL(OpDataIndex odi) => new(odi);
}

public struct OpUMul32x16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpUMul32x16INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpUMul32x16INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpUMul32x16INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "operand1")
                Operand1 = o.To<IdRef>();
            if (o.Name == "operand2")
                Operand2 = o.To<IdRef>();
        }
    }

    public OpUMul32x16INTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpUMul32x16INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Operand1.AsSpirvSpan(), ..Operand2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpUMul32x16INTEL(OpDataIndex odi) => new(odi);
}

public struct OpFunctionPointerCallINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFunctionPointerCallINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFunctionPointerCallINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpFunctionPointerCallINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpFunctionPointerCallINTEL(int resultType, int resultId, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFunctionPointerCallINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFunctionPointerCallINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAsmTargetINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAsmTargetINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAsmTargetINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Asmtarget
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAsmTargetINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "asmtarget")
                Asmtarget = o.To<LiteralString>();
        }
    }

    public OpAsmTargetINTEL(int resultType, int resultId, LiteralString asmtarget)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asmtarget = asmtarget;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAsmTargetINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Asmtarget.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAsmTargetINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAsmINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAsmINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAsmINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Asmtype
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Asminstructions
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralString Constraints
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAsmINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "asmtype")
                Asmtype = o.To<IdRef>();
            if (o.Name == "target")
                Target = o.To<IdRef>();
            if (o.Name == "asminstructions")
                Asminstructions = o.To<LiteralString>();
            if (o.Name == "constraints")
                Constraints = o.To<LiteralString>();
        }
    }

    public OpAsmINTEL(int resultType, int resultId, int asmtype, int target, LiteralString asminstructions, LiteralString constraints)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asmtype = asmtype;
        Target = target;
        Asminstructions = asminstructions;
        Constraints = constraints;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAsmINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Asmtype.AsSpirvSpan(), ..Target.AsSpirvSpan(), ..Asminstructions.AsSpirvSpan(), ..Constraints.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAsmINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAsmCallINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAsmCallINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAsmCallINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Asm
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpAsmCallINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "asm")
                Asm = o.To<IdRef>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpAsmCallINTEL(int resultType, int resultId, int asm, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asm = asm;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAsmCallINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Asm.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAsmCallINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFMinEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicFMinEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicFMinEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicFMinEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicFMinEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicFMinEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFMinEXT(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFMaxEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicFMaxEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicFMaxEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicFMaxEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicFMaxEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicFMaxEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFMaxEXT(OpDataIndex odi) => new(odi);
}

public struct OpAssumeTrueKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAssumeTrueKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "condition")
                Condition = o.To<IdRef>();
        }
    }

    public OpAssumeTrueKHR(int condition)
    {
        Condition = condition;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAssumeTrueKHR, ..Condition.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAssumeTrueKHR(OpDataIndex odi) => new(odi);
}

public struct OpExpectKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpExpectKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpExpectKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ExpectedValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpExpectKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
            if (o.Name == "expectedValue")
                ExpectedValue = o.To<IdRef>();
        }
    }

    public OpExpectKHR(int resultType, int resultId, int value, int expectedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        ExpectedValue = expectedValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExpectKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Value.AsSpirvSpan(), ..ExpectedValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpExpectKHR(OpDataIndex odi) => new(odi);
}

public struct OpDecorateString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpDecorateString(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "target")
                Target = o.To<IdRef>();
            if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
        }
    }

    public OpDecorateString(int target, Decoration decoration)
    {
        Target = target;
        Decoration = decoration;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpDecorateString, ..Target.AsSpirvSpan(), ..Decoration.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpDecorateString(OpDataIndex odi) => new(odi);
}

public struct OpMemberDecorateString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int StructType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMemberDecorateString(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "structType")
                StructType = o.To<IdRef>();
            if (o.Name == "member")
                Member = o.To<LiteralInteger>();
            if (o.Name == "decoration")
                Decoration = o.ToEnum<Decoration>();
        }
    }

    public OpMemberDecorateString(int structType, int member, Decoration decoration)
    {
        StructType = structType;
        Member = member;
        Decoration = decoration;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMemberDecorateString, ..StructType.AsSpirvSpan(), ..Member.AsSpirvSpan(), ..Decoration.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMemberDecorateString(OpDataIndex odi) => new(odi);
}

public struct OpVmeImageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpVmeImageINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpVmeImageINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Sampler
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpVmeImageINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "imageType")
                ImageType = o.To<IdRef>();
            if (o.Name == "sampler")
                Sampler = o.To<IdRef>();
        }
    }

    public OpVmeImageINTEL(int resultType, int resultId, int imageType, int sampler)
    {
        ResultType = resultType;
        ResultId = resultId;
        ImageType = imageType;
        Sampler = sampler;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpVmeImageINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ImageType.AsSpirvSpan(), ..Sampler.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVmeImageINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeVmeImageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeVmeImageINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeVmeImageINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeVmeImageINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "imageType")
                ImageType = o.To<IdRef>();
        }
    }

    public OpTypeVmeImageINTEL(int resultId, int imageType)
    {
        ResultId = resultId;
        ImageType = imageType;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeVmeImageINTEL, ..ResultId.AsSpirvSpan(), ..ImageType.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeVmeImageINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcImePayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcImePayloadINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImePayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcImePayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcImePayloadINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcRefPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcRefPayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcRefPayloadINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcRefPayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcRefPayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcRefPayloadINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcRefPayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcSicPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcSicPayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcSicPayloadINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcSicPayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcSicPayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcSicPayloadINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcSicPayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcMcePayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcMcePayloadINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcMcePayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcMcePayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcMcePayloadINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcMceResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcMceResultINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcMceResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcMceResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcMceResultINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcMceResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcImeResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeResultINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcImeResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcImeResultINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeResultSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcImeResultSingleReferenceStreamoutINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeResultSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcImeResultSingleReferenceStreamoutINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeResultDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcImeResultDualReferenceStreamoutINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeResultDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcImeResultDualReferenceStreamoutINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcImeSingleReferenceStreaminINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcImeSingleReferenceStreaminINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcImeDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcImeDualReferenceStreaminINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcImeDualReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcImeDualReferenceStreaminINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcImeDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcRefResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcRefResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcRefResultINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcRefResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcRefResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcRefResultINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcRefResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeAvcSicResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeAvcSicResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeAvcSicResultINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeAvcSicResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpTypeAvcSicResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeAvcSicResultINTEL, ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeAvcSicResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sliceType")
                SliceType = o.To<IdRef>();
            if (o.Name == "qp")
                Qp = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SliceType.AsSpirvSpan(), ..Qp.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceBasePenalty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "referenceBasePenalty")
                ReferenceBasePenalty = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(int resultType, int resultId, int referenceBasePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReferenceBasePenalty = referenceBasePenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ReferenceBasePenalty.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sliceType")
                SliceType = o.To<IdRef>();
            if (o.Name == "qp")
                Qp = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SliceType.AsSpirvSpan(), ..Qp.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetInterShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceSetInterShapePenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetInterShapePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedShapePenalty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "packedShapePenalty")
                PackedShapePenalty = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(int resultType, int resultId, int packedShapePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedShapePenalty = packedShapePenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceSetInterShapePenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PackedShapePenalty.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sliceType")
                SliceType = o.To<IdRef>();
            if (o.Name == "qp")
                Qp = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SliceType.AsSpirvSpan(), ..Qp.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetInterDirectionPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceSetInterDirectionPenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetInterDirectionPenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int DirectionCost
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "directionCost")
                DirectionCost = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(int resultType, int resultId, int directionCost, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        DirectionCost = directionCost;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..DirectionCost.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sliceType")
                SliceType = o.To<IdRef>();
            if (o.Name == "qp")
                Qp = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SliceType.AsSpirvSpan(), ..Qp.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sliceType")
                SliceType = o.To<IdRef>();
            if (o.Name == "qp")
                Qp = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SliceType.AsSpirvSpan(), ..Qp.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedCostCenterDelta
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedCostTable
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int CostPrecision
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "packedCostCenterDelta")
                PackedCostCenterDelta = o.To<IdRef>();
            if (o.Name == "packedCostTable")
                PackedCostTable = o.To<IdRef>();
            if (o.Name == "costPrecision")
                CostPrecision = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(int resultType, int resultId, int packedCostCenterDelta, int packedCostTable, int costPrecision, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedCostCenterDelta = packedCostCenterDelta;
        PackedCostTable = packedCostTable;
        CostPrecision = costPrecision;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PackedCostCenterDelta.AsSpirvSpan(), ..PackedCostTable.AsSpirvSpan(), ..CostPrecision.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sliceType")
                SliceType = o.To<IdRef>();
            if (o.Name == "qp")
                Qp = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SliceType.AsSpirvSpan(), ..Qp.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetAcOnlyHaarINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceSetAcOnlyHaarINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetAcOnlyHaarINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceSetAcOnlyHaarINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SourceFieldPolarity
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "sourceFieldPolarity")
                SourceFieldPolarity = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(int resultType, int resultId, int sourceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SourceFieldPolarity = sourceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SourceFieldPolarity.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "referenceFieldPolarity")
                ReferenceFieldPolarity = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(int resultType, int resultId, int referenceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReferenceFieldPolarity = referenceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ReferenceFieldPolarity.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ForwardReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BackwardReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "forwardReferenceFieldPolarity")
                ForwardReferenceFieldPolarity = o.To<IdRef>();
            if (o.Name == "backwardReferenceFieldPolarity")
                BackwardReferenceFieldPolarity = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(int resultType, int resultId, int forwardReferenceFieldPolarity, int backwardReferenceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ForwardReferenceFieldPolarity = forwardReferenceFieldPolarity;
        BackwardReferenceFieldPolarity = backwardReferenceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ForwardReferenceFieldPolarity.AsSpirvSpan(), ..BackwardReferenceFieldPolarity.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToImePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceConvertToImePayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToImePayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceConvertToImePayloadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToImePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToImeResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceConvertToImeResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToImeResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceConvertToImeResultINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToImeResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToRefPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceConvertToRefPayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToRefPayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceConvertToRefPayloadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToRefPayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToRefResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceConvertToRefResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToRefResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceConvertToRefResultINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToRefResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToSicPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceConvertToSicPayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToSicPayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceConvertToSicPayloadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToSicPayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceConvertToSicResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceConvertToSicResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceConvertToSicResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceConvertToSicResultINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToSicResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetMotionVectorsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetMotionVectorsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetMotionVectorsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetInterDistortionsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterDistortionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetInterDistortionsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetBestInterDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetBestInterDistortionsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetBestInterDistortionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetBestInterDistortionsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterMajorShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetInterMajorShapeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterMajorShapeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetInterMajorShapeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMajorShapeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterMinorShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetInterMinorShapeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterMinorShapeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetInterMinorShapeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMinorShapeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterDirectionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetInterDirectionsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterDirectionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetInterDirectionsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterDirectionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterMotionVectorCountINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetInterMotionVectorCountINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterMotionVectorCountINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetInterMotionVectorCountINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetInterReferenceIdsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterReferenceIdsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetInterReferenceIdsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedReferenceParameterFieldPolarities
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.To<IdRef>();
            if (o.Name == "packedReferenceParameterFieldPolarities")
                PackedReferenceParameterFieldPolarities = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(int resultType, int resultId, int packedReferenceIds, int packedReferenceParameterFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceParameterFieldPolarities = packedReferenceParameterFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PackedReferenceIds.AsSpirvSpan(), ..PackedReferenceParameterFieldPolarities.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeInitializeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeInitializeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PartitionMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SADAdjustment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeInitializeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcCoord")
                SrcCoord = o.To<IdRef>();
            if (o.Name == "partitionMask")
                PartitionMask = o.To<IdRef>();
            if (o.Name == "sADAdjustment")
                SADAdjustment = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeInitializeINTEL(int resultType, int resultId, int srcCoord, int partitionMask, int sADAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        PartitionMask = partitionMask;
        SADAdjustment = sADAdjustment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeInitializeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcCoord.AsSpirvSpan(), ..PartitionMask.AsSpirvSpan(), ..SADAdjustment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeSetSingleReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetSingleReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SearchWindowConfig
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "refOffset")
                RefOffset = o.To<IdRef>();
            if (o.Name == "searchWindowConfig")
                SearchWindowConfig = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL(int resultType, int resultId, int refOffset, int searchWindowConfig, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        RefOffset = refOffset;
        SearchWindowConfig = searchWindowConfig;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeSetSingleReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RefOffset.AsSpirvSpan(), ..SearchWindowConfig.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeSetDualReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetDualReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FwdRefOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BwdRefOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int IdSearchWindowConfig
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "fwdRefOffset")
                FwdRefOffset = o.To<IdRef>();
            if (o.Name == "bwdRefOffset")
                BwdRefOffset = o.To<IdRef>();
            if (o.Name == "idSearchWindowConfig")
                IdSearchWindowConfig = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL(int resultType, int resultId, int fwdRefOffset, int bwdRefOffset, int idSearchWindowConfig, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        FwdRefOffset = fwdRefOffset;
        BwdRefOffset = bwdRefOffset;
        IdSearchWindowConfig = idSearchWindowConfig;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeSetDualReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..FwdRefOffset.AsSpirvSpan(), ..BwdRefOffset.AsSpirvSpan(), ..IdSearchWindowConfig.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeRefWindowSizeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeRefWindowSizeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeRefWindowSizeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SearchWindowConfig
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int DualRef
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "searchWindowConfig")
                SearchWindowConfig = o.To<IdRef>();
            if (o.Name == "dualRef")
                DualRef = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL(int resultType, int resultId, int searchWindowConfig, int dualRef)
    {
        ResultType = resultType;
        ResultId = resultId;
        SearchWindowConfig = searchWindowConfig;
        DualRef = dualRef;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeRefWindowSizeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SearchWindowConfig.AsSpirvSpan(), ..DualRef.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeRefWindowSizeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeAdjustRefOffsetINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeAdjustRefOffsetINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeAdjustRefOffsetINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefOffset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefWindowSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ImageSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "refOffset")
                RefOffset = o.To<IdRef>();
            if (o.Name == "srcCoord")
                SrcCoord = o.To<IdRef>();
            if (o.Name == "refWindowSize")
                RefWindowSize = o.To<IdRef>();
            if (o.Name == "imageSize")
                ImageSize = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL(int resultType, int resultId, int refOffset, int srcCoord, int refWindowSize, int imageSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        RefOffset = refOffset;
        SrcCoord = srcCoord;
        RefWindowSize = refWindowSize;
        ImageSize = imageSize;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeAdjustRefOffsetINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RefOffset.AsSpirvSpan(), ..SrcCoord.AsSpirvSpan(), ..RefWindowSize.AsSpirvSpan(), ..ImageSize.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeAdjustRefOffsetINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeConvertToMcePayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeConvertToMcePayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeConvertToMcePayloadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetMaxMotionVectorCountINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeSetMaxMotionVectorCountINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetMaxMotionVectorCountINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MaxMotionVectorCount
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "maxMotionVectorCount")
                MaxMotionVectorCount = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(int resultType, int resultId, int maxMotionVectorCount, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        MaxMotionVectorCount = maxMotionVectorCount;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..MaxMotionVectorCount.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Threshold
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "threshold")
                Threshold = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(int resultType, int resultId, int threshold, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Threshold = threshold;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Threshold.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeSetWeightedSadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeSetWeightedSadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeSetWeightedSadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedSadWeights
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "packedSadWeights")
                PackedSadWeights = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL(int resultType, int resultId, int packedSadWeights, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedSadWeights = packedSadWeights;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeSetWeightedSadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PackedSadWeights.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeSetWeightedSadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "refImage")
                RefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..RefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeEvaluateWithDualReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "fwdRefImage")
                FwdRefImage = o.To<IdRef>();
            if (o.Name == "bwdRefImage")
                BwdRefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..FwdRefImage.AsSpirvSpan(), ..BwdRefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "refImage")
                RefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "streaminComponents")
                StreaminComponents = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(int resultType, int resultId, int srcImage, int refImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..RefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..StreaminComponents.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "fwdRefImage")
                FwdRefImage = o.To<IdRef>();
            if (o.Name == "bwdRefImage")
                BwdRefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "streaminComponents")
                StreaminComponents = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..FwdRefImage.AsSpirvSpan(), ..BwdRefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..StreaminComponents.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "refImage")
                RefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..RefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "fwdRefImage")
                FwdRefImage = o.To<IdRef>();
            if (o.Name == "bwdRefImage")
                BwdRefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..FwdRefImage.AsSpirvSpan(), ..BwdRefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "refImage")
                RefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "streaminComponents")
                StreaminComponents = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(int resultType, int resultId, int srcImage, int refImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..RefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..StreaminComponents.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "fwdRefImage")
                FwdRefImage = o.To<IdRef>();
            if (o.Name == "bwdRefImage")
                BwdRefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "streaminComponents")
                StreaminComponents = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..FwdRefImage.AsSpirvSpan(), ..BwdRefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..StreaminComponents.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeConvertToMceResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeConvertToMceResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeConvertToMceResultINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetSingleReferenceStreaminINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetDualReferenceStreaminINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetDualReferenceStreaminINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetDualReferenceStreaminINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeStripDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeStripDualReferenceStreamoutINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeStripDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "majorShape")
                MajorShape = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..MajorShape.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "majorShape")
                MajorShape = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..MajorShape.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "majorShape")
                MajorShape = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..MajorShape.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "majorShape")
                MajorShape = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..MajorShape.AsSpirvSpan(), ..Direction.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "majorShape")
                MajorShape = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..MajorShape.AsSpirvSpan(), ..Direction.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
            if (o.Name == "majorShape")
                MajorShape = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan(), ..MajorShape.AsSpirvSpan(), ..Direction.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetBorderReachedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetBorderReachedINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetBorderReachedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ImageSelect
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "imageSelect")
                ImageSelect = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL(int resultType, int resultId, int imageSelect, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ImageSelect = imageSelect;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetBorderReachedINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ImageSelect.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetBorderReachedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcFmeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcFmeInitializeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcFmeInitializeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MajorShapes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MinorShapes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PixelResolution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcFmeInitializeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcCoord")
                SrcCoord = o.To<IdRef>();
            if (o.Name == "motionVectors")
                MotionVectors = o.To<IdRef>();
            if (o.Name == "majorShapes")
                MajorShapes = o.To<IdRef>();
            if (o.Name == "minorShapes")
                MinorShapes = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "pixelResolution")
                PixelResolution = o.To<IdRef>();
            if (o.Name == "sadAdjustment")
                SadAdjustment = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcFmeInitializeINTEL(int resultType, int resultId, int srcCoord, int motionVectors, int majorShapes, int minorShapes, int direction, int pixelResolution, int sadAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        MotionVectors = motionVectors;
        MajorShapes = majorShapes;
        MinorShapes = minorShapes;
        Direction = direction;
        PixelResolution = pixelResolution;
        SadAdjustment = sadAdjustment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcFmeInitializeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcCoord.AsSpirvSpan(), ..MotionVectors.AsSpirvSpan(), ..MajorShapes.AsSpirvSpan(), ..MinorShapes.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..PixelResolution.AsSpirvSpan(), ..SadAdjustment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcFmeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcBmeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcBmeInitializeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcBmeInitializeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MajorShapes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MinorShapes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PixelResolution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BidirectionalWeight
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcBmeInitializeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcCoord")
                SrcCoord = o.To<IdRef>();
            if (o.Name == "motionVectors")
                MotionVectors = o.To<IdRef>();
            if (o.Name == "majorShapes")
                MajorShapes = o.To<IdRef>();
            if (o.Name == "minorShapes")
                MinorShapes = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
            if (o.Name == "pixelResolution")
                PixelResolution = o.To<IdRef>();
            if (o.Name == "bidirectionalWeight")
                BidirectionalWeight = o.To<IdRef>();
            if (o.Name == "sadAdjustment")
                SadAdjustment = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcBmeInitializeINTEL(int resultType, int resultId, int srcCoord, int motionVectors, int majorShapes, int minorShapes, int direction, int pixelResolution, int bidirectionalWeight, int sadAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        MotionVectors = motionVectors;
        MajorShapes = majorShapes;
        MinorShapes = minorShapes;
        Direction = direction;
        PixelResolution = pixelResolution;
        BidirectionalWeight = bidirectionalWeight;
        SadAdjustment = sadAdjustment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcBmeInitializeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcCoord.AsSpirvSpan(), ..MotionVectors.AsSpirvSpan(), ..MajorShapes.AsSpirvSpan(), ..MinorShapes.AsSpirvSpan(), ..Direction.AsSpirvSpan(), ..PixelResolution.AsSpirvSpan(), ..BidirectionalWeight.AsSpirvSpan(), ..SadAdjustment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcBmeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcRefConvertToMcePayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefConvertToMcePayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcRefConvertToMcePayloadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefSetBidirectionalMixDisableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcRefSetBidirectionalMixDisableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefSetBidirectionalMixDisableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefSetBilinearFilterEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcRefSetBilinearFilterEnableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefSetBilinearFilterEnableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcRefSetBilinearFilterEnableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "refImage")
                RefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..RefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcRefEvaluateWithDualReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "fwdRefImage")
                FwdRefImage = o.To<IdRef>();
            if (o.Name == "bwdRefImage")
                BwdRefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..FwdRefImage.AsSpirvSpan(), ..BwdRefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..PackedReferenceIds.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedReferenceFieldPolarities
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.To<IdRef>();
            if (o.Name == "packedReferenceFieldPolarities")
                PackedReferenceFieldPolarities = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int packedReferenceFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceFieldPolarities = packedReferenceFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..PackedReferenceIds.AsSpirvSpan(), ..PackedReferenceFieldPolarities.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcRefConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcRefConvertToMceResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcRefConvertToMceResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcRefConvertToMceResultINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcRefConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicInitializeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicInitializeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicInitializeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcCoord")
                SrcCoord = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicInitializeINTEL(int resultType, int resultId, int srcCoord)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicInitializeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcCoord.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicInitializeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConfigureSkcINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicConfigureSkcINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConfigureSkcINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SkipBlockPartitionType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SkipMotionVectorMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BidirectionalWeight
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConfigureSkcINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "skipBlockPartitionType")
                SkipBlockPartitionType = o.To<IdRef>();
            if (o.Name == "skipMotionVectorMask")
                SkipMotionVectorMask = o.To<IdRef>();
            if (o.Name == "motionVectors")
                MotionVectors = o.To<IdRef>();
            if (o.Name == "bidirectionalWeight")
                BidirectionalWeight = o.To<IdRef>();
            if (o.Name == "sadAdjustment")
                SadAdjustment = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicConfigureSkcINTEL(int resultType, int resultId, int skipBlockPartitionType, int skipMotionVectorMask, int motionVectors, int bidirectionalWeight, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SkipBlockPartitionType = skipBlockPartitionType;
        SkipMotionVectorMask = skipMotionVectorMask;
        MotionVectors = motionVectors;
        BidirectionalWeight = bidirectionalWeight;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicConfigureSkcINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SkipBlockPartitionType.AsSpirvSpan(), ..SkipMotionVectorMask.AsSpirvSpan(), ..MotionVectors.AsSpirvSpan(), ..BidirectionalWeight.AsSpirvSpan(), ..SadAdjustment.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureSkcINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConfigureIpeLumaINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicConfigureIpeLumaINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConfigureIpeLumaINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LumaIntraPartitionMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int IntraNeighbourAvailabilty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LeftEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerLumaPixel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UpperEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UpperRightEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "lumaIntraPartitionMask")
                LumaIntraPartitionMask = o.To<IdRef>();
            if (o.Name == "intraNeighbourAvailabilty")
                IntraNeighbourAvailabilty = o.To<IdRef>();
            if (o.Name == "leftEdgeLumaPixels")
                LeftEdgeLumaPixels = o.To<IdRef>();
            if (o.Name == "upperLeftCornerLumaPixel")
                UpperLeftCornerLumaPixel = o.To<IdRef>();
            if (o.Name == "upperEdgeLumaPixels")
                UpperEdgeLumaPixels = o.To<IdRef>();
            if (o.Name == "upperRightEdgeLumaPixels")
                UpperRightEdgeLumaPixels = o.To<IdRef>();
            if (o.Name == "sadAdjustment")
                SadAdjustment = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL(int resultType, int resultId, int lumaIntraPartitionMask, int intraNeighbourAvailabilty, int leftEdgeLumaPixels, int upperLeftCornerLumaPixel, int upperEdgeLumaPixels, int upperRightEdgeLumaPixels, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaIntraPartitionMask = lumaIntraPartitionMask;
        IntraNeighbourAvailabilty = intraNeighbourAvailabilty;
        LeftEdgeLumaPixels = leftEdgeLumaPixels;
        UpperLeftCornerLumaPixel = upperLeftCornerLumaPixel;
        UpperEdgeLumaPixels = upperEdgeLumaPixels;
        UpperRightEdgeLumaPixels = upperRightEdgeLumaPixels;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicConfigureIpeLumaINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..LumaIntraPartitionMask.AsSpirvSpan(), ..IntraNeighbourAvailabilty.AsSpirvSpan(), ..LeftEdgeLumaPixels.AsSpirvSpan(), ..UpperLeftCornerLumaPixel.AsSpirvSpan(), ..UpperEdgeLumaPixels.AsSpirvSpan(), ..UpperRightEdgeLumaPixels.AsSpirvSpan(), ..SadAdjustment.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConfigureIpeLumaChromaINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicConfigureIpeLumaChromaINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConfigureIpeLumaChromaINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LumaIntraPartitionMask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int IntraNeighbourAvailabilty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LeftEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerLumaPixel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UpperEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UpperRightEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LeftEdgeChromaPixels
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerChromaPixel
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int UpperEdgeChromaPixels
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "lumaIntraPartitionMask")
                LumaIntraPartitionMask = o.To<IdRef>();
            if (o.Name == "intraNeighbourAvailabilty")
                IntraNeighbourAvailabilty = o.To<IdRef>();
            if (o.Name == "leftEdgeLumaPixels")
                LeftEdgeLumaPixels = o.To<IdRef>();
            if (o.Name == "upperLeftCornerLumaPixel")
                UpperLeftCornerLumaPixel = o.To<IdRef>();
            if (o.Name == "upperEdgeLumaPixels")
                UpperEdgeLumaPixels = o.To<IdRef>();
            if (o.Name == "upperRightEdgeLumaPixels")
                UpperRightEdgeLumaPixels = o.To<IdRef>();
            if (o.Name == "leftEdgeChromaPixels")
                LeftEdgeChromaPixels = o.To<IdRef>();
            if (o.Name == "upperLeftCornerChromaPixel")
                UpperLeftCornerChromaPixel = o.To<IdRef>();
            if (o.Name == "upperEdgeChromaPixels")
                UpperEdgeChromaPixels = o.To<IdRef>();
            if (o.Name == "sadAdjustment")
                SadAdjustment = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(int resultType, int resultId, int lumaIntraPartitionMask, int intraNeighbourAvailabilty, int leftEdgeLumaPixels, int upperLeftCornerLumaPixel, int upperEdgeLumaPixels, int upperRightEdgeLumaPixels, int leftEdgeChromaPixels, int upperLeftCornerChromaPixel, int upperEdgeChromaPixels, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaIntraPartitionMask = lumaIntraPartitionMask;
        IntraNeighbourAvailabilty = intraNeighbourAvailabilty;
        LeftEdgeLumaPixels = leftEdgeLumaPixels;
        UpperLeftCornerLumaPixel = upperLeftCornerLumaPixel;
        UpperEdgeLumaPixels = upperEdgeLumaPixels;
        UpperRightEdgeLumaPixels = upperRightEdgeLumaPixels;
        LeftEdgeChromaPixels = leftEdgeChromaPixels;
        UpperLeftCornerChromaPixel = upperLeftCornerChromaPixel;
        UpperEdgeChromaPixels = upperEdgeChromaPixels;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..LumaIntraPartitionMask.AsSpirvSpan(), ..IntraNeighbourAvailabilty.AsSpirvSpan(), ..LeftEdgeLumaPixels.AsSpirvSpan(), ..UpperLeftCornerLumaPixel.AsSpirvSpan(), ..UpperEdgeLumaPixels.AsSpirvSpan(), ..UpperRightEdgeLumaPixels.AsSpirvSpan(), ..LeftEdgeChromaPixels.AsSpirvSpan(), ..UpperLeftCornerChromaPixel.AsSpirvSpan(), ..UpperEdgeChromaPixels.AsSpirvSpan(), ..SadAdjustment.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetMotionVectorMaskINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetMotionVectorMaskINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetMotionVectorMaskINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SkipBlockPartitionType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "skipBlockPartitionType")
                SkipBlockPartitionType = o.To<IdRef>();
            if (o.Name == "direction")
                Direction = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(int resultType, int resultId, int skipBlockPartitionType, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        SkipBlockPartitionType = skipBlockPartitionType;
        Direction = direction;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetMotionVectorMaskINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SkipBlockPartitionType.AsSpirvSpan(), ..Direction.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicConvertToMcePayloadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConvertToMcePayloadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicConvertToMcePayloadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedShapePenalty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "packedShapePenalty")
                PackedShapePenalty = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(int resultType, int resultId, int packedShapePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedShapePenalty = packedShapePenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PackedShapePenalty.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LumaModePenalty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LumaPackedNeighborModes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int LumaPackedNonDcPenalty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "lumaModePenalty")
                LumaModePenalty = o.To<IdRef>();
            if (o.Name == "lumaPackedNeighborModes")
                LumaPackedNeighborModes = o.To<IdRef>();
            if (o.Name == "lumaPackedNonDcPenalty")
                LumaPackedNonDcPenalty = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(int resultType, int resultId, int lumaModePenalty, int lumaPackedNeighborModes, int lumaPackedNonDcPenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaModePenalty = lumaModePenalty;
        LumaPackedNeighborModes = lumaPackedNeighborModes;
        LumaPackedNonDcPenalty = lumaPackedNonDcPenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..LumaModePenalty.AsSpirvSpan(), ..LumaPackedNeighborModes.AsSpirvSpan(), ..LumaPackedNonDcPenalty.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ChromaModeBasePenalty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "chromaModeBasePenalty")
                ChromaModeBasePenalty = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(int resultType, int resultId, int chromaModeBasePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ChromaModeBasePenalty = chromaModeBasePenalty;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..ChromaModeBasePenalty.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetBilinearFilterEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicSetBilinearFilterEnableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetBilinearFilterEnableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicSetBilinearFilterEnableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedSadCoefficients
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "packedSadCoefficients")
                PackedSadCoefficients = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(int resultType, int resultId, int packedSadCoefficients, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedSadCoefficients = packedSadCoefficients;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PackedSadCoefficients.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BlockBasedSkipType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "blockBasedSkipType")
                BlockBasedSkipType = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(int resultType, int resultId, int blockBasedSkipType, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        BlockBasedSkipType = blockBasedSkipType;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BlockBasedSkipType.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateIpeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicEvaluateIpeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateIpeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL(int resultType, int resultId, int srcImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicEvaluateIpeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateIpeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "refImage")
                RefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..RefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicEvaluateWithDualReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "fwdRefImage")
                FwdRefImage = o.To<IdRef>();
            if (o.Name == "bwdRefImage")
                BwdRefImage = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..FwdRefImage.AsSpirvSpan(), ..BwdRefImage.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..PackedReferenceIds.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PackedReferenceFieldPolarities
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "srcImage")
                SrcImage = o.To<IdRef>();
            if (o.Name == "packedReferenceIds")
                PackedReferenceIds = o.To<IdRef>();
            if (o.Name == "packedReferenceFieldPolarities")
                PackedReferenceFieldPolarities = o.To<IdRef>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int packedReferenceFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceFieldPolarities = packedReferenceFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..SrcImage.AsSpirvSpan(), ..PackedReferenceIds.AsSpirvSpan(), ..PackedReferenceFieldPolarities.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicConvertToMceResultINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicConvertToMceResultINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicConvertToMceResultINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetIpeLumaShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetIpeLumaShapeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetIpeLumaShapeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetIpeLumaShapeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetPackedIpeLumaModesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetPackedIpeLumaModesINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetPackedIpeLumaModesINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetIpeChromaModeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetIpeChromaModeINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetIpeChromaModeINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetIpeChromaModeINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetIpeChromaModeINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupAvcSicGetInterRawSadsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSubgroupAvcSicGetInterRawSadsINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSubgroupAvcSicGetInterRawSadsINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "payload")
                Payload = o.To<IdRef>();
        }
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupAvcSicGetInterRawSadsINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Payload.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupAvcSicGetInterRawSadsINTEL(OpDataIndex odi) => new(odi);
}

public struct OpVariableLengthArrayINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpVariableLengthArrayINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpVariableLengthArrayINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Lenght
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpVariableLengthArrayINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "lenght")
                Lenght = o.To<IdRef>();
        }
    }

    public OpVariableLengthArrayINTEL(int resultType, int resultId, int lenght)
    {
        ResultType = resultType;
        ResultId = resultId;
        Lenght = lenght;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpVariableLengthArrayINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Lenght.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpVariableLengthArrayINTEL(OpDataIndex odi) => new(odi);
}

public struct OpSaveMemoryINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpSaveMemoryINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpSaveMemoryINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSaveMemoryINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
        }
    }

    public OpSaveMemoryINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSaveMemoryINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSaveMemoryINTEL(OpDataIndex odi) => new(odi);
}

public struct OpRestoreMemoryINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRestoreMemoryINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "ptr")
                Ptr = o.To<IdRef>();
        }
    }

    public OpRestoreMemoryINTEL(int ptr)
    {
        Ptr = ptr;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRestoreMemoryINTEL, ..Ptr.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRestoreMemoryINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSinCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatSinCosPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSinCosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FromSign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSinCosPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "fromSign")
                FromSign = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatSinCosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int fromSign, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        FromSign = fromSign;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatSinCosPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..FromSign.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSinCosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCastINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatCastINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCastINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCastINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatCastINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatCastINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCastINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCastFromIntINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatCastFromIntINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCastFromIntINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FromSign
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCastFromIntINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "fromSign")
                FromSign = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatCastFromIntINTEL(int resultType, int resultId, int a, int mout, int fromSign, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        Mout = mout;
        FromSign = fromSign;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatCastFromIntINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..FromSign.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCastFromIntINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCastToIntINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatCastToIntINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCastToIntINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCastToIntINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatCastToIntINTEL(int resultType, int resultId, int a, int m1, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatCastToIntINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCastToIntINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatAddINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatAddINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatAddINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatAddINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatAddINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatAddINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatAddINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatSubINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSubINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSubINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatSubINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatSubINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSubINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatMulINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatMulINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatMulINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatMulINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatMulINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatMulINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatMulINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatDivINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatDivINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatDivINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatDivINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatDivINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatDivINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatDivINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatGTINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatGTINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatGTINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatGTINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatGTINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatGTINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatGTINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatGEINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatGEINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatGEINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatGEINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatGEINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatGEINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatGEINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLTINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatLTINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLTINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLTINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatLTINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatLTINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLTINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLEINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatLEINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLEINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLEINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatLEINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatLEINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLEINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatEQINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatEQINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatEQINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatEQINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatEQINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatEQINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatEQINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatRecipINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatRecipINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatRecipINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatRecipINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatRecipINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatRecipINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatRecipINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatRSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatRSqrtINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatRSqrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatRSqrtINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatRSqrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatRSqrtINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatRSqrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCbrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatCbrtINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCbrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCbrtINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatCbrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatCbrtINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCbrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatHypotINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatHypotINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatHypotINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatHypotINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatHypotINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatHypotINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatHypotINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatSqrtINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSqrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSqrtINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatSqrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatSqrtINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSqrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLogINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatLogINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLogINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLogINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatLogINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatLogINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLogINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLog2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatLog2INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLog2INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLog2INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatLog2INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatLog2INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLog2INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLog10INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatLog10INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLog10INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLog10INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatLog10INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatLog10INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLog10INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatLog1pINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatLog1pINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatLog1pINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatLog1pINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatLog1pINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatLog1pINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatLog1pINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatExpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatExpINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatExpINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatExpINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatExpINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatExpINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatExpINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatExp2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatExp2INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatExp2INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatExp2INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatExp2INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatExp2INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatExp2INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatExp10INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatExp10INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatExp10INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatExp10INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatExp10INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatExp10INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatExp10INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatExpm1INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatExpm1INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatExpm1INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatExpm1INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatExpm1INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatExpm1INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatExpm1INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatSinINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSinINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSinINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatSinINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatSinINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSinINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatCosINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCosINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatCosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatCosINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSinCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatSinCosINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSinCosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSinCosINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatSinCosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatSinCosINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSinCosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatSinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatSinPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatSinPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatSinPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatSinPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatSinPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatSinPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatCosPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatCosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatCosPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatCosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatCosPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatCosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatASinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatASinINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatASinINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatASinINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatASinINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatASinINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatASinINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatASinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatASinPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatASinPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatASinPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatASinPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatASinPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatASinPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatACosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatACosINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatACosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatACosINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatACosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatACosINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatACosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatACosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatACosPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatACosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatACosPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatACosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatACosPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatACosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatATanINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatATanINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatATanINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatATanINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatATanINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatATanINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatATanINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatATanPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatATanPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatATanPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatATanPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatATanPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatATanPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatATanPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatATan2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatATan2INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatATan2INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatATan2INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatATan2INTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatATan2INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatATan2INTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatPowINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatPowINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatPowINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatPowINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatPowINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatPowINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatPowINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatPowRINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatPowRINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatPowRINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatPowRINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "m2")
                M2 = o.To<LiteralInteger>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatPowRINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatPowRINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..M2.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatPowRINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArbitraryFloatPowNINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArbitraryFloatPowNINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArbitraryFloatPowNINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArbitraryFloatPowNINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "m1")
                M1 = o.To<LiteralInteger>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "mout")
                Mout = o.To<LiteralInteger>();
            if (o.Name == "enableSubnormals")
                EnableSubnormals = o.To<LiteralInteger>();
            if (o.Name == "roundingMode")
                RoundingMode = o.To<LiteralInteger>();
            if (o.Name == "roundingAccuracy")
                RoundingAccuracy = o.To<LiteralInteger>();
        }
    }

    public OpArbitraryFloatPowNINTEL(int resultType, int resultId, int a, int m1, int b, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArbitraryFloatPowNINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..A.AsSpirvSpan(), ..M1.AsSpirvSpan(), ..B.AsSpirvSpan(), ..Mout.AsSpirvSpan(), ..EnableSubnormals.AsSpirvSpan(), ..RoundingMode.AsSpirvSpan(), ..RoundingAccuracy.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArbitraryFloatPowNINTEL(OpDataIndex odi) => new(odi);
}

public struct OpLoopControlINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public LiteralArray<LiteralInteger> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpLoopControlINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "values")
                Values = o.To<LiteralArray<LiteralInteger>>();
        }
    }

    public OpLoopControlINTEL(LiteralArray<LiteralInteger> values)
    {
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpLoopControlINTEL, ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpLoopControlINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAliasDomainDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAliasDomainDeclINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAliasDomainDeclINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Name
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAliasDomainDeclINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "name")
                Name = o.To<IdRef>();
        }
    }

    public OpAliasDomainDeclINTEL(int resultId, int? name)
    {
        ResultId = resultId;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAliasDomainDeclINTEL, ..ResultId.AsSpirvSpan(), ..Name.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAliasDomainDeclINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAliasScopeDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAliasScopeDeclINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAliasScopeDeclINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int AliasDomain
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int? Name
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAliasScopeDeclINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "aliasDomain")
                AliasDomain = o.To<IdRef>();
            if (o.Name == "name")
                Name = o.To<IdRef>();
        }
    }

    public OpAliasScopeDeclINTEL(int resultId, int aliasDomain, int? name)
    {
        ResultId = resultId;
        AliasDomain = aliasDomain;
        Name = name;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAliasScopeDeclINTEL, ..ResultId.AsSpirvSpan(), ..AliasDomain.AsSpirvSpan(), ..Name.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAliasScopeDeclINTEL(OpDataIndex odi) => new(odi);
}

public struct OpAliasScopeListDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAliasScopeListDeclINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAliasScopeListDeclINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpAliasScopeListDeclINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpAliasScopeListDeclINTEL(int resultId, LiteralArray<IdRef> values)
    {
        ResultId = resultId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAliasScopeListDeclINTEL, ..ResultId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAliasScopeListDeclINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedSqrtINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedSqrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedSqrtINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedSqrtINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedSqrtINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSqrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedRecipINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedRecipINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedRecipINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedRecipINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedRecipINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedRecipINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedRecipINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedRsqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedRsqrtINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedRsqrtINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedRsqrtINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedRsqrtINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedRsqrtINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedRsqrtINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedSinINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedSinINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedSinINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedSinINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedSinINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSinINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedCosINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedCosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedCosINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedCosINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedCosINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedCosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSinCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedSinCosINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedSinCosINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedSinCosINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedSinCosINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedSinCosINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSinCosINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedSinPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedSinPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedSinPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedSinPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedSinPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSinPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedCosPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedCosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedCosPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedCosPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedCosPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedCosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedSinCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedSinCosPiINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedSinCosPiINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedSinCosPiINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedSinCosPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedSinCosPiINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedSinCosPiINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedLogINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedLogINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedLogINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedLogINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedLogINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedLogINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedLogINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFixedExpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFixedExpINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFixedExpINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFixedExpINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "inputType")
                InputType = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
            if (o.Name == "s")
                S = o.To<LiteralInteger>();
            if (o.Name == "i")
                I = o.To<LiteralInteger>();
            if (o.Name == "rI")
                RI = o.To<LiteralInteger>();
            if (o.Name == "q")
                Q = o.To<LiteralInteger>();
            if (o.Name == "o")
                O = o.To<LiteralInteger>();
        }
    }

    public OpFixedExpINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFixedExpINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..InputType.AsSpirvSpan(), ..Input.AsSpirvSpan(), ..S.AsSpirvSpan(), ..I.AsSpirvSpan(), ..RI.AsSpirvSpan(), ..Q.AsSpirvSpan(), ..O.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFixedExpINTEL(OpDataIndex odi) => new(odi);
}

public struct OpPtrCastToCrossWorkgroupINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpPtrCastToCrossWorkgroupINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpPtrCastToCrossWorkgroupINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpPtrCastToCrossWorkgroupINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
        }
    }

    public OpPtrCastToCrossWorkgroupINTEL(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpPtrCastToCrossWorkgroupINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpPtrCastToCrossWorkgroupINTEL(OpDataIndex odi) => new(odi);
}

public struct OpCrossWorkgroupCastToPtrINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCrossWorkgroupCastToPtrINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCrossWorkgroupCastToPtrINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpCrossWorkgroupCastToPtrINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
        }
    }

    public OpCrossWorkgroupCastToPtrINTEL(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCrossWorkgroupCastToPtrINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCrossWorkgroupCastToPtrINTEL(OpDataIndex odi) => new(odi);
}

public struct OpReadPipeBlockingINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpReadPipeBlockingINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpReadPipeBlockingINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpReadPipeBlockingINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpReadPipeBlockingINTEL(int resultType, int resultId, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpReadPipeBlockingINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpReadPipeBlockingINTEL(OpDataIndex odi) => new(odi);
}

public struct OpWritePipeBlockingINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpWritePipeBlockingINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpWritePipeBlockingINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpWritePipeBlockingINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "packetSize")
                PacketSize = o.To<IdRef>();
            if (o.Name == "packetAlignment")
                PacketAlignment = o.To<IdRef>();
        }
    }

    public OpWritePipeBlockingINTEL(int resultType, int resultId, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpWritePipeBlockingINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PacketSize.AsSpirvSpan(), ..PacketAlignment.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpWritePipeBlockingINTEL(OpDataIndex odi) => new(odi);
}

public struct OpFPGARegINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpFPGARegINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpFPGARegINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Result
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpFPGARegINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "result")
                Result = o.To<IdRef>();
            if (o.Name == "input")
                Input = o.To<IdRef>();
        }
    }

    public OpFPGARegINTEL(int resultType, int resultId, int result, int input)
    {
        ResultType = resultType;
        ResultId = resultId;
        Result = result;
        Input = input;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpFPGARegINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Result.AsSpirvSpan(), ..Input.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpFPGARegINTEL(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetRayTMinKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetRayTMinKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetRayTMinKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetRayTMinKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
        }
    }

    public OpRayQueryGetRayTMinKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetRayTMinKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetRayTMinKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetRayFlagsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetRayFlagsKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetRayFlagsKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetRayFlagsKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
        }
    }

    public OpRayQueryGetRayFlagsKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetRayFlagsKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetRayFlagsKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionTKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionTKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionTKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionTKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionTKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionTKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionInstanceCustomIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionInstanceCustomIndexKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionInstanceCustomIndexKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionInstanceCustomIndexKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionInstanceIdKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionInstanceIdKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionInstanceIdKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionInstanceIdKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionInstanceIdKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionInstanceIdKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceIdKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionGeometryIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionGeometryIndexKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionGeometryIndexKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionGeometryIndexKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionGeometryIndexKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionPrimitiveIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionPrimitiveIndexKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionPrimitiveIndexKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionPrimitiveIndexKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionPrimitiveIndexKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionBarycentricsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionBarycentricsKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionBarycentricsKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionBarycentricsKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionBarycentricsKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionBarycentricsKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionBarycentricsKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionFrontFaceKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionFrontFaceKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionFrontFaceKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionFrontFaceKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionFrontFaceKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionFrontFaceKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionFrontFaceKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionCandidateAABBOpaqueKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionCandidateAABBOpaqueKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionCandidateAABBOpaqueKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionObjectRayDirectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionObjectRayDirectionKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionObjectRayDirectionKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionObjectRayDirectionKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectRayDirectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionObjectRayOriginKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionObjectRayOriginKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionObjectRayOriginKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionObjectRayOriginKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectRayOriginKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetWorldRayDirectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetWorldRayDirectionKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetWorldRayDirectionKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetWorldRayDirectionKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
        }
    }

    public OpRayQueryGetWorldRayDirectionKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetWorldRayDirectionKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetWorldRayDirectionKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetWorldRayOriginKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetWorldRayOriginKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetWorldRayOriginKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetWorldRayOriginKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
        }
    }

    public OpRayQueryGetWorldRayOriginKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetWorldRayOriginKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetWorldRayOriginKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionObjectToWorldKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionObjectToWorldKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionObjectToWorldKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionObjectToWorldKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectToWorldKHR(OpDataIndex odi) => new(odi);
}

public struct OpRayQueryGetIntersectionWorldToObjectKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpRayQueryGetIntersectionWorldToObjectKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpRayQueryGetIntersectionWorldToObjectKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "rayQuery")
                RayQuery = o.To<IdRef>();
            if (o.Name == "intersection")
                Intersection = o.To<IdRef>();
        }
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpRayQueryGetIntersectionWorldToObjectKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..RayQuery.AsSpirvSpan(), ..Intersection.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpRayQueryGetIntersectionWorldToObjectKHR(OpDataIndex odi) => new(odi);
}

public struct OpAtomicFAddEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpAtomicFAddEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpAtomicFAddEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpAtomicFAddEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "pointer")
                Pointer = o.To<IdRef>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public OpAtomicFAddEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpAtomicFAddEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Pointer.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpAtomicFAddEXT(OpDataIndex odi) => new(odi);
}

public struct OpTypeBufferSurfaceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpTypeBufferSurfaceINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpTypeBufferSurfaceINTEL inst) => inst.ResultId;
    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public AccessQualifier AccessQualifier
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpTypeBufferSurfaceINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "accessQualifier")
                AccessQualifier = o.ToEnum<AccessQualifier>();
        }
    }

    public OpTypeBufferSurfaceINTEL(int resultId, AccessQualifier accessQualifier)
    {
        ResultId = resultId;
        AccessQualifier = accessQualifier;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeBufferSurfaceINTEL, ..ResultId.AsSpirvSpan(), ..AccessQualifier.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeBufferSurfaceINTEL(OpDataIndex odi) => new(odi);
}

public struct OpTypeStructContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpTypeStructContinuedINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpTypeStructContinuedINTEL(LiteralArray<IdRef> values)
    {
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpTypeStructContinuedINTEL, ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpTypeStructContinuedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpCompositeConstructContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpCompositeConstructContinuedINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpCompositeConstructContinuedINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public LiteralArray<IdRef> Values
    {
        get;
        set
        {
            field.Assign(value);
            UpdateInstructionMemory();
        }
    }

    public OpCompositeConstructContinuedINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "values")
                Values = o.To<LiteralArray<IdRef>>();
        }
    }

    public OpCompositeConstructContinuedINTEL(int resultType, int resultId, LiteralArray<IdRef> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values.Assign(values);
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpCompositeConstructContinuedINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Values.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpCompositeConstructContinuedINTEL(OpDataIndex odi) => new(odi);
}

public struct OpConvertFToBF16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertFToBF16INTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertFToBF16INTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertFToBF16INTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "floatValue")
                FloatValue = o.To<IdRef>();
        }
    }

    public OpConvertFToBF16INTEL(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertFToBF16INTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..FloatValue.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertFToBF16INTEL(OpDataIndex odi) => new(odi);
}

public struct OpConvertBF16ToFINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpConvertBF16ToFINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpConvertBF16ToFINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int BFloat16Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpConvertBF16ToFINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "bFloat16Value")
                BFloat16Value = o.To<IdRef>();
        }
    }

    public OpConvertBF16ToFINTEL(int resultType, int resultId, int bFloat16Value)
    {
        ResultType = resultType;
        ResultId = resultId;
        BFloat16Value = bFloat16Value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpConvertBF16ToFINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..BFloat16Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpConvertBF16ToFINTEL(OpDataIndex odi) => new(odi);
}

public struct OpControlBarrierArriveINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpControlBarrierArriveINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpControlBarrierArriveINTEL(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpControlBarrierArriveINTEL, ..Execution.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpControlBarrierArriveINTEL(OpDataIndex odi) => new(odi);
}

public struct OpControlBarrierWaitINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpControlBarrierWaitINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "memory")
                Memory = o.To<IdScope>();
            if (o.Name == "semantics")
                Semantics = o.To<IdMemorySemantics>();
        }
    }

    public OpControlBarrierWaitINTEL(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpControlBarrierWaitINTEL, ..Execution.AsSpirvSpan(), ..Memory.AsSpirvSpan(), ..Semantics.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpControlBarrierWaitINTEL(OpDataIndex odi) => new(odi);
}

public struct OpArithmeticFenceEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpArithmeticFenceEXT inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpArithmeticFenceEXT inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpArithmeticFenceEXT(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "target")
                Target = o.To<IdRef>();
        }
    }

    public OpArithmeticFenceEXT(int resultType, int resultId, int target)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpArithmeticFenceEXT, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Target.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpArithmeticFenceEXT(OpDataIndex odi) => new(odi);
}

public struct OpSubgroupBlockPrefetchINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int NumBytes
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockPrefetchINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "ptr")
                Ptr = o.To<IdRef>();
            if (o.Name == "numBytes")
                NumBytes = o.To<IdRef>();
            if (o.Name == "memoryaccess")
                Memoryaccess = o.ToEnum<MemoryAccessMask>();
        }
    }

    public OpSubgroupBlockPrefetchINTEL(int ptr, int numBytes, MemoryAccessMask? memoryaccess)
    {
        Ptr = ptr;
        NumBytes = numBytes;
        Memoryaccess = memoryaccess;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpSubgroupBlockPrefetchINTEL, ..Ptr.AsSpirvSpan(), ..NumBytes.AsSpirvSpan(), ..Memoryaccess.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpSubgroupBlockPrefetchINTEL(OpDataIndex odi) => new(odi);
}

public struct OpGroupIMulKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupIMulKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupIMulKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupIMulKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupIMulKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupIMulKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupIMulKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupFMulKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupFMulKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupFMulKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupFMulKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupFMulKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupFMulKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupFMulKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupBitwiseAndKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupBitwiseAndKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupBitwiseAndKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupBitwiseAndKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupBitwiseAndKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupBitwiseAndKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupBitwiseAndKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupBitwiseOrKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupBitwiseOrKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupBitwiseOrKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupBitwiseOrKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupBitwiseOrKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupBitwiseOrKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupBitwiseOrKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupBitwiseXorKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupBitwiseXorKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupBitwiseXorKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupBitwiseXorKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupBitwiseXorKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupBitwiseXorKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupBitwiseXorKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupLogicalAndKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupLogicalAndKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupLogicalAndKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupLogicalAndKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupLogicalAndKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupLogicalAndKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupLogicalAndKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupLogicalOrKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupLogicalOrKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupLogicalOrKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupLogicalOrKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupLogicalOrKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupLogicalOrKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupLogicalOrKHR(OpDataIndex odi) => new(odi);
}

public struct OpGroupLogicalXorKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpGroupLogicalXorKHR inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpGroupLogicalXorKHR inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpGroupLogicalXorKHR(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "execution")
                Execution = o.To<IdScope>();
            if (o.Name == "operation")
                Operation = o.ToEnum<GroupOperation>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public OpGroupLogicalXorKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpGroupLogicalXorKHR, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Execution.AsSpirvSpan(), ..Operation.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpGroupLogicalXorKHR(OpDataIndex odi) => new(odi);
}

public struct OpMaskedGatherINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(OpMaskedGatherINTEL inst) => new IdRef(inst.ResultId);
    public static implicit operator int (OpMaskedGatherINTEL inst) => inst.ResultId;
    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PtrVector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Alignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int FillEmpty
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMaskedGatherINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "ptrVector")
                PtrVector = o.To<IdRef>();
            if (o.Name == "alignment")
                Alignment = o.To<LiteralInteger>();
            if (o.Name == "mask")
                Mask = o.To<IdRef>();
            if (o.Name == "fillEmpty")
                FillEmpty = o.To<IdRef>();
        }
    }

    public OpMaskedGatherINTEL(int resultType, int resultId, int ptrVector, int alignment, int mask, int fillEmpty)
    {
        ResultType = resultType;
        ResultId = resultId;
        PtrVector = ptrVector;
        Alignment = alignment;
        Mask = mask;
        FillEmpty = fillEmpty;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMaskedGatherINTEL, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..PtrVector.AsSpirvSpan(), ..Alignment.AsSpirvSpan(), ..Mask.AsSpirvSpan(), ..FillEmpty.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMaskedGatherINTEL(OpDataIndex odi) => new(odi);
}

public struct OpMaskedScatterINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public int InputVector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int PtrVector
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Alignment
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public OpMaskedScatterINTEL(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "inputVector")
                InputVector = o.To<IdRef>();
            if (o.Name == "ptrVector")
                PtrVector = o.To<IdRef>();
            if (o.Name == "alignment")
                Alignment = o.To<LiteralInteger>();
            if (o.Name == "mask")
                Mask = o.To<IdRef>();
        }
    }

    public OpMaskedScatterINTEL(int inputVector, int ptrVector, int alignment, int mask)
    {
        InputVector = inputVector;
        PtrVector = ptrVector;
        Alignment = alignment;
        Mask = mask;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpMaskedScatterINTEL, ..InputVector.AsSpirvSpan(), ..PtrVector.AsSpirvSpan(), ..Alignment.AsSpirvSpan(), ..Mask.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator OpMaskedScatterINTEL(OpDataIndex odi) => new(odi);
}

public struct GLSLRound : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLRound inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLRound inst) => inst.ResultId;
    public int Instruction => 1;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLRound(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLRound(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLRound(OpDataIndex odi) => new(odi);
}

public struct GLSLRoundEven : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLRoundEven inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLRoundEven inst) => inst.ResultId;
    public int Instruction => 2;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLRoundEven(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLRoundEven(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLRoundEven(OpDataIndex odi) => new(odi);
}

public struct GLSLTrunc : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLTrunc inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLTrunc inst) => inst.ResultId;
    public int Instruction => 3;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLTrunc(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLTrunc(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLTrunc(OpDataIndex odi) => new(odi);
}

public struct GLSLFAbs : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFAbs inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFAbs inst) => inst.ResultId;
    public int Instruction => 4;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFAbs(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLFAbs(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFAbs(OpDataIndex odi) => new(odi);
}

public struct GLSLSAbs : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSAbs inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSAbs inst) => inst.ResultId;
    public int Instruction => 5;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSAbs(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLSAbs(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSAbs(OpDataIndex odi) => new(odi);
}

public struct GLSLFSign : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFSign inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFSign inst) => inst.ResultId;
    public int Instruction => 6;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFSign(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLFSign(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFSign(OpDataIndex odi) => new(odi);
}

public struct GLSLSSign : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSSign inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSSign inst) => inst.ResultId;
    public int Instruction => 7;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSSign(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLSSign(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSSign(OpDataIndex odi) => new(odi);
}

public struct GLSLFloor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFloor inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFloor inst) => inst.ResultId;
    public int Instruction => 8;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFloor(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLFloor(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFloor(OpDataIndex odi) => new(odi);
}

public struct GLSLCeil : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLCeil inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLCeil inst) => inst.ResultId;
    public int Instruction => 9;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLCeil(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLCeil(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLCeil(OpDataIndex odi) => new(odi);
}

public struct GLSLFract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFract inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFract inst) => inst.ResultId;
    public int Instruction => 10;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFract(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLFract(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFract(OpDataIndex odi) => new(odi);
}

public struct GLSLRadians : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLRadians inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLRadians inst) => inst.ResultId;
    public int Instruction => 11;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Degrees
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLRadians(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "degrees")
                Degrees = o.To<IdRef>();
        }
    }

    public GLSLRadians(int resultType, int resultId, int set, int degrees)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Degrees = degrees;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Degrees.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLRadians(OpDataIndex odi) => new(odi);
}

public struct GLSLDegrees : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLDegrees inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLDegrees inst) => inst.ResultId;
    public int Instruction => 12;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Radians
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLDegrees(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "radians")
                Radians = o.To<IdRef>();
        }
    }

    public GLSLDegrees(int resultType, int resultId, int set, int radians)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Radians = radians;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Radians.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLDegrees(OpDataIndex odi) => new(odi);
}

public struct GLSLSin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSin inst) => inst.ResultId;
    public int Instruction => 13;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLSin(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSin(OpDataIndex odi) => new(odi);
}

public struct GLSLCos : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLCos inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLCos inst) => inst.ResultId;
    public int Instruction => 14;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLCos(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLCos(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLCos(OpDataIndex odi) => new(odi);
}

public struct GLSLTan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLTan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLTan inst) => inst.ResultId;
    public int Instruction => 15;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLTan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLTan(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLTan(OpDataIndex odi) => new(odi);
}

public struct GLSLAsin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLAsin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLAsin inst) => inst.ResultId;
    public int Instruction => 16;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLAsin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLAsin(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAsin(OpDataIndex odi) => new(odi);
}

public struct GLSLAcos : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLAcos inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLAcos inst) => inst.ResultId;
    public int Instruction => 17;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLAcos(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLAcos(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAcos(OpDataIndex odi) => new(odi);
}

public struct GLSLAtan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLAtan inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLAtan inst) => inst.ResultId;
    public int Instruction => 18;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y_over_x
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLAtan(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "y_over_x")
                Y_over_x = o.To<IdRef>();
        }
    }

    public GLSLAtan(int resultType, int resultId, int set, int y_over_x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Y_over_x = y_over_x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Y_over_x.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAtan(OpDataIndex odi) => new(odi);
}

public struct GLSLSinh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSinh inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSinh inst) => inst.ResultId;
    public int Instruction => 19;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSinh(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLSinh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSinh(OpDataIndex odi) => new(odi);
}

public struct GLSLCosh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLCosh inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLCosh inst) => inst.ResultId;
    public int Instruction => 20;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLCosh(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLCosh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLCosh(OpDataIndex odi) => new(odi);
}

public struct GLSLTanh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLTanh inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLTanh inst) => inst.ResultId;
    public int Instruction => 21;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLTanh(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLTanh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLTanh(OpDataIndex odi) => new(odi);
}

public struct GLSLAsinh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLAsinh inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLAsinh inst) => inst.ResultId;
    public int Instruction => 22;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLAsinh(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLAsinh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAsinh(OpDataIndex odi) => new(odi);
}

public struct GLSLAcosh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLAcosh inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLAcosh inst) => inst.ResultId;
    public int Instruction => 23;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLAcosh(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLAcosh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAcosh(OpDataIndex odi) => new(odi);
}

public struct GLSLAtanh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLAtanh inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLAtanh inst) => inst.ResultId;
    public int Instruction => 24;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLAtanh(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLAtanh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAtanh(OpDataIndex odi) => new(odi);
}

public struct GLSLAtan2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLAtan2 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLAtan2 inst) => inst.ResultId;
    public int Instruction => 25;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLAtan2(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLAtan2(int resultType, int resultId, int set, int y, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Y = y;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Y.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLAtan2(OpDataIndex odi) => new(odi);
}

public struct GLSLPow : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLPow inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLPow inst) => inst.ResultId;
    public int Instruction => 26;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLPow(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLPow(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPow(OpDataIndex odi) => new(odi);
}

public struct GLSLExp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLExp inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLExp inst) => inst.ResultId;
    public int Instruction => 27;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLExp(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLExp(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLExp(OpDataIndex odi) => new(odi);
}

public struct GLSLLog : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLLog inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLLog inst) => inst.ResultId;
    public int Instruction => 28;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLLog(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLLog(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLLog(OpDataIndex odi) => new(odi);
}

public struct GLSLExp2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLExp2 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLExp2 inst) => inst.ResultId;
    public int Instruction => 29;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLExp2(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLExp2(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLExp2(OpDataIndex odi) => new(odi);
}

public struct GLSLLog2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLLog2 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLLog2 inst) => inst.ResultId;
    public int Instruction => 30;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLLog2(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLLog2(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLLog2(OpDataIndex odi) => new(odi);
}

public struct GLSLSqrt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSqrt inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSqrt inst) => inst.ResultId;
    public int Instruction => 31;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSqrt(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLSqrt(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSqrt(OpDataIndex odi) => new(odi);
}

public struct GLSLInverseSqrt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLInverseSqrt inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLInverseSqrt inst) => inst.ResultId;
    public int Instruction => 32;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLInverseSqrt(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLInverseSqrt(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLInverseSqrt(OpDataIndex odi) => new(odi);
}

public struct GLSLDeterminant : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLDeterminant inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLDeterminant inst) => inst.ResultId;
    public int Instruction => 33;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLDeterminant(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLDeterminant(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLDeterminant(OpDataIndex odi) => new(odi);
}

public struct GLSLMatrixInverse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLMatrixInverse inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLMatrixInverse inst) => inst.ResultId;
    public int Instruction => 34;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLMatrixInverse(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLMatrixInverse(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLMatrixInverse(OpDataIndex odi) => new(odi);
}

public struct GLSLModf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLModf inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLModf inst) => inst.ResultId;
    public int Instruction => 35;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLModf(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "i")
                I = o.To<IdRef>();
        }
    }

    public GLSLModf(int resultType, int resultId, int set, int x, int i)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        I = i;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..I.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLModf(OpDataIndex odi) => new(odi);
}

public struct GLSLModfStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLModfStruct inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLModfStruct inst) => inst.ResultId;
    public int Instruction => 36;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLModfStruct(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLModfStruct(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLModfStruct(OpDataIndex odi) => new(odi);
}

public struct GLSLFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFMin inst) => inst.ResultId;
    public int Instruction => 37;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLFMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFMin(OpDataIndex odi) => new(odi);
}

public struct GLSLUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUMin inst) => inst.ResultId;
    public int Instruction => 38;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLUMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUMin(OpDataIndex odi) => new(odi);
}

public struct GLSLSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSMin inst) => inst.ResultId;
    public int Instruction => 39;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLSMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSMin(OpDataIndex odi) => new(odi);
}

public struct GLSLFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFMax inst) => inst.ResultId;
    public int Instruction => 40;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLFMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFMax(OpDataIndex odi) => new(odi);
}

public struct GLSLUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUMax inst) => inst.ResultId;
    public int Instruction => 41;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLUMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUMax(OpDataIndex odi) => new(odi);
}

public struct GLSLSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSMax inst) => inst.ResultId;
    public int Instruction => 42;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLSMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSMax(OpDataIndex odi) => new(odi);
}

public struct GLSLFClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFClamp inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFClamp inst) => inst.ResultId;
    public int Instruction => 43;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFClamp(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "minVal")
                MinVal = o.To<IdRef>();
            if (o.Name == "maxVal")
                MaxVal = o.To<IdRef>();
        }
    }

    public GLSLFClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..MinVal.AsSpirvSpan(), ..MaxVal.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFClamp(OpDataIndex odi) => new(odi);
}

public struct GLSLUClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUClamp inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUClamp inst) => inst.ResultId;
    public int Instruction => 44;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUClamp(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "minVal")
                MinVal = o.To<IdRef>();
            if (o.Name == "maxVal")
                MaxVal = o.To<IdRef>();
        }
    }

    public GLSLUClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..MinVal.AsSpirvSpan(), ..MaxVal.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUClamp(OpDataIndex odi) => new(odi);
}

public struct GLSLSClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSClamp inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSClamp inst) => inst.ResultId;
    public int Instruction => 45;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSClamp(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "minVal")
                MinVal = o.To<IdRef>();
            if (o.Name == "maxVal")
                MaxVal = o.To<IdRef>();
        }
    }

    public GLSLSClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..MinVal.AsSpirvSpan(), ..MaxVal.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSClamp(OpDataIndex odi) => new(odi);
}

public struct GLSLFMix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFMix inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFMix inst) => inst.ResultId;
    public int Instruction => 46;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFMix(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
            if (o.Name == "a")
                A = o.To<IdRef>();
        }
    }

    public GLSLFMix(int resultType, int resultId, int set, int x, int y, int a)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        A = a;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan(), ..A.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFMix(OpDataIndex odi) => new(odi);
}

public struct GLSLIMix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLIMix inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLIMix inst) => inst.ResultId;
    public int Instruction => 47;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLIMix(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
            if (o.Name == "a")
                A = o.To<IdRef>();
        }
    }

    public GLSLIMix(int resultType, int resultId, int set, int x, int y, int a)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        A = a;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan(), ..A.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLIMix(OpDataIndex odi) => new(odi);
}

public struct GLSLStep : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLStep inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLStep inst) => inst.ResultId;
    public int Instruction => 48;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Edge
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLStep(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "edge")
                Edge = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLStep(int resultType, int resultId, int set, int edge, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Edge = edge;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Edge.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLStep(OpDataIndex odi) => new(odi);
}

public struct GLSLSmoothStep : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLSmoothStep inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLSmoothStep inst) => inst.ResultId;
    public int Instruction => 49;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Edge0
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Edge1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLSmoothStep(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "edge0")
                Edge0 = o.To<IdRef>();
            if (o.Name == "edge1")
                Edge1 = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLSmoothStep(int resultType, int resultId, int set, int edge0, int edge1, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Edge0 = edge0;
        Edge1 = edge1;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Edge0.AsSpirvSpan(), ..Edge1.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLSmoothStep(OpDataIndex odi) => new(odi);
}

public struct GLSLFma : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFma inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFma inst) => inst.ResultId;
    public int Instruction => 50;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFma(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "a")
                A = o.To<IdRef>();
            if (o.Name == "b")
                B = o.To<IdRef>();
            if (o.Name == "c")
                C = o.To<IdRef>();
        }
    }

    public GLSLFma(int resultType, int resultId, int set, int a, int b, int c)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        A = a;
        B = b;
        C = c;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..A.AsSpirvSpan(), ..B.AsSpirvSpan(), ..C.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFma(OpDataIndex odi) => new(odi);
}

public struct GLSLFrexp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFrexp inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFrexp inst) => inst.ResultId;
    public int Instruction => 51;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Exp
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFrexp(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "exp")
                Exp = o.To<IdRef>();
        }
    }

    public GLSLFrexp(int resultType, int resultId, int set, int x, int exp)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Exp = exp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Exp.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFrexp(OpDataIndex odi) => new(odi);
}

public struct GLSLFrexpStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFrexpStruct inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFrexpStruct inst) => inst.ResultId;
    public int Instruction => 52;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFrexpStruct(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLFrexpStruct(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFrexpStruct(OpDataIndex odi) => new(odi);
}

public struct GLSLLdexp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLLdexp inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLLdexp inst) => inst.ResultId;
    public int Instruction => 53;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Exp
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLLdexp(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "exp")
                Exp = o.To<IdRef>();
        }
    }

    public GLSLLdexp(int resultType, int resultId, int set, int x, int exp)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Exp = exp;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Exp.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLLdexp(OpDataIndex odi) => new(odi);
}

public struct GLSLPackSnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLPackSnorm4x8 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLPackSnorm4x8 inst) => inst.ResultId;
    public int Instruction => 54;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLPackSnorm4x8(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "v")
                V = o.To<IdRef>();
        }
    }

    public GLSLPackSnorm4x8(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..V.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackSnorm4x8(OpDataIndex odi) => new(odi);
}

public struct GLSLPackUnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLPackUnorm4x8 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLPackUnorm4x8 inst) => inst.ResultId;
    public int Instruction => 55;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLPackUnorm4x8(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "v")
                V = o.To<IdRef>();
        }
    }

    public GLSLPackUnorm4x8(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..V.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackUnorm4x8(OpDataIndex odi) => new(odi);
}

public struct GLSLPackSnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLPackSnorm2x16 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLPackSnorm2x16 inst) => inst.ResultId;
    public int Instruction => 56;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLPackSnorm2x16(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "v")
                V = o.To<IdRef>();
        }
    }

    public GLSLPackSnorm2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..V.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackSnorm2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLPackUnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLPackUnorm2x16 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLPackUnorm2x16 inst) => inst.ResultId;
    public int Instruction => 57;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLPackUnorm2x16(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "v")
                V = o.To<IdRef>();
        }
    }

    public GLSLPackUnorm2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..V.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackUnorm2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLPackHalf2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLPackHalf2x16 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLPackHalf2x16 inst) => inst.ResultId;
    public int Instruction => 58;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLPackHalf2x16(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "v")
                V = o.To<IdRef>();
        }
    }

    public GLSLPackHalf2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..V.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackHalf2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLPackDouble2x32 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLPackDouble2x32 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLPackDouble2x32 inst) => inst.ResultId;
    public int Instruction => 59;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLPackDouble2x32(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "v")
                V = o.To<IdRef>();
        }
    }

    public GLSLPackDouble2x32(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..V.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLPackDouble2x32(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackSnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUnpackSnorm2x16 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUnpackSnorm2x16 inst) => inst.ResultId;
    public int Instruction => 60;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUnpackSnorm2x16(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public GLSLUnpackSnorm2x16(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackSnorm2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackUnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUnpackUnorm2x16 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUnpackUnorm2x16 inst) => inst.ResultId;
    public int Instruction => 61;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUnpackUnorm2x16(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public GLSLUnpackUnorm2x16(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackUnorm2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackHalf2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUnpackHalf2x16 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUnpackHalf2x16 inst) => inst.ResultId;
    public int Instruction => 62;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUnpackHalf2x16(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "v")
                V = o.To<IdRef>();
        }
    }

    public GLSLUnpackHalf2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..V.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackHalf2x16(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackSnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUnpackSnorm4x8 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUnpackSnorm4x8 inst) => inst.ResultId;
    public int Instruction => 63;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUnpackSnorm4x8(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public GLSLUnpackSnorm4x8(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackSnorm4x8(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackUnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUnpackUnorm4x8 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUnpackUnorm4x8 inst) => inst.ResultId;
    public int Instruction => 64;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUnpackUnorm4x8(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "p")
                P = o.To<IdRef>();
        }
    }

    public GLSLUnpackUnorm4x8(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..P.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackUnorm4x8(OpDataIndex odi) => new(odi);
}

public struct GLSLUnpackDouble2x32 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLUnpackDouble2x32 inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLUnpackDouble2x32 inst) => inst.ResultId;
    public int Instruction => 65;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLUnpackDouble2x32(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "v")
                V = o.To<IdRef>();
        }
    }

    public GLSLUnpackDouble2x32(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..V.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLUnpackDouble2x32(OpDataIndex odi) => new(odi);
}

public struct GLSLLength : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLLength inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLLength inst) => inst.ResultId;
    public int Instruction => 66;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLLength(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLLength(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLLength(OpDataIndex odi) => new(odi);
}

public struct GLSLDistance : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLDistance inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLDistance inst) => inst.ResultId;
    public int Instruction => 67;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P0
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int P1
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLDistance(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "p0")
                P0 = o.To<IdRef>();
            if (o.Name == "p1")
                P1 = o.To<IdRef>();
        }
    }

    public GLSLDistance(int resultType, int resultId, int set, int p0, int p1)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P0 = p0;
        P1 = p1;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..P0.AsSpirvSpan(), ..P1.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLDistance(OpDataIndex odi) => new(odi);
}

public struct GLSLCross : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLCross inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLCross inst) => inst.ResultId;
    public int Instruction => 68;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLCross(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLCross(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLCross(OpDataIndex odi) => new(odi);
}

public struct GLSLNormalize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLNormalize inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLNormalize inst) => inst.ResultId;
    public int Instruction => 69;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLNormalize(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
        }
    }

    public GLSLNormalize(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLNormalize(OpDataIndex odi) => new(odi);
}

public struct GLSLFaceForward : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFaceForward inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFaceForward inst) => inst.ResultId;
    public int Instruction => 70;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Nref
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFaceForward(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "n")
                N = o.To<IdRef>();
            if (o.Name == "i")
                I = o.To<IdRef>();
            if (o.Name == "nref")
                Nref = o.To<IdRef>();
        }
    }

    public GLSLFaceForward(int resultType, int resultId, int set, int n, int i, int nref)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        N = n;
        I = i;
        Nref = nref;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..N.AsSpirvSpan(), ..I.AsSpirvSpan(), ..Nref.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFaceForward(OpDataIndex odi) => new(odi);
}

public struct GLSLReflect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLReflect inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLReflect inst) => inst.ResultId;
    public int Instruction => 71;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLReflect(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "i")
                I = o.To<IdRef>();
            if (o.Name == "n")
                N = o.To<IdRef>();
        }
    }

    public GLSLReflect(int resultType, int resultId, int set, int i, int n)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        I = i;
        N = n;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..I.AsSpirvSpan(), ..N.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLReflect(OpDataIndex odi) => new(odi);
}

public struct GLSLRefract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLRefract inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLRefract inst) => inst.ResultId;
    public int Instruction => 72;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Eta
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLRefract(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "i")
                I = o.To<IdRef>();
            if (o.Name == "n")
                N = o.To<IdRef>();
            if (o.Name == "eta")
                Eta = o.To<IdRef>();
        }
    }

    public GLSLRefract(int resultType, int resultId, int set, int i, int n, int eta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        I = i;
        N = n;
        Eta = eta;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..I.AsSpirvSpan(), ..N.AsSpirvSpan(), ..Eta.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLRefract(OpDataIndex odi) => new(odi);
}

public struct GLSLFindILsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFindILsb inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFindILsb inst) => inst.ResultId;
    public int Instruction => 73;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFindILsb(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public GLSLFindILsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFindILsb(OpDataIndex odi) => new(odi);
}

public struct GLSLFindSMsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFindSMsb inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFindSMsb inst) => inst.ResultId;
    public int Instruction => 74;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFindSMsb(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public GLSLFindSMsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFindSMsb(OpDataIndex odi) => new(odi);
}

public struct GLSLFindUMsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLFindUMsb inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLFindUMsb inst) => inst.ResultId;
    public int Instruction => 75;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLFindUMsb(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "value")
                Value = o.To<IdRef>();
        }
    }

    public GLSLFindUMsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Value.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLFindUMsb(OpDataIndex odi) => new(odi);
}

public struct GLSLInterpolateAtCentroid : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLInterpolateAtCentroid inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLInterpolateAtCentroid inst) => inst.ResultId;
    public int Instruction => 76;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLInterpolateAtCentroid(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "interpolant")
                Interpolant = o.To<IdRef>();
        }
    }

    public GLSLInterpolateAtCentroid(int resultType, int resultId, int set, int interpolant)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Interpolant.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLInterpolateAtCentroid(OpDataIndex odi) => new(odi);
}

public struct GLSLInterpolateAtSample : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLInterpolateAtSample inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLInterpolateAtSample inst) => inst.ResultId;
    public int Instruction => 77;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Sample
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLInterpolateAtSample(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "interpolant")
                Interpolant = o.To<IdRef>();
            if (o.Name == "sample")
                Sample = o.To<IdRef>();
        }
    }

    public GLSLInterpolateAtSample(int resultType, int resultId, int set, int interpolant, int sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        Sample = sample;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Interpolant.AsSpirvSpan(), ..Sample.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLInterpolateAtSample(OpDataIndex odi) => new(odi);
}

public struct GLSLInterpolateAtOffset : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLInterpolateAtOffset inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLInterpolateAtOffset inst) => inst.ResultId;
    public int Instruction => 78;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLInterpolateAtOffset(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "interpolant")
                Interpolant = o.To<IdRef>();
            if (o.Name == "offset")
                Offset = o.To<IdRef>();
        }
    }

    public GLSLInterpolateAtOffset(int resultType, int resultId, int set, int interpolant, int offset)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        Offset = offset;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..Interpolant.AsSpirvSpan(), ..Offset.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLInterpolateAtOffset(OpDataIndex odi) => new(odi);
}

public struct GLSLNMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLNMin inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLNMin inst) => inst.ResultId;
    public int Instruction => 79;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLNMin(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLNMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLNMin(OpDataIndex odi) => new(odi);
}

public struct GLSLNMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLNMax inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLNMax inst) => inst.ResultId;
    public int Instruction => 80;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLNMax(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "y")
                Y = o.To<IdRef>();
        }
    }

    public GLSLNMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..Y.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLNMax(OpDataIndex odi) => new(odi);
}

public struct GLSLNClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Buffer[odi.Index].Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Buffer[odi.Index].Memory.Dispose();
                odi.Buffer[odi.Index].Memory = value;
            }
            else
                field = value;
        }
    }

    public static implicit operator IdRef(GLSLNClamp inst) => new IdRef(inst.ResultId);
    public static implicit operator int (GLSLNClamp inst) => inst.ResultId;
    public int Instruction => 81;

    public int ResultType
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            UpdateInstructionMemory();
        }
    }

    public GLSLNClamp(OpDataIndex index)
    {
        DataIndex = index;
        foreach (var o in index.Buffer[index.Index])
        {
            if (o.Name == "resultType")
                ResultType = o.To<IdResultType>();
            if (o.Name == "resultId")
                ResultId = o.To<IdResult>();
            if (o.Name == "set")
                Set = o.To<IdRef>();
            if (o.Name == "x")
                X = o.To<IdRef>();
            if (o.Name == "minVal")
                MinVal = o.To<IdRef>();
            if (o.Name == "maxVal")
                MaxVal = o.To<IdRef>();
        }
    }

    public GLSLNClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
    }

    public void UpdateInstructionMemory()
    {
        Span<int> instruction = [(int)SDSLOp.OpExtInst, ..ResultType.AsSpirvSpan(), ..ResultId.AsSpirvSpan(), ..Set.AsSpirvSpan(), ..Instruction.AsSpirvSpan(), ..X.AsSpirvSpan(), ..MinVal.AsSpirvSpan(), ..MaxVal.AsSpirvSpan()];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    public static implicit operator GLSLNClamp(OpDataIndex odi) => new(odi);
}