using static Stride.Shaders.Spirv.Specification;
using CommunityToolkit.HighPerformance;
using CommunityToolkit.HighPerformance.Buffers;
using Stride.Shaders.Spirv.Core.Buffers;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace Stride.Shaders.Spirv.Core;
public ref partial struct OpSDSLShader : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLShader()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLShader | (1 << 16);
    }

    public OpSDSLShader(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLShader(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string ShaderName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLShader(string shaderName)
    {
        ShaderName = shaderName;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLShader, ..ShaderName.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "shaderName":
                    ShaderName = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLShader(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLShaderEnd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLShaderEnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLShaderEnd | (1 << 16);
    }

    public OpSDSLShaderEnd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLShaderEnd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLShaderEnd];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLShaderEnd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLEffect : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLEffect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLEffect | (1 << 16);
    }

    public OpSDSLEffect(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLEffect(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string EffectName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLEffect(string effectName)
    {
        EffectName = effectName;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLEffect, ..EffectName.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "effectName":
                    EffectName = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLEffect(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLComposition : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLComposition()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLComposition | (1 << 16);
    }

    public OpSDSLComposition(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLComposition(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string CompositionPath
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLComposition(string compositionPath)
    {
        CompositionPath = compositionPath;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLComposition, ..CompositionPath.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "compositionPath":
                    CompositionPath = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLComposition(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLCompositionEnd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLCompositionEnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLCompositionEnd | (1 << 16);
    }

    public OpSDSLCompositionEnd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLCompositionEnd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLCompositionEnd];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLCompositionEnd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLMixinInherit : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixinInherit()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixinInherit | (1 << 16);
    }

    public OpSDSLMixinInherit(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLMixinInherit(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixinInherit(int shader)
    {
        Shader = shader;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixinInherit, Shader];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "shader":
                    Shader = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLMixinInherit(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLCompose : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLCompose()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLCompose | (1 << 16);
    }

    public OpSDSLCompose(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLCompose(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLCompose(string mixin, string name)
    {
        Mixin = mixin;
        Name = name;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLCompose, ..Mixin.AsDisposableLiteralValue().Words, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "mixin":
                    Mixin = o.ToLiteral<string>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLCompose(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLStage : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLStage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLStage | (1 << 16);
    }

    public OpSDSLStage(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLStage(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int StagedElement
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLStage(int stagedElement)
    {
        StagedElement = stagedElement;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLStage, StagedElement];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "stagedElement":
                    StagedElement = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLStage(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLImportShader : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportShader()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportShader | (1 << 16);
    }

    public OpSDSLImportShader(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLImportShader(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string ShaderName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLImportShader inst) => inst.ResultId;
    public OpSDSLImportShader(int resultId, string shaderName, LiteralArray<int> values)
    {
        ResultId = resultId;
        ShaderName = shaderName;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportShader, ResultId, ..ShaderName.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "shaderName":
                    ShaderName = o.ToLiteral<string>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpSDSLImportShader(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSDSLImportFunction : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportFunction | (1 << 16);
    }

    public OpSDSLImportFunction(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLImportFunction(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FunctionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string FunctionName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public FunctionFlagsMask Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLImportFunction inst) => inst.ResultId;
    public OpSDSLImportFunction(int resultId, int functionType, string functionName, int shader, FunctionFlagsMask flags)
    {
        ResultId = resultId;
        FunctionType = functionType;
        FunctionName = functionName;
        Shader = shader;
        Flags = flags;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportFunction, ResultId, FunctionType, ..FunctionName.AsDisposableLiteralValue().Words, Shader, (int)Flags];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "functionType":
                    FunctionType = o.ToLiteral<int>();
                    break;
                case "functionName":
                    FunctionName = o.ToLiteral<string>();
                    break;
                case "shader":
                    Shader = o.ToLiteral<int>();
                    break;
                case "flags":
                    Flags = o.ToEnum<FunctionFlagsMask>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLImportFunction(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLImportVariable : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportVariable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportVariable | (1 << 16);
    }

    public OpSDSLImportVariable(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLImportVariable(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string VariableName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public VariableFlagsMask Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLImportVariable inst) => inst.ResultId;
    public OpSDSLImportVariable(int resultId, int resultType, string variableName, int shader, VariableFlagsMask flags)
    {
        ResultId = resultId;
        ResultType = resultType;
        VariableName = variableName;
        Shader = shader;
        Flags = flags;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportVariable, ResultId, ResultType, ..VariableName.AsDisposableLiteralValue().Words, Shader, (int)Flags];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "variableName":
                    VariableName = o.ToLiteral<string>();
                    break;
                case "shader":
                    Shader = o.ToLiteral<int>();
                    break;
                case "flags":
                    Flags = o.ToEnum<VariableFlagsMask>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLImportVariable(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLImportStruct : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportStruct | (1 << 16);
    }

    public OpSDSLImportStruct(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLImportStruct(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string StructName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLImportStruct inst) => inst.ResultId;
    public OpSDSLImportStruct(int resultId, string structName, int shader)
    {
        ResultId = resultId;
        StructName = structName;
        Shader = shader;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportStruct, ResultId, ..StructName.AsDisposableLiteralValue().Words, Shader];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "structName":
                    StructName = o.ToLiteral<string>();
                    break;
                case "shader":
                    Shader = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLImportStruct(OpDataIndex odi) => new(odi);
}

public ref partial struct OpVariableSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVariableSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVariableSDSL | (1 << 16);
    }

    public OpVariableSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVariableSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public VariableFlagsMask Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? MethodInitializer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVariableSDSL inst) => inst.ResultId;
    public OpVariableSDSL(int resultType, int resultId, StorageClass storageclass, VariableFlagsMask flags, int? methodInitializer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        Flags = flags;
        MethodInitializer = methodInitializer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVariableSDSL, ResultType, ResultId, (int)Storageclass, (int)Flags, ..(MethodInitializer is null ? (Span<int>)[] : [MethodInitializer.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                case "flags":
                    Flags = o.ToEnum<VariableFlagsMask>();
                    break;
                case "methodInitializer":
                    if (o.Words.Length > 0)
                    {
                        MethodInitializer = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpVariableSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMemberAccessSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberAccessSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberAccessSDSL | (1 << 16);
    }

    public OpMemberAccessSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMemberAccessSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Instance
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMemberAccessSDSL inst) => inst.ResultId;
    public OpMemberAccessSDSL(int resultType, int resultId, int instance, int member)
    {
        ResultType = resultType;
        ResultId = resultId;
        Instance = instance;
        Member = member;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberAccessSDSL, ResultType, ResultId, Instance, Member];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "instance":
                    Instance = o.ToLiteral<int>();
                    break;
                case "member":
                    Member = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMemberAccessSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeFunctionSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeFunctionSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeFunctionSDSL | (1 << 16);
    }

    public OpTypeFunctionSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeFunctionSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReturnType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeFunctionSDSL inst) => inst.ResultId;
    public OpTypeFunctionSDSL(int resultId, int returnType, LiteralArray<(int, int)> values)
    {
        ResultId = resultId;
        ReturnType = returnType;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeFunctionSDSL, ResultId, ReturnType, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "returnType":
                    ReturnType = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<(int, int)>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTypeFunctionSDSL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSDSLFunctionInfo : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLFunctionInfo()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLFunctionInfo | (1 << 16);
    }

    public OpSDSLFunctionInfo(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLFunctionInfo(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public FunctionFlagsMask Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Parent
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLFunctionInfo(FunctionFlagsMask flags, int parent)
    {
        Flags = flags;
        Parent = parent;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLFunctionInfo, (int)Flags, Parent];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "flags":
                    Flags = o.ToEnum<FunctionFlagsMask>();
                    break;
                case "parent":
                    Parent = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLFunctionInfo(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBaseSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBaseSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBaseSDSL | (1 << 16);
    }

    public OpBaseSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBaseSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBaseSDSL inst) => inst.ResultId;
    public OpBaseSDSL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBaseSDSL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBaseSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpThisSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpThisSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpThisSDSL | (1 << 16);
    }

    public OpThisSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpThisSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpThisSDSL inst) => inst.ResultId;
    public OpThisSDSL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpThisSDSL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpThisSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpStageSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStageSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStageSDSL | (1 << 16);
    }

    public OpStageSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpStageSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpStageSDSL inst) => inst.ResultId;
    public OpStageSDSL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStageSDSL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpStageSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpStreamsSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStreamsSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStreamsSDSL | (1 << 16);
    }

    public OpStreamsSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpStreamsSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpStreamsSDSL inst) => inst.ResultId;
    public OpStreamsSDSL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStreamsSDSL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpStreamsSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLMixin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixin | (1 << 16);
    }

    public OpSDSLMixin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLMixin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixin(string mixin, LiteralArray<int> values)
    {
        Mixin = mixin;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixin, ..Mixin.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "mixin":
                    Mixin = o.ToLiteral<string>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpSDSLMixin(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSDSLMixinCompose : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixinCompose()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixinCompose | (1 << 16);
    }

    public OpSDSLMixinCompose(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLMixinCompose(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string Identifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixinCompose(string identifier, string mixin, LiteralArray<int> values)
    {
        Identifier = identifier;
        Mixin = mixin;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixinCompose, ..Identifier.AsDisposableLiteralValue().Words, ..Mixin.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "identifier":
                    Identifier = o.ToLiteral<string>();
                    break;
                case "mixin":
                    Mixin = o.ToLiteral<string>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpSDSLMixinCompose(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSDSLMixinComposeArray : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixinComposeArray()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixinComposeArray | (1 << 16);
    }

    public OpSDSLMixinComposeArray(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLMixinComposeArray(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string Identifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixinComposeArray(string identifier, string mixin, LiteralArray<int> values)
    {
        Identifier = identifier;
        Mixin = mixin;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixinComposeArray, ..Identifier.AsDisposableLiteralValue().Words, ..Mixin.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "identifier":
                    Identifier = o.ToLiteral<string>();
                    break;
                case "mixin":
                    Mixin = o.ToLiteral<string>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpSDSLMixinComposeArray(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSDSLGenericParameter : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLGenericParameter()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLGenericParameter | (1 << 16);
    }

    public OpSDSLGenericParameter(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLGenericParameter(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string DeclaringClass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLGenericParameter inst) => inst.ResultId;
    public OpSDSLGenericParameter(int resultType, int resultId, int index, string declaringClass)
    {
        ResultType = resultType;
        ResultId = resultId;
        Index = index;
        DeclaringClass = declaringClass;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLGenericParameter, ResultType, ResultId, ..Index.AsDisposableLiteralValue().Words, ..DeclaringClass.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                case "declaringClass":
                    DeclaringClass = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLGenericParameter(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDSLGenericReference : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLGenericReference()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLGenericReference | (1 << 16);
    }

    public OpSDSLGenericReference(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDSLGenericReference(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string DeclaringClass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLGenericReference inst) => inst.ResultId;
    public OpSDSLGenericReference(int resultType, int resultId, int index, string declaringClass)
    {
        ResultType = resultType;
        ResultId = resultId;
        Index = index;
        DeclaringClass = declaringClass;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLGenericReference, ResultType, ResultId, ..Index.AsDisposableLiteralValue().Words, ..DeclaringClass.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                case "declaringClass":
                    DeclaringClass = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDSLGenericReference(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantStringSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantStringSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantStringSDSL | (1 << 16);
    }

    public OpConstantStringSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantStringSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string LiteralString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantStringSDSL inst) => inst.ResultId;
    public OpConstantStringSDSL(int resultId, string literalString)
    {
        ResultId = resultId;
        LiteralString = literalString;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantStringSDSL, ResultId, ..LiteralString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "literalString":
                    LiteralString = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantStringSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeGenericSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeGenericSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeGenericSDSL | (1 << 16);
    }

    public OpTypeGenericSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeGenericSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GenericParameterKindSDSL Kind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeGenericSDSL inst) => inst.ResultId;
    public OpTypeGenericSDSL(int resultId, GenericParameterKindSDSL kind)
    {
        ResultId = resultId;
        Kind = kind;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeGenericSDSL, ResultId, (int)Kind];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "kind":
                    Kind = o.ToEnum<GenericParameterKindSDSL>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeGenericSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeStreamsSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeStreamsSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeStreamsSDSL | (1 << 16);
    }

    public OpTypeStreamsSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeStreamsSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeStreamsSDSL inst) => inst.ResultId;
    public OpTypeStreamsSDSL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeStreamsSDSL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeStreamsSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpForeachSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpForeachSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpForeachSDSL | (1 << 16);
    }

    public OpForeachSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpForeachSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Collection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpForeachSDSL inst) => inst.ResultId;
    public OpForeachSDSL(int resultType, int resultId, int collection)
    {
        ResultType = resultType;
        ResultId = resultId;
        Collection = collection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpForeachSDSL, ResultType, ResultId, Collection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "collection":
                    Collection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpForeachSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpForeachEndSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpForeachEndSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpForeachEndSDSL | (1 << 16);
    }

    public OpForeachEndSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpForeachEndSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpForeachEndSDSL];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpForeachEndSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUnresolvableShaderSDSL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnresolvableShaderSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUnresolvableShaderSDSL | (1 << 16);
    }

    public OpUnresolvableShaderSDSL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUnresolvableShaderSDSL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string ShaderCode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ShaderCodeNameEnd
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUnresolvableShaderSDSL(string shaderCode, int shaderCodeNameEnd)
    {
        ShaderCode = shaderCode;
        ShaderCodeNameEnd = shaderCodeNameEnd;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUnresolvableShaderSDSL, ..ShaderCode.AsDisposableLiteralValue().Words, ..ShaderCodeNameEnd.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "shaderCode":
                    ShaderCode = o.ToLiteral<string>();
                    break;
                case "shaderCodeNameEnd":
                    ShaderCodeNameEnd = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUnresolvableShaderSDSL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpNop : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNop()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNop | (1 << 16);
    }

    public OpNop(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpNop(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNop];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpNop(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUndef : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUndef()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUndef | (1 << 16);
    }

    public OpUndef(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUndef(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUndef inst) => inst.ResultId;
    public OpUndef(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUndef, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUndef(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSourceContinued : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSourceContinued()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSourceContinued | (1 << 16);
    }

    public OpSourceContinued(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSourceContinued(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string ContinuedSource
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSourceContinued(string continuedSource)
    {
        ContinuedSource = continuedSource;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSourceContinued, ..ContinuedSource.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "continuedSource":
                    ContinuedSource = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSourceContinued(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSource : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSource()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSource | (1 << 16);
    }

    public OpSource(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSource(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public SourceLanguage Sourcelanguage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Version
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? File
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string? Source
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSource(SourceLanguage sourcelanguage, int version, int? file, string? source)
    {
        Sourcelanguage = sourcelanguage;
        Version = version;
        File = file;
        Source = source;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSource, (int)Sourcelanguage, ..Version.AsDisposableLiteralValue().Words, ..(File is null ? (Span<int>)[] : [File.Value]), ..(Source is null ? (Span<int>)[] : Source.AsDisposableLiteralValue().Words)];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "sourcelanguage":
                    Sourcelanguage = o.ToEnum<SourceLanguage>();
                    break;
                case "version":
                    Version = o.ToLiteral<int>();
                    break;
                case "file":
                    if (o.Words.Length > 0)
                    {
                        File = o.ToLiteral<int>();
                    }

                    break;
                case "source":
                    if (o.Words.Length > 0)
                    {
                        Source = o.ToLiteral<string>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSource(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSourceExtension : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSourceExtension()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSourceExtension | (1 << 16);
    }

    public OpSourceExtension(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSourceExtension(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string Extension
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSourceExtension(string extension)
    {
        Extension = extension;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSourceExtension, ..Extension.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "extension":
                    Extension = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSourceExtension(OpDataIndex odi) => new(odi);
}

public ref partial struct OpName : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpName()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpName | (1 << 16);
    }

    public OpName(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpName(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpName(int target, string name)
    {
        Target = target;
        Name = name;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpName, Target, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpName(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMemberName : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberName()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberName | (1 << 16);
    }

    public OpMemberName(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMemberName(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberName(int type, int member, string name)
    {
        Type = type;
        Member = member;
        Name = name;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberName, Type, ..Member.AsDisposableLiteralValue().Words, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "type":
                    Type = o.ToLiteral<int>();
                    break;
                case "member":
                    Member = o.ToLiteral<int>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMemberName(OpDataIndex odi) => new(odi);
}

public ref partial struct OpString : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpString()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpString | (1 << 16);
    }

    public OpString(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpString(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpString inst) => inst.ResultId;
    public OpString(int resultId, string value)
    {
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpString, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpString(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLine : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLine | (1 << 16);
    }

    public OpLine(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLine(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int File
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Line
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Column
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLine(int file, int line, int column)
    {
        File = file;
        Line = line;
        Column = column;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLine, File, ..Line.AsDisposableLiteralValue().Words, ..Column.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "file":
                    File = o.ToLiteral<int>();
                    break;
                case "line":
                    Line = o.ToLiteral<int>();
                    break;
                case "column":
                    Column = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLine(OpDataIndex odi) => new(odi);
}

public ref partial struct OpExtension : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtension()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtension | (1 << 16);
    }

    public OpExtension(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExtension(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExtension(string name)
    {
        Name = name;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtension, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpExtension(OpDataIndex odi) => new(odi);
}

public ref partial struct OpExtInstImport : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInstImport()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInstImport | (1 << 16);
    }

    public OpExtInstImport(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExtInstImport(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpExtInstImport inst) => inst.ResultId;
    public OpExtInstImport(int resultId, string name)
    {
        ResultId = resultId;
        Name = name;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInstImport, ResultId, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpExtInstImport(OpDataIndex odi) => new(odi);
}

public ref partial struct OpExtInst : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInst()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public OpExtInst(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExtInst(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Instruction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpExtInst inst) => inst.ResultId;
    public OpExtInst(int resultType, int resultId, int set, int instruction, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Instruction = instruction;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "instruction":
                    Instruction = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpExtInst(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpMemoryModel : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryModel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryModel | (1 << 16);
    }

    public OpMemoryModel(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMemoryModel(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public AddressingModel Addressingmodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryModel Memorymodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryModel(AddressingModel addressingmodel, MemoryModel memorymodel)
    {
        Addressingmodel = addressingmodel;
        Memorymodel = memorymodel;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryModel, (int)Addressingmodel, (int)Memorymodel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "addressingmodel":
                    Addressingmodel = o.ToEnum<AddressingModel>();
                    break;
                case "memorymodel":
                    Memorymodel = o.ToEnum<MemoryModel>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMemoryModel(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEntryPoint : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEntryPoint()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEntryPoint | (1 << 16);
    }

    public OpEntryPoint(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEntryPoint(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public ExecutionModel Executionmodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEntryPoint(ExecutionModel executionmodel, int entryPoint, string name, LiteralArray<int> values)
    {
        Executionmodel = executionmodel;
        EntryPoint = entryPoint;
        Name = name;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEntryPoint, (int)Executionmodel, EntryPoint, ..Name.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "executionmodel":
                    Executionmodel = o.ToEnum<ExecutionModel>();
                    break;
                case "entryPoint":
                    EntryPoint = o.ToLiteral<int>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpEntryPoint(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpExecutionMode : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecutionMode()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecutionMode | (1 << 16);
    }

    public OpExecutionMode(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExecutionMode(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ExecutionMode Mode { get; set; }

    public EnumerantParameters ModeParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecutionMode(int entryPoint, ExecutionMode mode, EnumerantParameters modeParameters)
    {
        EntryPoint = entryPoint;
        Mode = mode;
        ModeParameters = modeParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecutionMode, EntryPoint, (int)Mode, ..ModeParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "entryPoint":
                    EntryPoint = o.ToLiteral<int>();
                    break;
                case "mode":
                    Mode = o.ToEnum<ExecutionMode>();
                    ModeParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpExecutionMode(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ModeParameters.Dispose();
    }
}

public ref partial struct OpCapability : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCapability()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCapability | (1 << 16);
    }

    public OpCapability(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCapability(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public Capability Capability
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCapability(Capability capability)
    {
        Capability = capability;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCapability, (int)Capability];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "capability":
                    Capability = o.ToEnum<Capability>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCapability(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeVoid : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVoid()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVoid | (1 << 16);
    }

    public OpTypeVoid(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeVoid(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeVoid inst) => inst.ResultId;
    public OpTypeVoid(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVoid, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeVoid(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeBool : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeBool()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeBool | (1 << 16);
    }

    public OpTypeBool(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeBool(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeBool inst) => inst.ResultId;
    public OpTypeBool(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeBool, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeBool(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeInt : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeInt()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeInt | (1 << 16);
    }

    public OpTypeInt(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeInt(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Signedness
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeInt inst) => inst.ResultId;
    public OpTypeInt(int resultId, int width, int signedness)
    {
        ResultId = resultId;
        Width = width;
        Signedness = signedness;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeInt, ResultId, ..Width.AsDisposableLiteralValue().Words, ..Signedness.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "width":
                    Width = o.ToLiteral<int>();
                    break;
                case "signedness":
                    Signedness = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeInt(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeFloat : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeFloat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeFloat | (1 << 16);
    }

    public OpTypeFloat(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeFloat(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public FPEncoding? FloatingPointEncoding
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeFloat inst) => inst.ResultId;
    public OpTypeFloat(int resultId, int width, FPEncoding? floatingPointEncoding)
    {
        ResultId = resultId;
        Width = width;
        FloatingPointEncoding = floatingPointEncoding;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeFloat, ResultId, ..Width.AsDisposableLiteralValue().Words, ..(FloatingPointEncoding is null ? (Span<int>)[] : [(int)FloatingPointEncoding.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "width":
                    Width = o.ToLiteral<int>();
                    break;
                case "floatingPointEncoding":
                    if (o.Words.Length > 0)
                    {
                        FloatingPointEncoding = o.ToEnum<FPEncoding>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeFloat(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeVector : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVector()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVector | (1 << 16);
    }

    public OpTypeVector(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeVector(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeVector inst) => inst.ResultId;
    public OpTypeVector(int resultId, int componentType, int componentCount)
    {
        ResultId = resultId;
        ComponentType = componentType;
        ComponentCount = componentCount;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVector, ResultId, ComponentType, ..ComponentCount.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "componentType":
                    ComponentType = o.ToLiteral<int>();
                    break;
                case "componentCount":
                    ComponentCount = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeVector(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeMatrix : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeMatrix | (1 << 16);
    }

    public OpTypeMatrix(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeMatrix(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeMatrix inst) => inst.ResultId;
    public OpTypeMatrix(int resultId, int columnType, int columnCount)
    {
        ResultId = resultId;
        ColumnType = columnType;
        ColumnCount = columnCount;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeMatrix, ResultId, ColumnType, ..ColumnCount.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "columnType":
                    ColumnType = o.ToLiteral<int>();
                    break;
                case "columnCount":
                    ColumnCount = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeMatrix(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeImage : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeImage | (1 << 16);
    }

    public OpTypeImage(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeImage(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Dim Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Depth
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arrayed
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MS
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampled
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageFormat Imageformat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier? Accessqualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeImage inst) => inst.ResultId;
    public OpTypeImage(int resultId, int sampledType, Dim dim, int depth, int arrayed, int mS, int sampled, ImageFormat imageformat, AccessQualifier? accessqualifier)
    {
        ResultId = resultId;
        SampledType = sampledType;
        Dim = dim;
        Depth = depth;
        Arrayed = arrayed;
        MS = mS;
        Sampled = sampled;
        Imageformat = imageformat;
        Accessqualifier = accessqualifier;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeImage, ResultId, SampledType, (int)Dim, ..Depth.AsDisposableLiteralValue().Words, ..Arrayed.AsDisposableLiteralValue().Words, ..MS.AsDisposableLiteralValue().Words, ..Sampled.AsDisposableLiteralValue().Words, (int)Imageformat, ..(Accessqualifier is null ? (Span<int>)[] : [(int)Accessqualifier.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledType":
                    SampledType = o.ToLiteral<int>();
                    break;
                case "dim":
                    Dim = o.ToEnum<Dim>();
                    break;
                case "depth":
                    Depth = o.ToLiteral<int>();
                    break;
                case "arrayed":
                    Arrayed = o.ToLiteral<int>();
                    break;
                case "mS":
                    MS = o.ToLiteral<int>();
                    break;
                case "sampled":
                    Sampled = o.ToLiteral<int>();
                    break;
                case "imageformat":
                    Imageformat = o.ToEnum<ImageFormat>();
                    break;
                case "accessqualifier":
                    if (o.Words.Length > 0)
                    {
                        Accessqualifier = o.ToEnum<AccessQualifier>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeImage(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeSampler : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeSampler()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeSampler | (1 << 16);
    }

    public OpTypeSampler(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeSampler(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeSampler inst) => inst.ResultId;
    public OpTypeSampler(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeSampler, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeSampler(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeSampledImage : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeSampledImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeSampledImage | (1 << 16);
    }

    public OpTypeSampledImage(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeSampledImage(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeSampledImage inst) => inst.ResultId;
    public OpTypeSampledImage(int resultId, int imageType)
    {
        ResultId = resultId;
        ImageType = imageType;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeSampledImage, ResultId, ImageType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "imageType":
                    ImageType = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeSampledImage(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeArray : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeArray()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeArray | (1 << 16);
    }

    public OpTypeArray(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeArray(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ElementType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Length
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeArray inst) => inst.ResultId;
    public OpTypeArray(int resultId, int elementType, int length)
    {
        ResultId = resultId;
        ElementType = elementType;
        Length = length;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeArray, ResultId, ElementType, Length];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "elementType":
                    ElementType = o.ToLiteral<int>();
                    break;
                case "length":
                    Length = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeArray(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeRuntimeArray : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeRuntimeArray()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeRuntimeArray | (1 << 16);
    }

    public OpTypeRuntimeArray(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeRuntimeArray(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ElementType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeRuntimeArray inst) => inst.ResultId;
    public OpTypeRuntimeArray(int resultId, int elementType)
    {
        ResultId = resultId;
        ElementType = elementType;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeRuntimeArray, ResultId, ElementType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "elementType":
                    ElementType = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeRuntimeArray(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeStruct : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeStruct | (1 << 16);
    }

    public OpTypeStruct(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeStruct(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeStruct inst) => inst.ResultId;
    public OpTypeStruct(int resultId, LiteralArray<int> values)
    {
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeStruct, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTypeStruct(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpTypeOpaque : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeOpaque()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeOpaque | (1 << 16);
    }

    public OpTypeOpaque(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeOpaque(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Thenameoftheopaquetype
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeOpaque inst) => inst.ResultId;
    public OpTypeOpaque(int resultId, string thenameoftheopaquetype)
    {
        ResultId = resultId;
        Thenameoftheopaquetype = thenameoftheopaquetype;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeOpaque, ResultId, ..Thenameoftheopaquetype.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "thenameoftheopaquetype":
                    Thenameoftheopaquetype = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeOpaque(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypePointer : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePointer | (1 << 16);
    }

    public OpTypePointer(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypePointer(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypePointer inst) => inst.ResultId;
    public OpTypePointer(int resultId, StorageClass storageclass, int type)
    {
        ResultId = resultId;
        Storageclass = storageclass;
        Type = type;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePointer, ResultId, (int)Storageclass, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                case "type":
                    Type = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypePointer(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeFunction : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeFunction | (1 << 16);
    }

    public OpTypeFunction(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeFunction(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReturnType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeFunction inst) => inst.ResultId;
    public OpTypeFunction(int resultId, int returnType, LiteralArray<int> values)
    {
        ResultId = resultId;
        ReturnType = returnType;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeFunction, ResultId, ReturnType, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "returnType":
                    ReturnType = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTypeFunction(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpTypeEvent : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeEvent | (1 << 16);
    }

    public OpTypeEvent(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeEvent(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeEvent inst) => inst.ResultId;
    public OpTypeEvent(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeEvent, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeEvent(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeDeviceEvent : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeDeviceEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeDeviceEvent | (1 << 16);
    }

    public OpTypeDeviceEvent(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeDeviceEvent(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeDeviceEvent inst) => inst.ResultId;
    public OpTypeDeviceEvent(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeDeviceEvent, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeDeviceEvent(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeReserveId : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeReserveId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeReserveId | (1 << 16);
    }

    public OpTypeReserveId(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeReserveId(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeReserveId inst) => inst.ResultId;
    public OpTypeReserveId(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeReserveId, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeReserveId(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeQueue : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeQueue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeQueue | (1 << 16);
    }

    public OpTypeQueue(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeQueue(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeQueue inst) => inst.ResultId;
    public OpTypeQueue(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeQueue, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeQueue(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypePipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePipe | (1 << 16);
    }

    public OpTypePipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypePipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier Qualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypePipe inst) => inst.ResultId;
    public OpTypePipe(int resultId, AccessQualifier qualifier)
    {
        ResultId = resultId;
        Qualifier = qualifier;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePipe, ResultId, (int)Qualifier];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "qualifier":
                    Qualifier = o.ToEnum<AccessQualifier>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypePipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeForwardPointer : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeForwardPointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeForwardPointer | (1 << 16);
    }

    public OpTypeForwardPointer(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeForwardPointer(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int PointerType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeForwardPointer(int pointerType, StorageClass storageclass)
    {
        PointerType = pointerType;
        Storageclass = storageclass;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeForwardPointer, PointerType, (int)Storageclass];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointerType":
                    PointerType = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeForwardPointer(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantTrue : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantTrue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantTrue | (1 << 16);
    }

    public OpConstantTrue(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantTrue(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantTrue inst) => inst.ResultId;
    public OpConstantTrue(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantTrue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantTrue(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantFalse : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantFalse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantFalse | (1 << 16);
    }

    public OpConstantFalse(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantFalse(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantFalse inst) => inst.ResultId;
    public OpConstantFalse(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantFalse, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantFalse(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstant<T> : IMemoryInstruction where T : struct, INumber<T>
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstant()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstant | (1 << 16);
    }

    public OpConstant(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstant(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public T Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstant<T> inst) => inst.ResultId;
    public OpConstant(int resultType, int resultId, LiteralValue<T> value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstant, ResultType, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<LiteralValue<T>>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstant<T>(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantComposite : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantComposite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantComposite | (1 << 16);
    }

    public OpConstantComposite(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantComposite(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantComposite inst) => inst.ResultId;
    public OpConstantComposite(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantComposite, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpConstantComposite(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpConstantSampler : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantSampler()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantSampler | (1 << 16);
    }

    public OpConstantSampler(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantSampler(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SamplerAddressingMode Sampleraddressingmode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SamplerFilterMode Samplerfiltermode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantSampler inst) => inst.ResultId;
    public OpConstantSampler(int resultType, int resultId, SamplerAddressingMode sampleraddressingmode, int param, SamplerFilterMode samplerfiltermode)
    {
        ResultType = resultType;
        ResultId = resultId;
        Sampleraddressingmode = sampleraddressingmode;
        Param = param;
        Samplerfiltermode = samplerfiltermode;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantSampler, ResultType, ResultId, (int)Sampleraddressingmode, ..Param.AsDisposableLiteralValue().Words, (int)Samplerfiltermode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampleraddressingmode":
                    Sampleraddressingmode = o.ToEnum<SamplerAddressingMode>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "samplerfiltermode":
                    Samplerfiltermode = o.ToEnum<SamplerFilterMode>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantSampler(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantNull : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantNull()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantNull | (1 << 16);
    }

    public OpConstantNull(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantNull(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantNull inst) => inst.ResultId;
    public OpConstantNull(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantNull, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantNull(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSpecConstantTrue : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantTrue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantTrue | (1 << 16);
    }

    public OpSpecConstantTrue(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSpecConstantTrue(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantTrue inst) => inst.ResultId;
    public OpSpecConstantTrue(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantTrue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantTrue(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSpecConstantFalse : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantFalse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantFalse | (1 << 16);
    }

    public OpSpecConstantFalse(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSpecConstantFalse(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantFalse inst) => inst.ResultId;
    public OpSpecConstantFalse(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantFalse, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantFalse(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSpecConstant<T> : IMemoryInstruction where T : struct, INumber<T>
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstant()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstant | (1 << 16);
    }

    public OpSpecConstant(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSpecConstant(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public T Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstant<T> inst) => inst.ResultId;
    public OpSpecConstant(int resultType, int resultId, LiteralValue<T> value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstant, ResultType, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<LiteralValue<T>>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstant<T>(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSpecConstantComposite : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantComposite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantComposite | (1 << 16);
    }

    public OpSpecConstantComposite(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSpecConstantComposite(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantComposite inst) => inst.ResultId;
    public OpSpecConstantComposite(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantComposite, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpSpecConstantComposite(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSpecConstantOp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantOp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantOp | (1 << 16);
    }

    public OpSpecConstantOp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSpecConstantOp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Opcode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantOp inst) => inst.ResultId;
    public OpSpecConstantOp(int resultType, int resultId, int opcode)
    {
        ResultType = resultType;
        ResultId = resultId;
        Opcode = opcode;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantOp, ResultType, ResultId, ..Opcode.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "opcode":
                    Opcode = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantOp(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFunction : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunction | (1 << 16);
    }

    public OpFunction(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFunction(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public FunctionControlMask Functioncontrol
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FunctionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFunction inst) => inst.ResultId;
    public OpFunction(int resultType, int resultId, FunctionControlMask functioncontrol, int functionType)
    {
        ResultType = resultType;
        ResultId = resultId;
        Functioncontrol = functioncontrol;
        FunctionType = functionType;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunction, ResultType, ResultId, (int)Functioncontrol, FunctionType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "functioncontrol":
                    Functioncontrol = o.ToEnum<FunctionControlMask>();
                    break;
                case "functionType":
                    FunctionType = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFunction(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFunctionParameter : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionParameter()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionParameter | (1 << 16);
    }

    public OpFunctionParameter(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFunctionParameter(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFunctionParameter inst) => inst.ResultId;
    public OpFunctionParameter(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionParameter, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFunctionParameter(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFunctionEnd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionEnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionEnd | (1 << 16);
    }

    public OpFunctionEnd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFunctionEnd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionEnd];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFunctionEnd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFunctionCall : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionCall()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionCall | (1 << 16);
    }

    public OpFunctionCall(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFunctionCall(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Function
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFunctionCall inst) => inst.ResultId;
    public OpFunctionCall(int resultType, int resultId, int function, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Function = function;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionCall, ResultType, ResultId, Function, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "function":
                    Function = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpFunctionCall(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpVariable : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVariable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVariable | (1 << 16);
    }

    public OpVariable(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVariable(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Initializer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVariable inst) => inst.ResultId;
    public OpVariable(int resultType, int resultId, StorageClass storageclass, int? initializer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        Initializer = initializer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVariable, ResultType, ResultId, (int)Storageclass, ..(Initializer is null ? (Span<int>)[] : [Initializer.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                case "initializer":
                    if (o.Words.Length > 0)
                    {
                        Initializer = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpVariable(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageTexelPointer : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageTexelPointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageTexelPointer | (1 << 16);
    }

    public OpImageTexelPointer(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageTexelPointer(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageTexelPointer inst) => inst.ResultId;
    public OpImageTexelPointer(int resultType, int resultId, int image, int coordinate, int sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Sample = sample;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageTexelPointer, ResultType, ResultId, Image, Coordinate, Sample];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "sample":
                    Sample = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageTexelPointer(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLoad : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoad()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoad | (1 << 16);
    }

    public OpLoad(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLoad(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess { get; set; }

    public EnumerantParameters MemoryaccessParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLoad inst) => inst.ResultId;
    public OpLoad(int resultType, int resultId, int pointer, MemoryAccessMask? memoryaccess, EnumerantParameters memoryaccessParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memoryaccess = memoryaccess;
        MemoryaccessParameters = memoryaccessParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoad, ResultType, ResultId, Pointer, ..(Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value, ..MemoryaccessParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memoryaccess":
                    if (o.Words.Length > 0)
                    {
                        Memoryaccess = o.ToEnum<MemoryAccessMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            MemoryaccessParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLoad(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        MemoryaccessParameters.Dispose();
    }
}

public ref partial struct OpStore : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStore()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStore | (1 << 16);
    }

    public OpStore(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpStore(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess { get; set; }

    public EnumerantParameters MemoryaccessParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpStore(int pointer, int objectId, MemoryAccessMask? memoryaccess, EnumerantParameters memoryaccessParameters)
    {
        Pointer = pointer;
        ObjectId = objectId;
        Memoryaccess = memoryaccess;
        MemoryaccessParameters = memoryaccessParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStore, Pointer, ObjectId, ..(Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value, ..MemoryaccessParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "objectId":
                    ObjectId = o.ToLiteral<int>();
                    break;
                case "memoryaccess":
                    if (o.Words.Length > 0)
                    {
                        Memoryaccess = o.ToEnum<MemoryAccessMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            MemoryaccessParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpStore(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        MemoryaccessParameters.Dispose();
    }
}

public ref partial struct OpAccessChain : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAccessChain | (1 << 16);
    }

    public OpAccessChain(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAccessChain(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAccessChain inst) => inst.ResultId;
    public OpAccessChain(int resultType, int resultId, int baseId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAccessChain, ResultType, ResultId, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpAccessChain(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpInBoundsAccessChain : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpInBoundsAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpInBoundsAccessChain | (1 << 16);
    }

    public OpInBoundsAccessChain(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpInBoundsAccessChain(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpInBoundsAccessChain inst) => inst.ResultId;
    public OpInBoundsAccessChain(int resultType, int resultId, int baseId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpInBoundsAccessChain, ResultType, ResultId, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpInBoundsAccessChain(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpPtrAccessChain : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrAccessChain | (1 << 16);
    }

    public OpPtrAccessChain(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpPtrAccessChain(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrAccessChain inst) => inst.ResultId;
    public OpPtrAccessChain(int resultType, int resultId, int baseId, int element, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Element = element;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrAccessChain, ResultType, ResultId, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "element":
                    Element = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpPtrAccessChain(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpArrayLength : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArrayLength()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArrayLength | (1 << 16);
    }

    public OpArrayLength(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArrayLength(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Structure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arraymember
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArrayLength inst) => inst.ResultId;
    public OpArrayLength(int resultType, int resultId, int structure, int arraymember)
    {
        ResultType = resultType;
        ResultId = resultId;
        Structure = structure;
        Arraymember = arraymember;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArrayLength, ResultType, ResultId, Structure, ..Arraymember.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "structure":
                    Structure = o.ToLiteral<int>();
                    break;
                case "arraymember":
                    Arraymember = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArrayLength(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGenericPtrMemSemantics : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericPtrMemSemantics()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericPtrMemSemantics | (1 << 16);
    }

    public OpGenericPtrMemSemantics(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGenericPtrMemSemantics(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGenericPtrMemSemantics inst) => inst.ResultId;
    public OpGenericPtrMemSemantics(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericPtrMemSemantics, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGenericPtrMemSemantics(OpDataIndex odi) => new(odi);
}

public ref partial struct OpInBoundsPtrAccessChain : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpInBoundsPtrAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpInBoundsPtrAccessChain | (1 << 16);
    }

    public OpInBoundsPtrAccessChain(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpInBoundsPtrAccessChain(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpInBoundsPtrAccessChain inst) => inst.ResultId;
    public OpInBoundsPtrAccessChain(int resultType, int resultId, int baseId, int element, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Element = element;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpInBoundsPtrAccessChain, ResultType, ResultId, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "element":
                    Element = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpInBoundsPtrAccessChain(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpDecorate : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorate | (1 << 16);
    }

    public OpDecorate(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDecorate(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration { get; set; }

    public EnumerantParameters DecorationParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorate(int target, Decoration decoration, EnumerantParameters decorationParameters)
    {
        Target = target;
        Decoration = decoration;
        DecorationParameters = decorationParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorate, Target, (int)Decoration, ..DecorationParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    DecorationParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDecorate(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        DecorationParameters.Dispose();
    }
}

public ref partial struct OpMemberDecorate : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberDecorate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberDecorate | (1 << 16);
    }

    public OpMemberDecorate(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMemberDecorate(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int StructureType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration { get; set; }

    public EnumerantParameters DecorationParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberDecorate(int structureType, int member, Decoration decoration, EnumerantParameters decorationParameters)
    {
        StructureType = structureType;
        Member = member;
        Decoration = decoration;
        DecorationParameters = decorationParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberDecorate, StructureType, ..Member.AsDisposableLiteralValue().Words, (int)Decoration, ..DecorationParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "structureType":
                    StructureType = o.ToLiteral<int>();
                    break;
                case "member":
                    Member = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    DecorationParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMemberDecorate(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        DecorationParameters.Dispose();
    }
}

public ref partial struct OpDecorationGroup : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorationGroup()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorationGroup | (1 << 16);
    }

    public OpDecorationGroup(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDecorationGroup(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDecorationGroup inst) => inst.ResultId;
    public OpDecorationGroup(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorationGroup, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDecorationGroup(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupDecorate : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupDecorate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupDecorate | (1 << 16);
    }

    public OpGroupDecorate(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupDecorate(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int DecorationGroup
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupDecorate(int decorationGroup, LiteralArray<int> values)
    {
        DecorationGroup = decorationGroup;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupDecorate, DecorationGroup, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "decorationGroup":
                    DecorationGroup = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpGroupDecorate(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpGroupMemberDecorate : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupMemberDecorate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupMemberDecorate | (1 << 16);
    }

    public OpGroupMemberDecorate(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupMemberDecorate(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int DecorationGroup
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupMemberDecorate(int decorationGroup, LiteralArray<(int, int)> values)
    {
        DecorationGroup = decorationGroup;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupMemberDecorate, DecorationGroup, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "decorationGroup":
                    DecorationGroup = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<(int, int)>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpGroupMemberDecorate(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpVectorExtractDynamic : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorExtractDynamic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorExtractDynamic | (1 << 16);
    }

    public OpVectorExtractDynamic(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVectorExtractDynamic(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorExtractDynamic inst) => inst.ResultId;
    public OpVectorExtractDynamic(int resultType, int resultId, int vector, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Index = index;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorExtractDynamic, ResultType, ResultId, Vector, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpVectorExtractDynamic(OpDataIndex odi) => new(odi);
}

public ref partial struct OpVectorInsertDynamic : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorInsertDynamic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorInsertDynamic | (1 << 16);
    }

    public OpVectorInsertDynamic(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVectorInsertDynamic(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorInsertDynamic inst) => inst.ResultId;
    public OpVectorInsertDynamic(int resultType, int resultId, int vector, int component, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Component = component;
        Index = index;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorInsertDynamic, ResultType, ResultId, Vector, Component, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                case "component":
                    Component = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpVectorInsertDynamic(OpDataIndex odi) => new(odi);
}

public ref partial struct OpVectorShuffle : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorShuffle()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorShuffle | (1 << 16);
    }

    public OpVectorShuffle(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVectorShuffle(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorShuffle inst) => inst.ResultId;
    public OpVectorShuffle(int resultType, int resultId, int vector1, int vector2, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorShuffle, ResultType, ResultId, Vector1, Vector2, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpVectorShuffle(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpCompositeConstruct : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstruct | (1 << 16);
    }

    public OpCompositeConstruct(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCompositeConstruct(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeConstruct inst) => inst.ResultId;
    public OpCompositeConstruct(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstruct, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpCompositeConstruct(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpCompositeExtract : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeExtract | (1 << 16);
    }

    public OpCompositeExtract(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCompositeExtract(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Composite
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeExtract inst) => inst.ResultId;
    public OpCompositeExtract(int resultType, int resultId, int composite, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Composite = composite;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeExtract, ResultType, ResultId, Composite, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "composite":
                    Composite = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpCompositeExtract(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpCompositeInsert : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeInsert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeInsert | (1 << 16);
    }

    public OpCompositeInsert(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCompositeInsert(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Composite
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeInsert inst) => inst.ResultId;
    public OpCompositeInsert(int resultType, int resultId, int objectId, int composite, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        ObjectId = objectId;
        Composite = composite;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeInsert, ResultType, ResultId, ObjectId, Composite, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "objectId":
                    ObjectId = o.ToLiteral<int>();
                    break;
                case "composite":
                    Composite = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpCompositeInsert(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpCopyObject : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCopyObject()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCopyObject | (1 << 16);
    }

    public OpCopyObject(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCopyObject(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCopyObject inst) => inst.ResultId;
    public OpCopyObject(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCopyObject, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCopyObject(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTranspose : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTranspose()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTranspose | (1 << 16);
    }

    public OpTranspose(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTranspose(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTranspose inst) => inst.ResultId;
    public OpTranspose(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTranspose, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTranspose(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSampledImage : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSampledImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSampledImage | (1 << 16);
    }

    public OpSampledImage(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSampledImage(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampler
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSampledImage inst) => inst.ResultId;
    public OpSampledImage(int resultType, int resultId, int image, int sampler)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Sampler = sampler;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSampledImage, ResultType, ResultId, Image, Sampler];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "sampler":
                    Sampler = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSampledImage(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageSampleImplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleImplicitLod | (1 << 16);
    }

    public OpImageSampleImplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleImplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleImplicitLod inst) => inst.ResultId;
    public OpImageSampleImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleImplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSampleExplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleExplicitLod | (1 << 16);
    }

    public OpImageSampleExplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleExplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleExplicitLod inst) => inst.ResultId;
    public OpImageSampleExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleExplicitLod, ResultType, ResultId, SampledImage, Coordinate, (int)Imageoperands, ..ImageoperandsParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleExplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSampleDrefImplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleDrefImplicitLod | (1 << 16);
    }

    public OpImageSampleDrefImplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleDrefImplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleDrefImplicitLod inst) => inst.ResultId;
    public OpImageSampleDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleDrefImplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSampleDrefExplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleDrefExplicitLod | (1 << 16);
    }

    public OpImageSampleDrefExplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleDrefExplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleDrefExplicitLod inst) => inst.ResultId;
    public OpImageSampleDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, (int)Imageoperands, ..ImageoperandsParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleDrefExplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSampleProjImplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjImplicitLod | (1 << 16);
    }

    public OpImageSampleProjImplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleProjImplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleProjImplicitLod inst) => inst.ResultId;
    public OpImageSampleProjImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleProjImplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSampleProjExplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjExplicitLod | (1 << 16);
    }

    public OpImageSampleProjExplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleProjExplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleProjExplicitLod inst) => inst.ResultId;
    public OpImageSampleProjExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjExplicitLod, ResultType, ResultId, SampledImage, Coordinate, (int)Imageoperands, ..ImageoperandsParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleProjExplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSampleProjDrefImplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjDrefImplicitLod | (1 << 16);
    }

    public OpImageSampleProjDrefImplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleProjDrefImplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleProjDrefImplicitLod inst) => inst.ResultId;
    public OpImageSampleProjDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleProjDrefImplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSampleProjDrefExplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjDrefExplicitLod | (1 << 16);
    }

    public OpImageSampleProjDrefExplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleProjDrefExplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleProjDrefExplicitLod inst) => inst.ResultId;
    public OpImageSampleProjDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, (int)Imageoperands, ..ImageoperandsParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleProjDrefExplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageFetch : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageFetch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageFetch | (1 << 16);
    }

    public OpImageFetch(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageFetch(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageFetch inst) => inst.ResultId;
    public OpImageFetch(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageFetch, ResultType, ResultId, Image, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageFetch(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageGather : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageGather | (1 << 16);
    }

    public OpImageGather(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageGather(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageGather inst) => inst.ResultId;
    public OpImageGather(int resultType, int resultId, int sampledImage, int coordinate, int component, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Component = component;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageGather, ResultType, ResultId, SampledImage, Coordinate, Component, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "component":
                    Component = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageGather(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageDrefGather : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageDrefGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageDrefGather | (1 << 16);
    }

    public OpImageDrefGather(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageDrefGather(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageDrefGather inst) => inst.ResultId;
    public OpImageDrefGather(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageDrefGather, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageDrefGather(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageRead : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageRead()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageRead | (1 << 16);
    }

    public OpImageRead(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageRead(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageRead inst) => inst.ResultId;
    public OpImageRead(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageRead, ResultType, ResultId, Image, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageRead(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageWrite : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageWrite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageWrite | (1 << 16);
    }

    public OpImageWrite(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageWrite(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageWrite(int image, int coordinate, int texel, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        Image = image;
        Coordinate = coordinate;
        Texel = texel;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageWrite, Image, Coordinate, Texel, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "texel":
                    Texel = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageWrite(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImage : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImage | (1 << 16);
    }

    public OpImage(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImage(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImage inst) => inst.ResultId;
    public OpImage(int resultType, int resultId, int sampledImage)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImage, ResultType, ResultId, SampledImage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImage(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageQueryFormat : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryFormat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryFormat | (1 << 16);
    }

    public OpImageQueryFormat(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageQueryFormat(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQueryFormat inst) => inst.ResultId;
    public OpImageQueryFormat(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryFormat, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageQueryFormat(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageQueryOrder : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryOrder()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryOrder | (1 << 16);
    }

    public OpImageQueryOrder(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageQueryOrder(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQueryOrder inst) => inst.ResultId;
    public OpImageQueryOrder(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryOrder, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageQueryOrder(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageQuerySizeLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySizeLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySizeLod | (1 << 16);
    }

    public OpImageQuerySizeLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageQuerySizeLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LevelofDetail
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQuerySizeLod inst) => inst.ResultId;
    public OpImageQuerySizeLod(int resultType, int resultId, int image, int levelofDetail)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        LevelofDetail = levelofDetail;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySizeLod, ResultType, ResultId, Image, LevelofDetail];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "levelofDetail":
                    LevelofDetail = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageQuerySizeLod(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageQuerySize : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySize | (1 << 16);
    }

    public OpImageQuerySize(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageQuerySize(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQuerySize inst) => inst.ResultId;
    public OpImageQuerySize(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySize, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageQuerySize(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageQueryLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryLod | (1 << 16);
    }

    public OpImageQueryLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageQueryLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQueryLod inst) => inst.ResultId;
    public OpImageQueryLod(int resultType, int resultId, int sampledImage, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryLod, ResultType, ResultId, SampledImage, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageQueryLod(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageQueryLevels : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryLevels()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryLevels | (1 << 16);
    }

    public OpImageQueryLevels(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageQueryLevels(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQueryLevels inst) => inst.ResultId;
    public OpImageQueryLevels(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryLevels, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageQueryLevels(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageQuerySamples : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySamples()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySamples | (1 << 16);
    }

    public OpImageQuerySamples(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageQuerySamples(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQuerySamples inst) => inst.ResultId;
    public OpImageQuerySamples(int resultType, int resultId, int image)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySamples, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageQuerySamples(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertFToU : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToU | (1 << 16);
    }

    public OpConvertFToU(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertFToU(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertFToU inst) => inst.ResultId;
    public OpConvertFToU(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToU, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "floatValue":
                    FloatValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertFToU(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertFToS : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToS()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToS | (1 << 16);
    }

    public OpConvertFToS(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertFToS(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertFToS inst) => inst.ResultId;
    public OpConvertFToS(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToS, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "floatValue":
                    FloatValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertFToS(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertSToF : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSToF()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSToF | (1 << 16);
    }

    public OpConvertSToF(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertSToF(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertSToF inst) => inst.ResultId;
    public OpConvertSToF(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSToF, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "signedValue":
                    SignedValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertSToF(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertUToF : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToF()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToF | (1 << 16);
    }

    public OpConvertUToF(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertUToF(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToF inst) => inst.ResultId;
    public OpConvertUToF(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToF, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "unsignedValue":
                    UnsignedValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToF(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUConvert : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUConvert | (1 << 16);
    }

    public OpUConvert(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUConvert(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUConvert inst) => inst.ResultId;
    public OpUConvert(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUConvert, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "unsignedValue":
                    UnsignedValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUConvert(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSConvert : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSConvert | (1 << 16);
    }

    public OpSConvert(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSConvert(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSConvert inst) => inst.ResultId;
    public OpSConvert(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSConvert, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "signedValue":
                    SignedValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSConvert(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFConvert : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFConvert | (1 << 16);
    }

    public OpFConvert(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFConvert(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFConvert inst) => inst.ResultId;
    public OpFConvert(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFConvert, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "floatValue":
                    FloatValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFConvert(OpDataIndex odi) => new(odi);
}

public ref partial struct OpQuantizeToF16 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpQuantizeToF16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpQuantizeToF16 | (1 << 16);
    }

    public OpQuantizeToF16(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpQuantizeToF16(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpQuantizeToF16 inst) => inst.ResultId;
    public OpQuantizeToF16(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpQuantizeToF16, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpQuantizeToF16(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertPtrToU : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertPtrToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertPtrToU | (1 << 16);
    }

    public OpConvertPtrToU(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertPtrToU(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertPtrToU inst) => inst.ResultId;
    public OpConvertPtrToU(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertPtrToU, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertPtrToU(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSatConvertSToU : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSatConvertSToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSatConvertSToU | (1 << 16);
    }

    public OpSatConvertSToU(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSatConvertSToU(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSatConvertSToU inst) => inst.ResultId;
    public OpSatConvertSToU(int resultType, int resultId, int signedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSatConvertSToU, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "signedValue":
                    SignedValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSatConvertSToU(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSatConvertUToS : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSatConvertUToS()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSatConvertUToS | (1 << 16);
    }

    public OpSatConvertUToS(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSatConvertUToS(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSatConvertUToS inst) => inst.ResultId;
    public OpSatConvertUToS(int resultType, int resultId, int unsignedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSatConvertUToS, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "unsignedValue":
                    UnsignedValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSatConvertUToS(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertUToPtr : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToPtr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToPtr | (1 << 16);
    }

    public OpConvertUToPtr(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertUToPtr(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntegerValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToPtr inst) => inst.ResultId;
    public OpConvertUToPtr(int resultType, int resultId, int integerValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        IntegerValue = integerValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToPtr, ResultType, ResultId, IntegerValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "integerValue":
                    IntegerValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToPtr(OpDataIndex odi) => new(odi);
}

public ref partial struct OpPtrCastToGeneric : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrCastToGeneric()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrCastToGeneric | (1 << 16);
    }

    public OpPtrCastToGeneric(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpPtrCastToGeneric(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrCastToGeneric inst) => inst.ResultId;
    public OpPtrCastToGeneric(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrCastToGeneric, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpPtrCastToGeneric(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGenericCastToPtr : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericCastToPtr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericCastToPtr | (1 << 16);
    }

    public OpGenericCastToPtr(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGenericCastToPtr(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGenericCastToPtr inst) => inst.ResultId;
    public OpGenericCastToPtr(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericCastToPtr, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGenericCastToPtr(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGenericCastToPtrExplicit : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericCastToPtrExplicit()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericCastToPtrExplicit | (1 << 16);
    }

    public OpGenericCastToPtrExplicit(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGenericCastToPtrExplicit(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGenericCastToPtrExplicit inst) => inst.ResultId;
    public OpGenericCastToPtrExplicit(int resultType, int resultId, int pointer, StorageClass storage)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Storage = storage;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericCastToPtrExplicit, ResultType, ResultId, Pointer, (int)Storage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "storage":
                    Storage = o.ToEnum<StorageClass>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGenericCastToPtrExplicit(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitcast : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitcast | (1 << 16);
    }

    public OpBitcast(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitcast(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitcast inst) => inst.ResultId;
    public OpBitcast(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitcast, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitcast(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSNegate : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSNegate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSNegate | (1 << 16);
    }

    public OpSNegate(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSNegate(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSNegate inst) => inst.ResultId;
    public OpSNegate(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSNegate, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSNegate(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFNegate : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFNegate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFNegate | (1 << 16);
    }

    public OpFNegate(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFNegate(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFNegate inst) => inst.ResultId;
    public OpFNegate(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFNegate, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFNegate(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIAdd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAdd | (1 << 16);
    }

    public OpIAdd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIAdd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAdd inst) => inst.ResultId;
    public OpIAdd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAdd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIAdd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFAdd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFAdd | (1 << 16);
    }

    public OpFAdd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFAdd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFAdd inst) => inst.ResultId;
    public OpFAdd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFAdd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFAdd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpISub : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISub | (1 << 16);
    }

    public OpISub(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpISub(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpISub inst) => inst.ResultId;
    public OpISub(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISub, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpISub(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFSub : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFSub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFSub | (1 << 16);
    }

    public OpFSub(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFSub(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFSub inst) => inst.ResultId;
    public OpFSub(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFSub, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFSub(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIMul : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIMul | (1 << 16);
    }

    public OpIMul(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIMul(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIMul inst) => inst.ResultId;
    public OpIMul(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIMul, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIMul(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFMul : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFMul | (1 << 16);
    }

    public OpFMul(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFMul(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFMul inst) => inst.ResultId;
    public OpFMul(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFMul, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFMul(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUDiv : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDiv | (1 << 16);
    }

    public OpUDiv(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUDiv(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUDiv inst) => inst.ResultId;
    public OpUDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUDiv(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDiv : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDiv | (1 << 16);
    }

    public OpSDiv(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDiv(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDiv inst) => inst.ResultId;
    public OpSDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDiv(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFDiv : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFDiv | (1 << 16);
    }

    public OpFDiv(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFDiv(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFDiv inst) => inst.ResultId;
    public OpFDiv(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFDiv(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUMod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMod | (1 << 16);
    }

    public OpUMod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUMod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUMod inst) => inst.ResultId;
    public OpUMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUMod(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSRem : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSRem()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSRem | (1 << 16);
    }

    public OpSRem(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSRem(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSRem inst) => inst.ResultId;
    public OpSRem(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSRem, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSRem(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSMod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSMod | (1 << 16);
    }

    public OpSMod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSMod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSMod inst) => inst.ResultId;
    public OpSMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSMod(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFRem : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFRem()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFRem | (1 << 16);
    }

    public OpFRem(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFRem(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFRem inst) => inst.ResultId;
    public OpFRem(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFRem, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFRem(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFMod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFMod | (1 << 16);
    }

    public OpFMod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFMod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFMod inst) => inst.ResultId;
    public OpFMod(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFMod(OpDataIndex odi) => new(odi);
}

public ref partial struct OpVectorTimesScalar : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorTimesScalar()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorTimesScalar | (1 << 16);
    }

    public OpVectorTimesScalar(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVectorTimesScalar(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scalar
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorTimesScalar inst) => inst.ResultId;
    public OpVectorTimesScalar(int resultType, int resultId, int vector, int scalar)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Scalar = scalar;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorTimesScalar, ResultType, ResultId, Vector, Scalar];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                case "scalar":
                    Scalar = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpVectorTimesScalar(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMatrixTimesScalar : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesScalar()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesScalar | (1 << 16);
    }

    public OpMatrixTimesScalar(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMatrixTimesScalar(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scalar
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMatrixTimesScalar inst) => inst.ResultId;
    public OpMatrixTimesScalar(int resultType, int resultId, int matrix, int scalar)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Scalar = scalar;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesScalar, ResultType, ResultId, Matrix, Scalar];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                case "scalar":
                    Scalar = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMatrixTimesScalar(OpDataIndex odi) => new(odi);
}

public ref partial struct OpVectorTimesMatrix : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorTimesMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorTimesMatrix | (1 << 16);
    }

    public OpVectorTimesMatrix(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVectorTimesMatrix(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorTimesMatrix inst) => inst.ResultId;
    public OpVectorTimesMatrix(int resultType, int resultId, int vector, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Matrix = matrix;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorTimesMatrix, ResultType, ResultId, Vector, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpVectorTimesMatrix(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMatrixTimesVector : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesVector()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesVector | (1 << 16);
    }

    public OpMatrixTimesVector(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMatrixTimesVector(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMatrixTimesVector inst) => inst.ResultId;
    public OpMatrixTimesVector(int resultType, int resultId, int matrix, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Vector = vector;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesVector, ResultType, ResultId, Matrix, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMatrixTimesVector(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMatrixTimesMatrix : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesMatrix | (1 << 16);
    }

    public OpMatrixTimesMatrix(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMatrixTimesMatrix(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftMatrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RightMatrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMatrixTimesMatrix inst) => inst.ResultId;
    public OpMatrixTimesMatrix(int resultType, int resultId, int leftMatrix, int rightMatrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        LeftMatrix = leftMatrix;
        RightMatrix = rightMatrix;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesMatrix, ResultType, ResultId, LeftMatrix, RightMatrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "leftMatrix":
                    LeftMatrix = o.ToLiteral<int>();
                    break;
                case "rightMatrix":
                    RightMatrix = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMatrixTimesMatrix(OpDataIndex odi) => new(odi);
}

public ref partial struct OpOuterProduct : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpOuterProduct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpOuterProduct | (1 << 16);
    }

    public OpOuterProduct(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpOuterProduct(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpOuterProduct inst) => inst.ResultId;
    public OpOuterProduct(int resultType, int resultId, int vector1, int vector2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpOuterProduct, ResultType, ResultId, Vector1, Vector2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpOuterProduct(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDot : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDot | (1 << 16);
    }

    public OpDot(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDot(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDot inst) => inst.ResultId;
    public OpDot(int resultType, int resultId, int vector1, int vector2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDot, ResultType, ResultId, Vector1, Vector2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDot(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIAddCarry : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAddCarry()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAddCarry | (1 << 16);
    }

    public OpIAddCarry(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIAddCarry(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAddCarry inst) => inst.ResultId;
    public OpIAddCarry(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAddCarry, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIAddCarry(OpDataIndex odi) => new(odi);
}

public ref partial struct OpISubBorrow : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISubBorrow()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISubBorrow | (1 << 16);
    }

    public OpISubBorrow(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpISubBorrow(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpISubBorrow inst) => inst.ResultId;
    public OpISubBorrow(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISubBorrow, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpISubBorrow(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUMulExtended : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMulExtended()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMulExtended | (1 << 16);
    }

    public OpUMulExtended(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUMulExtended(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUMulExtended inst) => inst.ResultId;
    public OpUMulExtended(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMulExtended, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUMulExtended(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSMulExtended : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSMulExtended()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSMulExtended | (1 << 16);
    }

    public OpSMulExtended(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSMulExtended(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSMulExtended inst) => inst.ResultId;
    public OpSMulExtended(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSMulExtended, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSMulExtended(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAny : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAny | (1 << 16);
    }

    public OpAny(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAny(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAny inst) => inst.ResultId;
    public OpAny(int resultType, int resultId, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAny, ResultType, ResultId, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAny(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAll : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAll | (1 << 16);
    }

    public OpAll(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAll(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAll inst) => inst.ResultId;
    public OpAll(int resultType, int resultId, int vector)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAll, ResultType, ResultId, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAll(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIsNan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNan | (1 << 16);
    }

    public OpIsNan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIsNan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsNan inst) => inst.ResultId;
    public OpIsNan(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNan, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIsNan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIsInf : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsInf()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsInf | (1 << 16);
    }

    public OpIsInf(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIsInf(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsInf inst) => inst.ResultId;
    public OpIsInf(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsInf, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIsInf(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIsFinite : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsFinite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsFinite | (1 << 16);
    }

    public OpIsFinite(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIsFinite(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsFinite inst) => inst.ResultId;
    public OpIsFinite(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsFinite, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIsFinite(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIsNormal : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNormal()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNormal | (1 << 16);
    }

    public OpIsNormal(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIsNormal(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsNormal inst) => inst.ResultId;
    public OpIsNormal(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNormal, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIsNormal(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSignBitSet : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSignBitSet()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSignBitSet | (1 << 16);
    }

    public OpSignBitSet(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSignBitSet(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSignBitSet inst) => inst.ResultId;
    public OpSignBitSet(int resultType, int resultId, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSignBitSet, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSignBitSet(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLessOrGreater : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLessOrGreater()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLessOrGreater | (1 << 16);
    }

    public OpLessOrGreater(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLessOrGreater(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLessOrGreater inst) => inst.ResultId;
    public OpLessOrGreater(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLessOrGreater, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLessOrGreater(OpDataIndex odi) => new(odi);
}

public ref partial struct OpOrdered : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpOrdered()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpOrdered | (1 << 16);
    }

    public OpOrdered(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpOrdered(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpOrdered inst) => inst.ResultId;
    public OpOrdered(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpOrdered, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpOrdered(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUnordered : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnordered()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUnordered | (1 << 16);
    }

    public OpUnordered(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUnordered(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUnordered inst) => inst.ResultId;
    public OpUnordered(int resultType, int resultId, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUnordered, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUnordered(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLogicalEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalEqual | (1 << 16);
    }

    public OpLogicalEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLogicalEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalEqual inst) => inst.ResultId;
    public OpLogicalEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLogicalEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLogicalNotEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalNotEqual | (1 << 16);
    }

    public OpLogicalNotEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLogicalNotEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalNotEqual inst) => inst.ResultId;
    public OpLogicalNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLogicalNotEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLogicalOr : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalOr | (1 << 16);
    }

    public OpLogicalOr(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLogicalOr(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalOr inst) => inst.ResultId;
    public OpLogicalOr(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalOr, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLogicalOr(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLogicalAnd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalAnd | (1 << 16);
    }

    public OpLogicalAnd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLogicalAnd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalAnd inst) => inst.ResultId;
    public OpLogicalAnd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalAnd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLogicalAnd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLogicalNot : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalNot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalNot | (1 << 16);
    }

    public OpLogicalNot(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLogicalNot(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalNot inst) => inst.ResultId;
    public OpLogicalNot(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalNot, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLogicalNot(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSelect : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSelect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSelect | (1 << 16);
    }

    public OpSelect(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSelect(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Object1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Object2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSelect inst) => inst.ResultId;
    public OpSelect(int resultType, int resultId, int condition, int object1, int object2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Condition = condition;
        Object1 = object1;
        Object2 = object2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSelect, ResultType, ResultId, Condition, Object1, Object2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "condition":
                    Condition = o.ToLiteral<int>();
                    break;
                case "object1":
                    Object1 = o.ToLiteral<int>();
                    break;
                case "object2":
                    Object2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSelect(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIEqual | (1 << 16);
    }

    public OpIEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIEqual inst) => inst.ResultId;
    public OpIEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpINotEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpINotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpINotEqual | (1 << 16);
    }

    public OpINotEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpINotEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpINotEqual inst) => inst.ResultId;
    public OpINotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpINotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpINotEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUGreaterThan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUGreaterThan | (1 << 16);
    }

    public OpUGreaterThan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUGreaterThan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUGreaterThan inst) => inst.ResultId;
    public OpUGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUGreaterThan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSGreaterThan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSGreaterThan | (1 << 16);
    }

    public OpSGreaterThan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSGreaterThan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSGreaterThan inst) => inst.ResultId;
    public OpSGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSGreaterThan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUGreaterThanEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUGreaterThanEqual | (1 << 16);
    }

    public OpUGreaterThanEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUGreaterThanEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUGreaterThanEqual inst) => inst.ResultId;
    public OpUGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSGreaterThanEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSGreaterThanEqual | (1 << 16);
    }

    public OpSGreaterThanEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSGreaterThanEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSGreaterThanEqual inst) => inst.ResultId;
    public OpSGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpULessThan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpULessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpULessThan | (1 << 16);
    }

    public OpULessThan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpULessThan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpULessThan inst) => inst.ResultId;
    public OpULessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpULessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpULessThan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSLessThan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSLessThan | (1 << 16);
    }

    public OpSLessThan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSLessThan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSLessThan inst) => inst.ResultId;
    public OpSLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSLessThan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpULessThanEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpULessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpULessThanEqual | (1 << 16);
    }

    public OpULessThanEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpULessThanEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpULessThanEqual inst) => inst.ResultId;
    public OpULessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpULessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpULessThanEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSLessThanEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSLessThanEqual | (1 << 16);
    }

    public OpSLessThanEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSLessThanEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSLessThanEqual inst) => inst.ResultId;
    public OpSLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSLessThanEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFOrdEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdEqual | (1 << 16);
    }

    public OpFOrdEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFOrdEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdEqual inst) => inst.ResultId;
    public OpFOrdEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFOrdEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFUnordEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordEqual | (1 << 16);
    }

    public OpFUnordEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFUnordEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordEqual inst) => inst.ResultId;
    public OpFUnordEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFUnordEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFOrdNotEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdNotEqual | (1 << 16);
    }

    public OpFOrdNotEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFOrdNotEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdNotEqual inst) => inst.ResultId;
    public OpFOrdNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFOrdNotEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFUnordNotEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordNotEqual | (1 << 16);
    }

    public OpFUnordNotEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFUnordNotEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordNotEqual inst) => inst.ResultId;
    public OpFUnordNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFUnordNotEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFOrdLessThan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdLessThan | (1 << 16);
    }

    public OpFOrdLessThan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFOrdLessThan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdLessThan inst) => inst.ResultId;
    public OpFOrdLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFOrdLessThan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFUnordLessThan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordLessThan | (1 << 16);
    }

    public OpFUnordLessThan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFUnordLessThan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordLessThan inst) => inst.ResultId;
    public OpFUnordLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFUnordLessThan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFOrdGreaterThan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdGreaterThan | (1 << 16);
    }

    public OpFOrdGreaterThan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFOrdGreaterThan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdGreaterThan inst) => inst.ResultId;
    public OpFOrdGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFOrdGreaterThan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFUnordGreaterThan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordGreaterThan | (1 << 16);
    }

    public OpFUnordGreaterThan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFUnordGreaterThan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordGreaterThan inst) => inst.ResultId;
    public OpFUnordGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFUnordGreaterThan(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFOrdLessThanEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdLessThanEqual | (1 << 16);
    }

    public OpFOrdLessThanEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFOrdLessThanEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdLessThanEqual inst) => inst.ResultId;
    public OpFOrdLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFOrdLessThanEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFUnordLessThanEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordLessThanEqual | (1 << 16);
    }

    public OpFUnordLessThanEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFUnordLessThanEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordLessThanEqual inst) => inst.ResultId;
    public OpFUnordLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFUnordLessThanEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFOrdGreaterThanEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdGreaterThanEqual | (1 << 16);
    }

    public OpFOrdGreaterThanEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFOrdGreaterThanEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdGreaterThanEqual inst) => inst.ResultId;
    public OpFOrdGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFOrdGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFUnordGreaterThanEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordGreaterThanEqual | (1 << 16);
    }

    public OpFUnordGreaterThanEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFUnordGreaterThanEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordGreaterThanEqual inst) => inst.ResultId;
    public OpFUnordGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFUnordGreaterThanEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpShiftRightLogical : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftRightLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftRightLogical | (1 << 16);
    }

    public OpShiftRightLogical(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpShiftRightLogical(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpShiftRightLogical inst) => inst.ResultId;
    public OpShiftRightLogical(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftRightLogical, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "shift":
                    Shift = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpShiftRightLogical(OpDataIndex odi) => new(odi);
}

public ref partial struct OpShiftRightArithmetic : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftRightArithmetic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftRightArithmetic | (1 << 16);
    }

    public OpShiftRightArithmetic(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpShiftRightArithmetic(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpShiftRightArithmetic inst) => inst.ResultId;
    public OpShiftRightArithmetic(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftRightArithmetic, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "shift":
                    Shift = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpShiftRightArithmetic(OpDataIndex odi) => new(odi);
}

public ref partial struct OpShiftLeftLogical : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftLeftLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftLeftLogical | (1 << 16);
    }

    public OpShiftLeftLogical(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpShiftLeftLogical(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpShiftLeftLogical inst) => inst.ResultId;
    public OpShiftLeftLogical(int resultType, int resultId, int baseId, int shift)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftLeftLogical, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "shift":
                    Shift = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpShiftLeftLogical(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitwiseOr : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseOr | (1 << 16);
    }

    public OpBitwiseOr(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitwiseOr(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitwiseOr inst) => inst.ResultId;
    public OpBitwiseOr(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseOr, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitwiseOr(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitwiseXor : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseXor | (1 << 16);
    }

    public OpBitwiseXor(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitwiseXor(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitwiseXor inst) => inst.ResultId;
    public OpBitwiseXor(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseXor, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitwiseXor(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitwiseAnd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseAnd | (1 << 16);
    }

    public OpBitwiseAnd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitwiseAnd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitwiseAnd inst) => inst.ResultId;
    public OpBitwiseAnd(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseAnd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitwiseAnd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpNot : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNot | (1 << 16);
    }

    public OpNot(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpNot(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpNot inst) => inst.ResultId;
    public OpNot(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNot, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpNot(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitFieldInsert : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldInsert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldInsert | (1 << 16);
    }

    public OpBitFieldInsert(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitFieldInsert(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Insert
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitFieldInsert inst) => inst.ResultId;
    public OpBitFieldInsert(int resultType, int resultId, int baseId, int insert, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Insert = insert;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldInsert, ResultType, ResultId, BaseId, Insert, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "insert":
                    Insert = o.ToLiteral<int>();
                    break;
                case "offset":
                    Offset = o.ToLiteral<int>();
                    break;
                case "count":
                    Count = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitFieldInsert(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitFieldSExtract : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldSExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldSExtract | (1 << 16);
    }

    public OpBitFieldSExtract(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitFieldSExtract(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitFieldSExtract inst) => inst.ResultId;
    public OpBitFieldSExtract(int resultType, int resultId, int baseId, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldSExtract, ResultType, ResultId, BaseId, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "offset":
                    Offset = o.ToLiteral<int>();
                    break;
                case "count":
                    Count = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitFieldSExtract(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitFieldUExtract : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldUExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldUExtract | (1 << 16);
    }

    public OpBitFieldUExtract(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitFieldUExtract(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitFieldUExtract inst) => inst.ResultId;
    public OpBitFieldUExtract(int resultType, int resultId, int baseId, int offset, int count)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Offset = offset;
        Count = count;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldUExtract, ResultType, ResultId, BaseId, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "offset":
                    Offset = o.ToLiteral<int>();
                    break;
                case "count":
                    Count = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitFieldUExtract(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitReverse : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitReverse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitReverse | (1 << 16);
    }

    public OpBitReverse(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitReverse(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitReverse inst) => inst.ResultId;
    public OpBitReverse(int resultType, int resultId, int baseId)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitReverse, ResultType, ResultId, BaseId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitReverse(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBitCount : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitCount | (1 << 16);
    }

    public OpBitCount(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBitCount(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitCount inst) => inst.ResultId;
    public OpBitCount(int resultType, int resultId, int baseId)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitCount, ResultType, ResultId, BaseId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBitCount(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDPdx : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdx()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdx | (1 << 16);
    }

    public OpDPdx(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDPdx(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdx inst) => inst.ResultId;
    public OpDPdx(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdx, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDPdx(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDPdy : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdy()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdy | (1 << 16);
    }

    public OpDPdy(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDPdy(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdy inst) => inst.ResultId;
    public OpDPdy(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdy, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDPdy(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFwidth : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidth()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidth | (1 << 16);
    }

    public OpFwidth(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFwidth(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFwidth inst) => inst.ResultId;
    public OpFwidth(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidth, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFwidth(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDPdxFine : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdxFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdxFine | (1 << 16);
    }

    public OpDPdxFine(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDPdxFine(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdxFine inst) => inst.ResultId;
    public OpDPdxFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdxFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDPdxFine(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDPdyFine : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdyFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdyFine | (1 << 16);
    }

    public OpDPdyFine(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDPdyFine(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdyFine inst) => inst.ResultId;
    public OpDPdyFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdyFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDPdyFine(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFwidthFine : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidthFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidthFine | (1 << 16);
    }

    public OpFwidthFine(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFwidthFine(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFwidthFine inst) => inst.ResultId;
    public OpFwidthFine(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidthFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFwidthFine(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDPdxCoarse : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdxCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdxCoarse | (1 << 16);
    }

    public OpDPdxCoarse(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDPdxCoarse(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdxCoarse inst) => inst.ResultId;
    public OpDPdxCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdxCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDPdxCoarse(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDPdyCoarse : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdyCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdyCoarse | (1 << 16);
    }

    public OpDPdyCoarse(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDPdyCoarse(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdyCoarse inst) => inst.ResultId;
    public OpDPdyCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdyCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDPdyCoarse(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFwidthCoarse : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidthCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidthCoarse | (1 << 16);
    }

    public OpFwidthCoarse(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFwidthCoarse(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFwidthCoarse inst) => inst.ResultId;
    public OpFwidthCoarse(int resultType, int resultId, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidthCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFwidthCoarse(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEmitVertex : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitVertex()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitVertex | (1 << 16);
    }

    public OpEmitVertex(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEmitVertex(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEmitVertex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpEmitVertex(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEndPrimitive : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndPrimitive()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndPrimitive | (1 << 16);
    }

    public OpEndPrimitive(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEndPrimitive(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEndPrimitive];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpEndPrimitive(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEmitStreamVertex : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitStreamVertex()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitStreamVertex | (1 << 16);
    }

    public OpEmitStreamVertex(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEmitStreamVertex(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Stream
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEmitStreamVertex(int stream)
    {
        Stream = stream;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEmitStreamVertex, Stream];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "stream":
                    Stream = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpEmitStreamVertex(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEndStreamPrimitive : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndStreamPrimitive()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndStreamPrimitive | (1 << 16);
    }

    public OpEndStreamPrimitive(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEndStreamPrimitive(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Stream
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEndStreamPrimitive(int stream)
    {
        Stream = stream;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEndStreamPrimitive, Stream];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "stream":
                    Stream = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpEndStreamPrimitive(OpDataIndex odi) => new(odi);
}

public ref partial struct OpControlBarrier : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrier | (1 << 16);
    }

    public OpControlBarrier(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpControlBarrier(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrier(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrier, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpControlBarrier(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMemoryBarrier : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryBarrier | (1 << 16);
    }

    public OpMemoryBarrier(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMemoryBarrier(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryBarrier(int memory, int semantics)
    {
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryBarrier, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMemoryBarrier(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicLoad : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicLoad()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicLoad | (1 << 16);
    }

    public OpAtomicLoad(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicLoad(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicLoad inst) => inst.ResultId;
    public OpAtomicLoad(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicLoad, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicLoad(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicStore : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicStore()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicStore | (1 << 16);
    }

    public OpAtomicStore(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicStore(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicStore(int pointer, int memory, int semantics, int value)
    {
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicStore, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicStore(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicExchange : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicExchange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicExchange | (1 << 16);
    }

    public OpAtomicExchange(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicExchange(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicExchange inst) => inst.ResultId;
    public OpAtomicExchange(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicExchange, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicExchange(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicCompareExchange : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicCompareExchange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicCompareExchange | (1 << 16);
    }

    public OpAtomicCompareExchange(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicCompareExchange(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Equal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Unequal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Comparator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicCompareExchange inst) => inst.ResultId;
    public OpAtomicCompareExchange(int resultType, int resultId, int pointer, int memory, int equal, int unequal, int value, int comparator)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Equal = equal;
        Unequal = unequal;
        Value = value;
        Comparator = comparator;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicCompareExchange, ResultType, ResultId, Pointer, Memory, Equal, Unequal, Value, Comparator];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "equal":
                    Equal = o.ToLiteral<int>();
                    break;
                case "unequal":
                    Unequal = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "comparator":
                    Comparator = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicCompareExchange(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicCompareExchangeWeak : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicCompareExchangeWeak()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicCompareExchangeWeak | (1 << 16);
    }

    public OpAtomicCompareExchangeWeak(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicCompareExchangeWeak(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Equal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Unequal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Comparator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicCompareExchangeWeak inst) => inst.ResultId;
    public OpAtomicCompareExchangeWeak(int resultType, int resultId, int pointer, int memory, int equal, int unequal, int value, int comparator)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Equal = equal;
        Unequal = unequal;
        Value = value;
        Comparator = comparator;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicCompareExchangeWeak, ResultType, ResultId, Pointer, Memory, Equal, Unequal, Value, Comparator];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "equal":
                    Equal = o.ToLiteral<int>();
                    break;
                case "unequal":
                    Unequal = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "comparator":
                    Comparator = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicCompareExchangeWeak(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicIIncrement : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIIncrement()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIIncrement | (1 << 16);
    }

    public OpAtomicIIncrement(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicIIncrement(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicIIncrement inst) => inst.ResultId;
    public OpAtomicIIncrement(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIIncrement, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicIIncrement(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicIDecrement : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIDecrement()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIDecrement | (1 << 16);
    }

    public OpAtomicIDecrement(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicIDecrement(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicIDecrement inst) => inst.ResultId;
    public OpAtomicIDecrement(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIDecrement, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicIDecrement(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicIAdd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIAdd | (1 << 16);
    }

    public OpAtomicIAdd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicIAdd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicIAdd inst) => inst.ResultId;
    public OpAtomicIAdd(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIAdd, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicIAdd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicISub : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicISub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicISub | (1 << 16);
    }

    public OpAtomicISub(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicISub(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicISub inst) => inst.ResultId;
    public OpAtomicISub(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicISub, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicISub(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicSMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicSMin | (1 << 16);
    }

    public OpAtomicSMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicSMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicSMin inst) => inst.ResultId;
    public OpAtomicSMin(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicSMin, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicSMin(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicUMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicUMin | (1 << 16);
    }

    public OpAtomicUMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicUMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicUMin inst) => inst.ResultId;
    public OpAtomicUMin(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicUMin, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicUMin(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicSMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicSMax | (1 << 16);
    }

    public OpAtomicSMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicSMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicSMax inst) => inst.ResultId;
    public OpAtomicSMax(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicSMax, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicSMax(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicUMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicUMax | (1 << 16);
    }

    public OpAtomicUMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicUMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicUMax inst) => inst.ResultId;
    public OpAtomicUMax(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicUMax, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicUMax(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicAnd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicAnd | (1 << 16);
    }

    public OpAtomicAnd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicAnd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicAnd inst) => inst.ResultId;
    public OpAtomicAnd(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicAnd, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicAnd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicOr : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicOr | (1 << 16);
    }

    public OpAtomicOr(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicOr(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicOr inst) => inst.ResultId;
    public OpAtomicOr(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicOr, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicOr(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicXor : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicXor | (1 << 16);
    }

    public OpAtomicXor(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicXor(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicXor inst) => inst.ResultId;
    public OpAtomicXor(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicXor, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicXor(OpDataIndex odi) => new(odi);
}

public ref partial struct OpPhi : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPhi()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPhi | (1 << 16);
    }

    public OpPhi(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpPhi(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPhi inst) => inst.ResultId;
    public OpPhi(int resultType, int resultId, LiteralArray<(int, int)> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPhi, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<(int, int)>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpPhi(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpLoopMerge : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoopMerge()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoopMerge | (1 << 16);
    }

    public OpLoopMerge(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLoopMerge(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int MergeBlock
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ContinueTarget
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LoopControlMask Loopcontrol { get; set; }

    public EnumerantParameters LoopcontrolParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLoopMerge(int mergeBlock, int continueTarget, LoopControlMask loopcontrol, EnumerantParameters loopcontrolParameters)
    {
        MergeBlock = mergeBlock;
        ContinueTarget = continueTarget;
        Loopcontrol = loopcontrol;
        LoopcontrolParameters = loopcontrolParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoopMerge, MergeBlock, ContinueTarget, (int)Loopcontrol, ..LoopcontrolParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "mergeBlock":
                    MergeBlock = o.ToLiteral<int>();
                    break;
                case "continueTarget":
                    ContinueTarget = o.ToLiteral<int>();
                    break;
                case "loopcontrol":
                    Loopcontrol = o.ToEnum<LoopControlMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        LoopcontrolParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLoopMerge(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        LoopcontrolParameters.Dispose();
    }
}

public ref partial struct OpSelectionMerge : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSelectionMerge()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSelectionMerge | (1 << 16);
    }

    public OpSelectionMerge(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSelectionMerge(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int MergeBlock
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SelectionControlMask Selectioncontrol
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSelectionMerge(int mergeBlock, SelectionControlMask selectioncontrol)
    {
        MergeBlock = mergeBlock;
        Selectioncontrol = selectioncontrol;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSelectionMerge, MergeBlock, (int)Selectioncontrol];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "mergeBlock":
                    MergeBlock = o.ToLiteral<int>();
                    break;
                case "selectioncontrol":
                    Selectioncontrol = o.ToEnum<SelectionControlMask>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSelectionMerge(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLabel : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLabel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLabel | (1 << 16);
    }

    public OpLabel(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLabel(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLabel inst) => inst.ResultId;
    public OpLabel(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLabel, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLabel(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBranch : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBranch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBranch | (1 << 16);
    }

    public OpBranch(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBranch(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int TargetLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBranch(int targetLabel)
    {
        TargetLabel = targetLabel;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBranch, TargetLabel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "targetLabel":
                    TargetLabel = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBranch(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBranchConditional : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBranchConditional()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBranchConditional | (1 << 16);
    }

    public OpBranchConditional(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBranchConditional(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TrueLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FalseLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBranchConditional(int condition, int trueLabel, int falseLabel, LiteralArray<int> values)
    {
        Condition = condition;
        TrueLabel = trueLabel;
        FalseLabel = falseLabel;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBranchConditional, Condition, TrueLabel, FalseLabel, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "condition":
                    Condition = o.ToLiteral<int>();
                    break;
                case "trueLabel":
                    TrueLabel = o.ToLiteral<int>();
                    break;
                case "falseLabel":
                    FalseLabel = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpBranchConditional(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSwitch : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSwitch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSwitch | (1 << 16);
    }

    public OpSwitch(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSwitch(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Selector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DefaultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSwitch(int selector, int defaultId, LiteralArray<(int, int)> values)
    {
        Selector = selector;
        DefaultId = defaultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSwitch, Selector, DefaultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "selector":
                    Selector = o.ToLiteral<int>();
                    break;
                case "defaultId":
                    DefaultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<(int, int)>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpSwitch(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpKill : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpKill()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpKill | (1 << 16);
    }

    public OpKill(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpKill(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpKill];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpKill(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReturn : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReturn()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReturn | (1 << 16);
    }

    public OpReturn(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReturn(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReturn];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReturn(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReturnValue : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReturnValue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReturnValue | (1 << 16);
    }

    public OpReturnValue(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReturnValue(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReturnValue(int value)
    {
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReturnValue, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReturnValue(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUnreachable : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnreachable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUnreachable | (1 << 16);
    }

    public OpUnreachable(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUnreachable(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUnreachable];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUnreachable(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLifetimeStart : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLifetimeStart()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLifetimeStart | (1 << 16);
    }

    public OpLifetimeStart(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLifetimeStart(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Size
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLifetimeStart(int pointer, int size)
    {
        Pointer = pointer;
        Size = size;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLifetimeStart, Pointer, ..Size.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "size":
                    Size = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLifetimeStart(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLifetimeStop : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLifetimeStop()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLifetimeStop | (1 << 16);
    }

    public OpLifetimeStop(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLifetimeStop(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Size
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLifetimeStop(int pointer, int size)
    {
        Pointer = pointer;
        Size = size;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLifetimeStop, Pointer, ..Size.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "size":
                    Size = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpLifetimeStop(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupAsyncCopy : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAsyncCopy()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAsyncCopy | (1 << 16);
    }

    public OpGroupAsyncCopy(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupAsyncCopy(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Destination
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Source
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumElements
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupAsyncCopy inst) => inst.ResultId;
    public OpGroupAsyncCopy(int resultType, int resultId, int execution, int destination, int source, int numElements, int stride, int eventId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Destination = destination;
        Source = source;
        NumElements = numElements;
        Stride = stride;
        EventId = eventId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAsyncCopy, ResultType, ResultId, Execution, Destination, Source, NumElements, Stride, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "destination":
                    Destination = o.ToLiteral<int>();
                    break;
                case "source":
                    Source = o.ToLiteral<int>();
                    break;
                case "numElements":
                    NumElements = o.ToLiteral<int>();
                    break;
                case "stride":
                    Stride = o.ToLiteral<int>();
                    break;
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupAsyncCopy(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupWaitEvents : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupWaitEvents()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupWaitEvents | (1 << 16);
    }

    public OpGroupWaitEvents(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupWaitEvents(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventsList
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupWaitEvents(int execution, int numEvents, int eventsList)
    {
        Execution = execution;
        NumEvents = numEvents;
        EventsList = eventsList;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupWaitEvents, Execution, NumEvents, EventsList];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "numEvents":
                    NumEvents = o.ToLiteral<int>();
                    break;
                case "eventsList":
                    EventsList = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupWaitEvents(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupAll : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAll | (1 << 16);
    }

    public OpGroupAll(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupAll(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupAll inst) => inst.ResultId;
    public OpGroupAll(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAll, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupAll(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupAny : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAny | (1 << 16);
    }

    public OpGroupAny(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupAny(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupAny inst) => inst.ResultId;
    public OpGroupAny(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAny, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupAny(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupBroadcast : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBroadcast | (1 << 16);
    }

    public OpGroupBroadcast(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupBroadcast(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LocalId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupBroadcast inst) => inst.ResultId;
    public OpGroupBroadcast(int resultType, int resultId, int execution, int value, int localId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        LocalId = localId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBroadcast, ResultType, ResultId, Execution, Value, LocalId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "localId":
                    LocalId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupBroadcast(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupIAdd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIAdd | (1 << 16);
    }

    public OpGroupIAdd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupIAdd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupIAdd inst) => inst.ResultId;
    public OpGroupIAdd(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIAdd, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupIAdd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupFAdd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFAdd | (1 << 16);
    }

    public OpGroupFAdd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupFAdd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFAdd inst) => inst.ResultId;
    public OpGroupFAdd(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFAdd, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupFAdd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupFMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMin | (1 << 16);
    }

    public OpGroupFMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupFMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMin inst) => inst.ResultId;
    public OpGroupFMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMin(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupUMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMin | (1 << 16);
    }

    public OpGroupUMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupUMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupUMin inst) => inst.ResultId;
    public OpGroupUMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupUMin(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupSMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMin | (1 << 16);
    }

    public OpGroupSMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupSMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupSMin inst) => inst.ResultId;
    public OpGroupSMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupSMin(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupFMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMax | (1 << 16);
    }

    public OpGroupFMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupFMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMax inst) => inst.ResultId;
    public OpGroupFMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMax(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupUMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMax | (1 << 16);
    }

    public OpGroupUMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupUMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupUMax inst) => inst.ResultId;
    public OpGroupUMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupUMax(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupSMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMax | (1 << 16);
    }

    public OpGroupSMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupSMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupSMax inst) => inst.ResultId;
    public OpGroupSMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupSMax(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReadPipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadPipe | (1 << 16);
    }

    public OpReadPipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReadPipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReadPipe inst) => inst.ResultId;
    public OpReadPipe(int resultType, int resultId, int pipe, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadPipe, ResultType, ResultId, Pipe, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReadPipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpWritePipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePipe | (1 << 16);
    }

    public OpWritePipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpWritePipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpWritePipe inst) => inst.ResultId;
    public OpWritePipe(int resultType, int resultId, int pipe, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePipe, ResultType, ResultId, Pipe, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpWritePipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReservedReadPipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReservedReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReservedReadPipe | (1 << 16);
    }

    public OpReservedReadPipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReservedReadPipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReservedReadPipe inst) => inst.ResultId;
    public OpReservedReadPipe(int resultType, int resultId, int pipe, int reserveId, int index, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        ReserveId = reserveId;
        Index = index;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReservedReadPipe, ResultType, ResultId, Pipe, ReserveId, Index, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReservedReadPipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReservedWritePipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReservedWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReservedWritePipe | (1 << 16);
    }

    public OpReservedWritePipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReservedWritePipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReservedWritePipe inst) => inst.ResultId;
    public OpReservedWritePipe(int resultType, int resultId, int pipe, int reserveId, int index, int pointer, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        ReserveId = reserveId;
        Index = index;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReservedWritePipe, ResultType, ResultId, Pipe, ReserveId, Index, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReservedWritePipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReserveReadPipePackets : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReserveReadPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReserveReadPipePackets | (1 << 16);
    }

    public OpReserveReadPipePackets(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReserveReadPipePackets(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReserveReadPipePackets inst) => inst.ResultId;
    public OpReserveReadPipePackets(int resultType, int resultId, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReserveReadPipePackets, ResultType, ResultId, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "numPackets":
                    NumPackets = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReserveReadPipePackets(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReserveWritePipePackets : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReserveWritePipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReserveWritePipePackets | (1 << 16);
    }

    public OpReserveWritePipePackets(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReserveWritePipePackets(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReserveWritePipePackets inst) => inst.ResultId;
    public OpReserveWritePipePackets(int resultType, int resultId, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReserveWritePipePackets, ResultType, ResultId, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "numPackets":
                    NumPackets = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReserveWritePipePackets(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCommitReadPipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCommitReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCommitReadPipe | (1 << 16);
    }

    public OpCommitReadPipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCommitReadPipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCommitReadPipe(int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCommitReadPipe, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCommitReadPipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCommitWritePipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCommitWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCommitWritePipe | (1 << 16);
    }

    public OpCommitWritePipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCommitWritePipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCommitWritePipe(int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCommitWritePipe, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCommitWritePipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIsValidReserveId : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsValidReserveId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsValidReserveId | (1 << 16);
    }

    public OpIsValidReserveId(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIsValidReserveId(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsValidReserveId inst) => inst.ResultId;
    public OpIsValidReserveId(int resultType, int resultId, int reserveId)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReserveId = reserveId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsValidReserveId, ResultType, ResultId, ReserveId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIsValidReserveId(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGetNumPipePackets : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetNumPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetNumPipePackets | (1 << 16);
    }

    public OpGetNumPipePackets(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetNumPipePackets(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetNumPipePackets inst) => inst.ResultId;
    public OpGetNumPipePackets(int resultType, int resultId, int pipe, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetNumPipePackets, ResultType, ResultId, Pipe, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetNumPipePackets(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGetMaxPipePackets : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetMaxPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetMaxPipePackets | (1 << 16);
    }

    public OpGetMaxPipePackets(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetMaxPipePackets(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetMaxPipePackets inst) => inst.ResultId;
    public OpGetMaxPipePackets(int resultType, int resultId, int pipe, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetMaxPipePackets, ResultType, ResultId, Pipe, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetMaxPipePackets(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupReserveReadPipePackets : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupReserveReadPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupReserveReadPipePackets | (1 << 16);
    }

    public OpGroupReserveReadPipePackets(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupReserveReadPipePackets(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupReserveReadPipePackets inst) => inst.ResultId;
    public OpGroupReserveReadPipePackets(int resultType, int resultId, int execution, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupReserveReadPipePackets, ResultType, ResultId, Execution, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "numPackets":
                    NumPackets = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupReserveReadPipePackets(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupReserveWritePipePackets : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupReserveWritePipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupReserveWritePipePackets | (1 << 16);
    }

    public OpGroupReserveWritePipePackets(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupReserveWritePipePackets(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupReserveWritePipePackets inst) => inst.ResultId;
    public OpGroupReserveWritePipePackets(int resultType, int resultId, int execution, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupReserveWritePipePackets, ResultType, ResultId, Execution, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "numPackets":
                    NumPackets = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupReserveWritePipePackets(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupCommitReadPipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupCommitReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupCommitReadPipe | (1 << 16);
    }

    public OpGroupCommitReadPipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupCommitReadPipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupCommitReadPipe(int execution, int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Execution = execution;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupCommitReadPipe, Execution, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupCommitReadPipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupCommitWritePipe : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupCommitWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupCommitWritePipe | (1 << 16);
    }

    public OpGroupCommitWritePipe(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupCommitWritePipe(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupCommitWritePipe(int execution, int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        Execution = execution;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupCommitWritePipe, Execution, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupCommitWritePipe(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEnqueueMarker : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueMarker()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueMarker | (1 << 16);
    }

    public OpEnqueueMarker(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEnqueueMarker(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Queue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int WaitEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RetEvent
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpEnqueueMarker inst) => inst.ResultId;
    public OpEnqueueMarker(int resultType, int resultId, int queue, int numEvents, int waitEvents, int retEvent)
    {
        ResultType = resultType;
        ResultId = resultId;
        Queue = queue;
        NumEvents = numEvents;
        WaitEvents = waitEvents;
        RetEvent = retEvent;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueMarker, ResultType, ResultId, Queue, NumEvents, WaitEvents, RetEvent];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "queue":
                    Queue = o.ToLiteral<int>();
                    break;
                case "numEvents":
                    NumEvents = o.ToLiteral<int>();
                    break;
                case "waitEvents":
                    WaitEvents = o.ToLiteral<int>();
                    break;
                case "retEvent":
                    RetEvent = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpEnqueueMarker(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEnqueueKernel : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueKernel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueKernel | (1 << 16);
    }

    public OpEnqueueKernel(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEnqueueKernel(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Queue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int WaitEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RetEvent
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpEnqueueKernel inst) => inst.ResultId;
    public OpEnqueueKernel(int resultType, int resultId, int queue, int flags, int nDRange, int numEvents, int waitEvents, int retEvent, int invoke, int param, int paramSize, int paramAlign, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Queue = queue;
        Flags = flags;
        NDRange = nDRange;
        NumEvents = numEvents;
        WaitEvents = waitEvents;
        RetEvent = retEvent;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueKernel, ResultType, ResultId, Queue, Flags, NDRange, NumEvents, WaitEvents, RetEvent, Invoke, Param, ParamSize, ParamAlign, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "queue":
                    Queue = o.ToLiteral<int>();
                    break;
                case "flags":
                    Flags = o.ToLiteral<int>();
                    break;
                case "nDRange":
                    NDRange = o.ToLiteral<int>();
                    break;
                case "numEvents":
                    NumEvents = o.ToLiteral<int>();
                    break;
                case "waitEvents":
                    WaitEvents = o.ToLiteral<int>();
                    break;
                case "retEvent":
                    RetEvent = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpEnqueueKernel(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpGetKernelNDrangeSubGroupCount : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelNDrangeSubGroupCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelNDrangeSubGroupCount | (1 << 16);
    }

    public OpGetKernelNDrangeSubGroupCount(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetKernelNDrangeSubGroupCount(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelNDrangeSubGroupCount inst) => inst.ResultId;
    public OpGetKernelNDrangeSubGroupCount(int resultType, int resultId, int nDRange, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        NDRange = nDRange;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelNDrangeSubGroupCount, ResultType, ResultId, NDRange, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "nDRange":
                    NDRange = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelNDrangeSubGroupCount(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGetKernelNDrangeMaxSubGroupSize : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelNDrangeMaxSubGroupSize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelNDrangeMaxSubGroupSize | (1 << 16);
    }

    public OpGetKernelNDrangeMaxSubGroupSize(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetKernelNDrangeMaxSubGroupSize(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelNDrangeMaxSubGroupSize inst) => inst.ResultId;
    public OpGetKernelNDrangeMaxSubGroupSize(int resultType, int resultId, int nDRange, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        NDRange = nDRange;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelNDrangeMaxSubGroupSize, ResultType, ResultId, NDRange, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "nDRange":
                    NDRange = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelNDrangeMaxSubGroupSize(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGetKernelWorkGroupSize : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelWorkGroupSize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelWorkGroupSize | (1 << 16);
    }

    public OpGetKernelWorkGroupSize(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetKernelWorkGroupSize(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelWorkGroupSize inst) => inst.ResultId;
    public OpGetKernelWorkGroupSize(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelWorkGroupSize, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelWorkGroupSize(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGetKernelPreferredWorkGroupSizeMultiple : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelPreferredWorkGroupSizeMultiple | (1 << 16);
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelPreferredWorkGroupSizeMultiple inst) => inst.ResultId;
    public OpGetKernelPreferredWorkGroupSizeMultiple(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelPreferredWorkGroupSizeMultiple, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelPreferredWorkGroupSizeMultiple(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRetainEvent : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRetainEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRetainEvent | (1 << 16);
    }

    public OpRetainEvent(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRetainEvent(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRetainEvent(int eventId)
    {
        EventId = eventId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRetainEvent, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRetainEvent(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReleaseEvent : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReleaseEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReleaseEvent | (1 << 16);
    }

    public OpReleaseEvent(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReleaseEvent(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReleaseEvent(int eventId)
    {
        EventId = eventId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReleaseEvent, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReleaseEvent(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCreateUserEvent : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateUserEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateUserEvent | (1 << 16);
    }

    public OpCreateUserEvent(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCreateUserEvent(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCreateUserEvent inst) => inst.ResultId;
    public OpCreateUserEvent(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateUserEvent, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCreateUserEvent(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIsValidEvent : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsValidEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsValidEvent | (1 << 16);
    }

    public OpIsValidEvent(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIsValidEvent(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsValidEvent inst) => inst.ResultId;
    public OpIsValidEvent(int resultType, int resultId, int eventId)
    {
        ResultType = resultType;
        ResultId = resultId;
        EventId = eventId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsValidEvent, ResultType, ResultId, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIsValidEvent(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSetUserEventStatus : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSetUserEventStatus()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSetUserEventStatus | (1 << 16);
    }

    public OpSetUserEventStatus(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSetUserEventStatus(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Status
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSetUserEventStatus(int eventId, int status)
    {
        EventId = eventId;
        Status = status;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSetUserEventStatus, EventId, Status];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
                case "status":
                    Status = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSetUserEventStatus(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCaptureEventProfilingInfo : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCaptureEventProfilingInfo()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCaptureEventProfilingInfo | (1 << 16);
    }

    public OpCaptureEventProfilingInfo(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCaptureEventProfilingInfo(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ProfilingInfo
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCaptureEventProfilingInfo(int eventId, int profilingInfo, int value)
    {
        EventId = eventId;
        ProfilingInfo = profilingInfo;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCaptureEventProfilingInfo, EventId, ProfilingInfo, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
                case "profilingInfo":
                    ProfilingInfo = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCaptureEventProfilingInfo(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGetDefaultQueue : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetDefaultQueue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetDefaultQueue | (1 << 16);
    }

    public OpGetDefaultQueue(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetDefaultQueue(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetDefaultQueue inst) => inst.ResultId;
    public OpGetDefaultQueue(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetDefaultQueue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetDefaultQueue(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBuildNDRange : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBuildNDRange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBuildNDRange | (1 << 16);
    }

    public OpBuildNDRange(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBuildNDRange(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GlobalWorkSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LocalWorkSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GlobalWorkOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBuildNDRange inst) => inst.ResultId;
    public OpBuildNDRange(int resultType, int resultId, int globalWorkSize, int localWorkSize, int globalWorkOffset)
    {
        ResultType = resultType;
        ResultId = resultId;
        GlobalWorkSize = globalWorkSize;
        LocalWorkSize = localWorkSize;
        GlobalWorkOffset = globalWorkOffset;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBuildNDRange, ResultType, ResultId, GlobalWorkSize, LocalWorkSize, GlobalWorkOffset];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "globalWorkSize":
                    GlobalWorkSize = o.ToLiteral<int>();
                    break;
                case "localWorkSize":
                    LocalWorkSize = o.ToLiteral<int>();
                    break;
                case "globalWorkOffset":
                    GlobalWorkOffset = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBuildNDRange(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageSparseSampleImplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleImplicitLod | (1 << 16);
    }

    public OpImageSparseSampleImplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseSampleImplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleImplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleImplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseSampleExplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleExplicitLod | (1 << 16);
    }

    public OpImageSparseSampleExplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseSampleExplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleExplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleExplicitLod, ResultType, ResultId, SampledImage, Coordinate, (int)Imageoperands, ..ImageoperandsParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleExplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseSampleDrefImplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleDrefImplicitLod | (1 << 16);
    }

    public OpImageSparseSampleDrefImplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseSampleDrefImplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleDrefImplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleDrefImplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseSampleDrefExplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleDrefExplicitLod | (1 << 16);
    }

    public OpImageSparseSampleDrefExplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseSampleDrefExplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleDrefExplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, (int)Imageoperands, ..ImageoperandsParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleDrefExplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseSampleProjImplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjImplicitLod | (1 << 16);
    }

    public OpImageSparseSampleProjImplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseSampleProjImplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleProjImplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleProjImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleProjImplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseSampleProjExplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjExplicitLod | (1 << 16);
    }

    public OpImageSparseSampleProjExplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseSampleProjExplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleProjExplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleProjExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ImageOperandsMask imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjExplicitLod, ResultType, ResultId, SampledImage, Coordinate, (int)Imageoperands, ..ImageoperandsParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleProjExplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseSampleProjDrefImplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjDrefImplicitLod | (1 << 16);
    }

    public OpImageSparseSampleProjDrefImplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseSampleProjDrefImplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleProjDrefImplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleProjDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleProjDrefImplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseSampleProjDrefExplicitLod : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjDrefExplicitLod | (1 << 16);
    }

    public OpImageSparseSampleProjDrefExplicitLod(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseSampleProjDrefExplicitLod(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleProjDrefExplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleProjDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, (int)Imageoperands, ..ImageoperandsParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    if (data.Memory.Span.Length > o.Offset + 1)
                        ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleProjDrefExplicitLod(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseFetch : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseFetch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseFetch | (1 << 16);
    }

    public OpImageSparseFetch(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseFetch(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseFetch inst) => inst.ResultId;
    public OpImageSparseFetch(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseFetch, ResultType, ResultId, Image, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseFetch(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseGather : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseGather | (1 << 16);
    }

    public OpImageSparseGather(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseGather(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseGather inst) => inst.ResultId;
    public OpImageSparseGather(int resultType, int resultId, int sampledImage, int coordinate, int component, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Component = component;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseGather, ResultType, ResultId, SampledImage, Coordinate, Component, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "component":
                    Component = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseGather(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseDrefGather : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseDrefGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseDrefGather | (1 << 16);
    }

    public OpImageSparseDrefGather(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseDrefGather(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseDrefGather inst) => inst.ResultId;
    public OpImageSparseDrefGather(int resultType, int resultId, int sampledImage, int coordinate, int dref, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseDrefGather, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseDrefGather(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpImageSparseTexelsResident : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseTexelsResident()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseTexelsResident | (1 << 16);
    }

    public OpImageSparseTexelsResident(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseTexelsResident(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResidentCode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseTexelsResident inst) => inst.ResultId;
    public OpImageSparseTexelsResident(int resultType, int resultId, int residentCode)
    {
        ResultType = resultType;
        ResultId = resultId;
        ResidentCode = residentCode;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseTexelsResident, ResultType, ResultId, ResidentCode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "residentCode":
                    ResidentCode = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseTexelsResident(OpDataIndex odi) => new(odi);
}

public ref partial struct OpNoLine : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNoLine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNoLine | (1 << 16);
    }

    public OpNoLine(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpNoLine(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNoLine];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpNoLine(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicFlagTestAndSet : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFlagTestAndSet()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFlagTestAndSet | (1 << 16);
    }

    public OpAtomicFlagTestAndSet(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicFlagTestAndSet(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicFlagTestAndSet inst) => inst.ResultId;
    public OpAtomicFlagTestAndSet(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFlagTestAndSet, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFlagTestAndSet(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicFlagClear : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFlagClear()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFlagClear | (1 << 16);
    }

    public OpAtomicFlagClear(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicFlagClear(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicFlagClear(int pointer, int memory, int semantics)
    {
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFlagClear, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFlagClear(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageSparseRead : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseRead()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseRead | (1 << 16);
    }

    public OpImageSparseRead(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSparseRead(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseRead inst) => inst.ResultId;
    public OpImageSparseRead(int resultType, int resultId, int image, int coordinate, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseRead, ResultType, ResultId, Image, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseRead(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpSizeOf : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSizeOf()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSizeOf | (1 << 16);
    }

    public OpSizeOf(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSizeOf(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSizeOf inst) => inst.ResultId;
    public OpSizeOf(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSizeOf, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSizeOf(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypePipeStorage : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePipeStorage | (1 << 16);
    }

    public OpTypePipeStorage(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypePipeStorage(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypePipeStorage inst) => inst.ResultId;
    public OpTypePipeStorage(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePipeStorage, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypePipeStorage(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantPipeStorage : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantPipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantPipeStorage | (1 << 16);
    }

    public OpConstantPipeStorage(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantPipeStorage(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Capacity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantPipeStorage inst) => inst.ResultId;
    public OpConstantPipeStorage(int resultType, int resultId, int packetSize, int packetAlignment, int capacity)
    {
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        Capacity = capacity;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantPipeStorage, ResultType, ResultId, ..PacketSize.AsDisposableLiteralValue().Words, ..PacketAlignment.AsDisposableLiteralValue().Words, ..Capacity.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                case "capacity":
                    Capacity = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantPipeStorage(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCreatePipeFromPipeStorage : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreatePipeFromPipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreatePipeFromPipeStorage | (1 << 16);
    }

    public OpCreatePipeFromPipeStorage(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCreatePipeFromPipeStorage(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PipeStorage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCreatePipeFromPipeStorage inst) => inst.ResultId;
    public OpCreatePipeFromPipeStorage(int resultType, int resultId, int pipeStorage)
    {
        ResultType = resultType;
        ResultId = resultId;
        PipeStorage = pipeStorage;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreatePipeFromPipeStorage, ResultType, ResultId, PipeStorage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipeStorage":
                    PipeStorage = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCreatePipeFromPipeStorage(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGetKernelLocalSizeForSubgroupCount : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelLocalSizeForSubgroupCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelLocalSizeForSubgroupCount | (1 << 16);
    }

    public OpGetKernelLocalSizeForSubgroupCount(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetKernelLocalSizeForSubgroupCount(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SubgroupCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelLocalSizeForSubgroupCount inst) => inst.ResultId;
    public OpGetKernelLocalSizeForSubgroupCount(int resultType, int resultId, int subgroupCount, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        SubgroupCount = subgroupCount;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelLocalSizeForSubgroupCount, ResultType, ResultId, SubgroupCount, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "subgroupCount":
                    SubgroupCount = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelLocalSizeForSubgroupCount(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGetKernelMaxNumSubgroups : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelMaxNumSubgroups()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelMaxNumSubgroups | (1 << 16);
    }

    public OpGetKernelMaxNumSubgroups(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGetKernelMaxNumSubgroups(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelMaxNumSubgroups inst) => inst.ResultId;
    public OpGetKernelMaxNumSubgroups(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelMaxNumSubgroups, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelMaxNumSubgroups(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeNamedBarrier : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeNamedBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeNamedBarrier | (1 << 16);
    }

    public OpTypeNamedBarrier(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeNamedBarrier(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeNamedBarrier inst) => inst.ResultId;
    public OpTypeNamedBarrier(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeNamedBarrier, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeNamedBarrier(OpDataIndex odi) => new(odi);
}

public ref partial struct OpNamedBarrierInitialize : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNamedBarrierInitialize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNamedBarrierInitialize | (1 << 16);
    }

    public OpNamedBarrierInitialize(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpNamedBarrierInitialize(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SubgroupCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpNamedBarrierInitialize inst) => inst.ResultId;
    public OpNamedBarrierInitialize(int resultType, int resultId, int subgroupCount)
    {
        ResultType = resultType;
        ResultId = resultId;
        SubgroupCount = subgroupCount;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNamedBarrierInitialize, ResultType, ResultId, SubgroupCount];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "subgroupCount":
                    SubgroupCount = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpNamedBarrierInitialize(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMemoryNamedBarrier : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryNamedBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryNamedBarrier | (1 << 16);
    }

    public OpMemoryNamedBarrier(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMemoryNamedBarrier(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int NamedBarrier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryNamedBarrier(int namedBarrier, int memory, int semantics)
    {
        NamedBarrier = namedBarrier;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryNamedBarrier, NamedBarrier, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "namedBarrier":
                    NamedBarrier = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMemoryNamedBarrier(OpDataIndex odi) => new(odi);
}

public ref partial struct OpModuleProcessed : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpModuleProcessed()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpModuleProcessed | (1 << 16);
    }

    public OpModuleProcessed(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpModuleProcessed(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public string Process
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpModuleProcessed(string process)
    {
        Process = process;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpModuleProcessed, ..Process.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "process":
                    Process = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpModuleProcessed(OpDataIndex odi) => new(odi);
}

public ref partial struct OpExecutionModeId : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecutionModeId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecutionModeId | (1 << 16);
    }

    public OpExecutionModeId(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExecutionModeId(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ExecutionMode Mode { get; set; }

    public EnumerantParameters ModeParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecutionModeId(int entryPoint, ExecutionMode mode, EnumerantParameters modeParameters)
    {
        EntryPoint = entryPoint;
        Mode = mode;
        ModeParameters = modeParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecutionModeId, EntryPoint, (int)Mode, ..ModeParameters];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "entryPoint":
                    EntryPoint = o.ToLiteral<int>();
                    break;
                case "mode":
                    Mode = o.ToEnum<ExecutionMode>();
                    ModeParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpExecutionModeId(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ModeParameters.Dispose();
    }
}

public ref partial struct OpDecorateId : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorateId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorateId | (1 << 16);
    }

    public OpDecorateId(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDecorateId(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorateId(int target, Decoration decoration, int value)
    {
        Target = target;
        Decoration = decoration;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorateId, Target, (int)Decoration, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDecorateId(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformElect : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformElect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformElect | (1 << 16);
    }

    public OpGroupNonUniformElect(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformElect(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformElect inst) => inst.ResultId;
    public OpGroupNonUniformElect(int resultType, int resultId, int execution)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformElect, ResultType, ResultId, Execution];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformElect(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformAll : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAll | (1 << 16);
    }

    public OpGroupNonUniformAll(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformAll(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformAll inst) => inst.ResultId;
    public OpGroupNonUniformAll(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAll, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformAll(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformAny : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAny | (1 << 16);
    }

    public OpGroupNonUniformAny(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformAny(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformAny inst) => inst.ResultId;
    public OpGroupNonUniformAny(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAny, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformAny(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformAllEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAllEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAllEqual | (1 << 16);
    }

    public OpGroupNonUniformAllEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformAllEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformAllEqual inst) => inst.ResultId;
    public OpGroupNonUniformAllEqual(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAllEqual, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformAllEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBroadcast : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBroadcast | (1 << 16);
    }

    public OpGroupNonUniformBroadcast(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBroadcast(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Id
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBroadcast inst) => inst.ResultId;
    public OpGroupNonUniformBroadcast(int resultType, int resultId, int execution, int value, int id)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Id = id;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBroadcast, ResultType, ResultId, Execution, Value, Id];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "id":
                    Id = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBroadcast(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBroadcastFirst : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBroadcastFirst()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBroadcastFirst | (1 << 16);
    }

    public OpGroupNonUniformBroadcastFirst(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBroadcastFirst(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBroadcastFirst inst) => inst.ResultId;
    public OpGroupNonUniformBroadcastFirst(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBroadcastFirst, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBroadcastFirst(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBallot : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallot | (1 << 16);
    }

    public OpGroupNonUniformBallot(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBallot(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallot inst) => inst.ResultId;
    public OpGroupNonUniformBallot(int resultType, int resultId, int execution, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallot, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallot(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformInverseBallot : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformInverseBallot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformInverseBallot | (1 << 16);
    }

    public OpGroupNonUniformInverseBallot(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformInverseBallot(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformInverseBallot inst) => inst.ResultId;
    public OpGroupNonUniformInverseBallot(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformInverseBallot, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformInverseBallot(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBallotBitExtract : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotBitExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotBitExtract | (1 << 16);
    }

    public OpGroupNonUniformBallotBitExtract(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBallotBitExtract(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallotBitExtract inst) => inst.ResultId;
    public OpGroupNonUniformBallotBitExtract(int resultType, int resultId, int execution, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotBitExtract, ResultType, ResultId, Execution, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallotBitExtract(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBallotBitCount : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotBitCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotBitCount | (1 << 16);
    }

    public OpGroupNonUniformBallotBitCount(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBallotBitCount(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallotBitCount inst) => inst.ResultId;
    public OpGroupNonUniformBallotBitCount(int resultType, int resultId, int execution, GroupOperation operation, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotBitCount, ResultType, ResultId, Execution, (int)Operation, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallotBitCount(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBallotFindLSB : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotFindLSB()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotFindLSB | (1 << 16);
    }

    public OpGroupNonUniformBallotFindLSB(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBallotFindLSB(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallotFindLSB inst) => inst.ResultId;
    public OpGroupNonUniformBallotFindLSB(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotFindLSB, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallotFindLSB(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBallotFindMSB : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotFindMSB()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotFindMSB | (1 << 16);
    }

    public OpGroupNonUniformBallotFindMSB(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBallotFindMSB(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallotFindMSB inst) => inst.ResultId;
    public OpGroupNonUniformBallotFindMSB(int resultType, int resultId, int execution, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotFindMSB, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallotFindMSB(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformShuffle : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffle()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffle | (1 << 16);
    }

    public OpGroupNonUniformShuffle(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformShuffle(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Id
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformShuffle inst) => inst.ResultId;
    public OpGroupNonUniformShuffle(int resultType, int resultId, int execution, int value, int id)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Id = id;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffle, ResultType, ResultId, Execution, Value, Id];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "id":
                    Id = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformShuffle(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformShuffleXor : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleXor | (1 << 16);
    }

    public OpGroupNonUniformShuffleXor(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformShuffleXor(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformShuffleXor inst) => inst.ResultId;
    public OpGroupNonUniformShuffleXor(int resultType, int resultId, int execution, int value, int mask)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Mask = mask;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleXor, ResultType, ResultId, Execution, Value, Mask];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "mask":
                    Mask = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformShuffleXor(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformShuffleUp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleUp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleUp | (1 << 16);
    }

    public OpGroupNonUniformShuffleUp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformShuffleUp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformShuffleUp inst) => inst.ResultId;
    public OpGroupNonUniformShuffleUp(int resultType, int resultId, int execution, int value, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleUp, ResultType, ResultId, Execution, Value, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformShuffleUp(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformShuffleDown : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleDown()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleDown | (1 << 16);
    }

    public OpGroupNonUniformShuffleDown(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformShuffleDown(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformShuffleDown inst) => inst.ResultId;
    public OpGroupNonUniformShuffleDown(int resultType, int resultId, int execution, int value, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleDown, ResultType, ResultId, Execution, Value, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformShuffleDown(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformIAdd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformIAdd | (1 << 16);
    }

    public OpGroupNonUniformIAdd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformIAdd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformIAdd inst) => inst.ResultId;
    public OpGroupNonUniformIAdd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformIAdd, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformIAdd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformFAdd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFAdd | (1 << 16);
    }

    public OpGroupNonUniformFAdd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformFAdd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformFAdd inst) => inst.ResultId;
    public OpGroupNonUniformFAdd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFAdd, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformFAdd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformIMul : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformIMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformIMul | (1 << 16);
    }

    public OpGroupNonUniformIMul(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformIMul(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformIMul inst) => inst.ResultId;
    public OpGroupNonUniformIMul(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformIMul, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformIMul(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformFMul : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMul | (1 << 16);
    }

    public OpGroupNonUniformFMul(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformFMul(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformFMul inst) => inst.ResultId;
    public OpGroupNonUniformFMul(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMul, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformFMul(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformSMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformSMin | (1 << 16);
    }

    public OpGroupNonUniformSMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformSMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformSMin inst) => inst.ResultId;
    public OpGroupNonUniformSMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformSMin, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformSMin(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformUMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformUMin | (1 << 16);
    }

    public OpGroupNonUniformUMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformUMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformUMin inst) => inst.ResultId;
    public OpGroupNonUniformUMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformUMin, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformUMin(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformFMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMin | (1 << 16);
    }

    public OpGroupNonUniformFMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformFMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformFMin inst) => inst.ResultId;
    public OpGroupNonUniformFMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMin, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformFMin(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformSMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformSMax | (1 << 16);
    }

    public OpGroupNonUniformSMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformSMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformSMax inst) => inst.ResultId;
    public OpGroupNonUniformSMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformSMax, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformSMax(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformUMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformUMax | (1 << 16);
    }

    public OpGroupNonUniformUMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformUMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformUMax inst) => inst.ResultId;
    public OpGroupNonUniformUMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformUMax, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformUMax(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformFMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMax | (1 << 16);
    }

    public OpGroupNonUniformFMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformFMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformFMax inst) => inst.ResultId;
    public OpGroupNonUniformFMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMax, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformFMax(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBitwiseAnd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseAnd | (1 << 16);
    }

    public OpGroupNonUniformBitwiseAnd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBitwiseAnd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBitwiseAnd inst) => inst.ResultId;
    public OpGroupNonUniformBitwiseAnd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseAnd, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseAnd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBitwiseOr : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseOr | (1 << 16);
    }

    public OpGroupNonUniformBitwiseOr(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBitwiseOr(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBitwiseOr inst) => inst.ResultId;
    public OpGroupNonUniformBitwiseOr(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseOr, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseOr(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformBitwiseXor : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseXor | (1 << 16);
    }

    public OpGroupNonUniformBitwiseXor(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformBitwiseXor(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBitwiseXor inst) => inst.ResultId;
    public OpGroupNonUniformBitwiseXor(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseXor, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseXor(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformLogicalAnd : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalAnd | (1 << 16);
    }

    public OpGroupNonUniformLogicalAnd(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformLogicalAnd(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformLogicalAnd inst) => inst.ResultId;
    public OpGroupNonUniformLogicalAnd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalAnd, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformLogicalAnd(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformLogicalOr : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalOr | (1 << 16);
    }

    public OpGroupNonUniformLogicalOr(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformLogicalOr(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformLogicalOr inst) => inst.ResultId;
    public OpGroupNonUniformLogicalOr(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalOr, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformLogicalOr(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformLogicalXor : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalXor | (1 << 16);
    }

    public OpGroupNonUniformLogicalXor(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformLogicalXor(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformLogicalXor inst) => inst.ResultId;
    public OpGroupNonUniformLogicalXor(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalXor, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformLogicalXor(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformQuadBroadcast : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadBroadcast | (1 << 16);
    }

    public OpGroupNonUniformQuadBroadcast(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformQuadBroadcast(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformQuadBroadcast inst) => inst.ResultId;
    public OpGroupNonUniformQuadBroadcast(int resultType, int resultId, int execution, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadBroadcast, ResultType, ResultId, Execution, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformQuadBroadcast(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformQuadSwap : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadSwap()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadSwap | (1 << 16);
    }

    public OpGroupNonUniformQuadSwap(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformQuadSwap(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformQuadSwap inst) => inst.ResultId;
    public OpGroupNonUniformQuadSwap(int resultType, int resultId, int execution, int value, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Direction = direction;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadSwap, ResultType, ResultId, Execution, Value, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformQuadSwap(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCopyLogical : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCopyLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCopyLogical | (1 << 16);
    }

    public OpCopyLogical(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCopyLogical(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCopyLogical inst) => inst.ResultId;
    public OpCopyLogical(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCopyLogical, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCopyLogical(OpDataIndex odi) => new(odi);
}

public ref partial struct OpPtrEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrEqual | (1 << 16);
    }

    public OpPtrEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpPtrEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrEqual inst) => inst.ResultId;
    public OpPtrEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpPtrEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpPtrNotEqual : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrNotEqual | (1 << 16);
    }

    public OpPtrNotEqual(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpPtrNotEqual(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrNotEqual inst) => inst.ResultId;
    public OpPtrNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpPtrNotEqual(OpDataIndex odi) => new(odi);
}

public ref partial struct OpPtrDiff : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrDiff()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrDiff | (1 << 16);
    }

    public OpPtrDiff(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpPtrDiff(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrDiff inst) => inst.ResultId;
    public OpPtrDiff(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrDiff, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpPtrDiff(OpDataIndex odi) => new(odi);
}

public ref partial struct OpColorAttachmentReadEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpColorAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpColorAttachmentReadEXT | (1 << 16);
    }

    public OpColorAttachmentReadEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpColorAttachmentReadEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Attachment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpColorAttachmentReadEXT inst) => inst.ResultId;
    public OpColorAttachmentReadEXT(int resultType, int resultId, int attachment, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Attachment = attachment;
        Sample = sample;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpColorAttachmentReadEXT, ResultType, ResultId, Attachment, ..(Sample is null ? (Span<int>)[] : [Sample.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "attachment":
                    Attachment = o.ToLiteral<int>();
                    break;
                case "sample":
                    if (o.Words.Length > 0)
                    {
                        Sample = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpColorAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDepthAttachmentReadEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDepthAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDepthAttachmentReadEXT | (1 << 16);
    }

    public OpDepthAttachmentReadEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDepthAttachmentReadEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDepthAttachmentReadEXT inst) => inst.ResultId;
    public OpDepthAttachmentReadEXT(int resultType, int resultId, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Sample = sample;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDepthAttachmentReadEXT, ResultType, ResultId, ..(Sample is null ? (Span<int>)[] : [Sample.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sample":
                    if (o.Words.Length > 0)
                    {
                        Sample = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDepthAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpStencilAttachmentReadEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStencilAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStencilAttachmentReadEXT | (1 << 16);
    }

    public OpStencilAttachmentReadEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpStencilAttachmentReadEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpStencilAttachmentReadEXT inst) => inst.ResultId;
    public OpStencilAttachmentReadEXT(int resultType, int resultId, int? sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Sample = sample;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStencilAttachmentReadEXT, ResultType, ResultId, ..(Sample is null ? (Span<int>)[] : [Sample.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sample":
                    if (o.Words.Length > 0)
                    {
                        Sample = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpStencilAttachmentReadEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTerminateInvocation : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateInvocation()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateInvocation | (1 << 16);
    }

    public OpTerminateInvocation(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTerminateInvocation(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTerminateInvocation];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTerminateInvocation(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeUntypedPointerKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeUntypedPointerKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeUntypedPointerKHR | (1 << 16);
    }

    public OpTypeUntypedPointerKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeUntypedPointerKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeUntypedPointerKHR inst) => inst.ResultId;
    public OpTypeUntypedPointerKHR(int resultId, StorageClass storageclass)
    {
        ResultId = resultId;
        Storageclass = storageclass;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeUntypedPointerKHR, ResultId, (int)Storageclass];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeUntypedPointerKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUntypedVariableKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedVariableKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedVariableKHR | (1 << 16);
    }

    public OpUntypedVariableKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUntypedVariableKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? DataType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Initializer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedVariableKHR inst) => inst.ResultId;
    public OpUntypedVariableKHR(int resultType, int resultId, StorageClass storageclass, int? dataType, int? initializer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        DataType = dataType;
        Initializer = initializer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedVariableKHR, ResultType, ResultId, (int)Storageclass, ..(DataType is null ? (Span<int>)[] : [DataType.Value]), ..(Initializer is null ? (Span<int>)[] : [Initializer.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                case "dataType":
                    if (o.Words.Length > 0)
                    {
                        DataType = o.ToLiteral<int>();
                    }

                    break;
                case "initializer":
                    if (o.Words.Length > 0)
                    {
                        Initializer = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUntypedVariableKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUntypedAccessChainKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedAccessChainKHR | (1 << 16);
    }

    public OpUntypedAccessChainKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUntypedAccessChainKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedAccessChainKHR inst) => inst.ResultId;
    public OpUntypedAccessChainKHR(int resultType, int resultId, int baseType, int baseId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedAccessChainKHR, ResultType, ResultId, BaseType, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseType":
                    BaseType = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpUntypedAccessChainKHR(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpUntypedInBoundsAccessChainKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedInBoundsAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedInBoundsAccessChainKHR | (1 << 16);
    }

    public OpUntypedInBoundsAccessChainKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUntypedInBoundsAccessChainKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedInBoundsAccessChainKHR inst) => inst.ResultId;
    public OpUntypedInBoundsAccessChainKHR(int resultType, int resultId, int baseType, int baseId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedInBoundsAccessChainKHR, ResultType, ResultId, BaseType, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseType":
                    BaseType = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpUntypedInBoundsAccessChainKHR(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSubgroupBallotKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBallotKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBallotKHR | (1 << 16);
    }

    public OpSubgroupBallotKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupBallotKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupBallotKHR inst) => inst.ResultId;
    public OpSubgroupBallotKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBallotKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupBallotKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupFirstInvocationKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupFirstInvocationKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupFirstInvocationKHR | (1 << 16);
    }

    public OpSubgroupFirstInvocationKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupFirstInvocationKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupFirstInvocationKHR inst) => inst.ResultId;
    public OpSubgroupFirstInvocationKHR(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupFirstInvocationKHR, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupFirstInvocationKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUntypedPtrAccessChainKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedPtrAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedPtrAccessChainKHR | (1 << 16);
    }

    public OpUntypedPtrAccessChainKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUntypedPtrAccessChainKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedPtrAccessChainKHR inst) => inst.ResultId;
    public OpUntypedPtrAccessChainKHR(int resultType, int resultId, int baseType, int baseId, int element, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Element = element;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedPtrAccessChainKHR, ResultType, ResultId, BaseType, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseType":
                    BaseType = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "element":
                    Element = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpUntypedPtrAccessChainKHR(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpUntypedInBoundsPtrAccessChainKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedInBoundsPtrAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedInBoundsPtrAccessChainKHR | (1 << 16);
    }

    public OpUntypedInBoundsPtrAccessChainKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUntypedInBoundsPtrAccessChainKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedInBoundsPtrAccessChainKHR inst) => inst.ResultId;
    public OpUntypedInBoundsPtrAccessChainKHR(int resultType, int resultId, int baseType, int baseId, int element, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Element = element;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedInBoundsPtrAccessChainKHR, ResultType, ResultId, BaseType, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseType":
                    BaseType = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "element":
                    Element = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpUntypedInBoundsPtrAccessChainKHR(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpUntypedArrayLengthKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedArrayLengthKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedArrayLengthKHR | (1 << 16);
    }

    public OpUntypedArrayLengthKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUntypedArrayLengthKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Structure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arraymember
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedArrayLengthKHR inst) => inst.ResultId;
    public OpUntypedArrayLengthKHR(int resultType, int resultId, int structure, int pointer, int arraymember)
    {
        ResultType = resultType;
        ResultId = resultId;
        Structure = structure;
        Pointer = pointer;
        Arraymember = arraymember;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedArrayLengthKHR, ResultType, ResultId, Structure, Pointer, ..Arraymember.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "structure":
                    Structure = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "arraymember":
                    Arraymember = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUntypedArrayLengthKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUntypedPrefetchKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedPrefetchKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedPrefetchKHR | (1 << 16);
    }

    public OpUntypedPrefetchKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUntypedPrefetchKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int PointerType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumBytes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? RW
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Locality
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? CacheType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedPrefetchKHR(int pointerType, int numBytes, int? rW, int? locality, int? cacheType)
    {
        PointerType = pointerType;
        NumBytes = numBytes;
        RW = rW;
        Locality = locality;
        CacheType = cacheType;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedPrefetchKHR, PointerType, NumBytes, ..(RW is null ? (Span<int>)[] : [RW.Value]), ..(Locality is null ? (Span<int>)[] : [Locality.Value]), ..(CacheType is null ? (Span<int>)[] : [CacheType.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointerType":
                    PointerType = o.ToLiteral<int>();
                    break;
                case "numBytes":
                    NumBytes = o.ToLiteral<int>();
                    break;
                case "rW":
                    if (o.Words.Length > 0)
                    {
                        RW = o.ToLiteral<int>();
                    }

                    break;
                case "locality":
                    if (o.Words.Length > 0)
                    {
                        Locality = o.ToLiteral<int>();
                    }

                    break;
                case "cacheType":
                    if (o.Words.Length > 0)
                    {
                        CacheType = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUntypedPrefetchKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAllKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAllKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAllKHR | (1 << 16);
    }

    public OpSubgroupAllKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAllKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAllKHR inst) => inst.ResultId;
    public OpSubgroupAllKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAllKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAllKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAnyKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAnyKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAnyKHR | (1 << 16);
    }

    public OpSubgroupAnyKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAnyKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAnyKHR inst) => inst.ResultId;
    public OpSubgroupAnyKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAnyKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAnyKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAllEqualKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAllEqualKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAllEqualKHR | (1 << 16);
    }

    public OpSubgroupAllEqualKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAllEqualKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAllEqualKHR inst) => inst.ResultId;
    public OpSubgroupAllEqualKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAllEqualKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAllEqualKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformRotateKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformRotateKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformRotateKHR | (1 << 16);
    }

    public OpGroupNonUniformRotateKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformRotateKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformRotateKHR inst) => inst.ResultId;
    public OpGroupNonUniformRotateKHR(int resultType, int resultId, int execution, int value, int delta, int? clusterSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        ClusterSize = clusterSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformRotateKHR, ResultType, ResultId, Execution, Value, Delta, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                    {
                        ClusterSize = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformRotateKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupReadInvocationKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupReadInvocationKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupReadInvocationKHR | (1 << 16);
    }

    public OpSubgroupReadInvocationKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupReadInvocationKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupReadInvocationKHR inst) => inst.ResultId;
    public OpSubgroupReadInvocationKHR(int resultType, int resultId, int value, int index)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        Index = index;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupReadInvocationKHR, ResultType, ResultId, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupReadInvocationKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpExtInstWithForwardRefsKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInstWithForwardRefsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInstWithForwardRefsKHR | (1 << 16);
    }

    public OpExtInstWithForwardRefsKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExtInstWithForwardRefsKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Instruction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpExtInstWithForwardRefsKHR inst) => inst.ResultId;
    public OpExtInstWithForwardRefsKHR(int resultType, int resultId, int set, int instruction, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Instruction = instruction;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInstWithForwardRefsKHR, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "instruction":
                    Instruction = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpExtInstWithForwardRefsKHR(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpTraceRayKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceRayKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceRayKHR | (1 << 16);
    }

    public OpTraceRayKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTraceRayKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceRayKHR(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int payload)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceRayKHR, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "sBTOffset":
                    SBTOffset = o.ToLiteral<int>();
                    break;
                case "sBTStride":
                    SBTStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTmin":
                    RayTmin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTmax":
                    RayTmax = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTraceRayKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpExecuteCallableKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecuteCallableKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecuteCallableKHR | (1 << 16);
    }

    public OpExecuteCallableKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExecuteCallableKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CallableData
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecuteCallableKHR(int sBTIndex, int callableData)
    {
        SBTIndex = sBTIndex;
        CallableData = callableData;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecuteCallableKHR, SBTIndex, CallableData];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "sBTIndex":
                    SBTIndex = o.ToLiteral<int>();
                    break;
                case "callableData":
                    CallableData = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpExecuteCallableKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertUToAccelerationStructureKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToAccelerationStructureKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToAccelerationStructureKHR | (1 << 16);
    }

    public OpConvertUToAccelerationStructureKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertUToAccelerationStructureKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToAccelerationStructureKHR inst) => inst.ResultId;
    public OpConvertUToAccelerationStructureKHR(int resultType, int resultId, int accel)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToAccelerationStructureKHR, ResultType, ResultId, Accel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToAccelerationStructureKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIgnoreIntersectionKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIgnoreIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIgnoreIntersectionKHR | (1 << 16);
    }

    public OpIgnoreIntersectionKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIgnoreIntersectionKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIgnoreIntersectionKHR];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIgnoreIntersectionKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTerminateRayKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateRayKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateRayKHR | (1 << 16);
    }

    public OpTerminateRayKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTerminateRayKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTerminateRayKHR];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTerminateRayKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDot : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDot | (1 << 16);
    }

    public OpSDot(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDot(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDot inst) => inst.ResultId;
    public OpSDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDot, ResultType, ResultId, Vector1, Vector2, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                    {
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDot(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUDot : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDot | (1 << 16);
    }

    public OpUDot(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUDot(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUDot inst) => inst.ResultId;
    public OpUDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDot, ResultType, ResultId, Vector1, Vector2, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                    {
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUDot(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSUDot : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSUDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSUDot | (1 << 16);
    }

    public OpSUDot(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSUDot(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSUDot inst) => inst.ResultId;
    public OpSUDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSUDot, ResultType, ResultId, Vector1, Vector2, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                    {
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSUDot(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSDotAccSat : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDotAccSat | (1 << 16);
    }

    public OpSDotAccSat(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSDotAccSat(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDotAccSat inst) => inst.ResultId;
    public OpSDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "accumulator":
                    Accumulator = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                    {
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSDotAccSat(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUDotAccSat : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDotAccSat | (1 << 16);
    }

    public OpUDotAccSat(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUDotAccSat(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUDotAccSat inst) => inst.ResultId;
    public OpUDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "accumulator":
                    Accumulator = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                    {
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUDotAccSat(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSUDotAccSat : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSUDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSUDotAccSat | (1 << 16);
    }

    public OpSUDotAccSat(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSUDotAccSat(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSUDotAccSat inst) => inst.ResultId;
    public OpSUDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSUDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "accumulator":
                    Accumulator = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                    {
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSUDotAccSat(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeCooperativeMatrixKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeCooperativeMatrixKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeCooperativeMatrixKHR | (1 << 16);
    }

    public OpTypeCooperativeMatrixKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeCooperativeMatrixKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scope
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Rows
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Columns
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Use
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeCooperativeMatrixKHR inst) => inst.ResultId;
    public OpTypeCooperativeMatrixKHR(int resultId, int componentType, int scope, int rows, int columns, int use)
    {
        ResultId = resultId;
        ComponentType = componentType;
        Scope = scope;
        Rows = rows;
        Columns = columns;
        Use = use;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeCooperativeMatrixKHR, ResultId, ComponentType, Scope, Rows, Columns, Use];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "componentType":
                    ComponentType = o.ToLiteral<int>();
                    break;
                case "scope":
                    Scope = o.ToLiteral<int>();
                    break;
                case "rows":
                    Rows = o.ToLiteral<int>();
                    break;
                case "columns":
                    Columns = o.ToLiteral<int>();
                    break;
                case "use":
                    Use = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeCooperativeMatrixKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCooperativeMatrixMulAddKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixMulAddKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixMulAddKHR | (1 << 16);
    }

    public OpCooperativeMatrixMulAddKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCooperativeMatrixMulAddKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public CooperativeMatrixOperandsMask? CooperativeMatrixOperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixMulAddKHR inst) => inst.ResultId;
    public OpCooperativeMatrixMulAddKHR(int resultType, int resultId, int a, int b, int c, CooperativeMatrixOperandsMask? cooperativeMatrixOperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        B = b;
        C = c;
        CooperativeMatrixOperands = cooperativeMatrixOperands;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixMulAddKHR, ResultType, ResultId, A, B, C, ..(CooperativeMatrixOperands is null ? (Span<int>)[] : [(int)CooperativeMatrixOperands.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "c":
                    C = o.ToLiteral<int>();
                    break;
                case "cooperativeMatrixOperands":
                    if (o.Words.Length > 0)
                    {
                        CooperativeMatrixOperands = o.ToEnum<CooperativeMatrixOperandsMask>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixMulAddKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCooperativeMatrixLengthKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLengthKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLengthKHR | (1 << 16);
    }

    public OpCooperativeMatrixLengthKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCooperativeMatrixLengthKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixLengthKHR inst) => inst.ResultId;
    public OpCooperativeMatrixLengthKHR(int resultType, int resultId, int type)
    {
        ResultType = resultType;
        ResultId = resultId;
        Type = type;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLengthKHR, ResultType, ResultId, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "type":
                    Type = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixLengthKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantCompositeReplicateEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantCompositeReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantCompositeReplicateEXT | (1 << 16);
    }

    public OpConstantCompositeReplicateEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantCompositeReplicateEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantCompositeReplicateEXT inst) => inst.ResultId;
    public OpConstantCompositeReplicateEXT(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantCompositeReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantCompositeReplicateEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSpecConstantCompositeReplicateEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantCompositeReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantCompositeReplicateEXT | (1 << 16);
    }

    public OpSpecConstantCompositeReplicateEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSpecConstantCompositeReplicateEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantCompositeReplicateEXT inst) => inst.ResultId;
    public OpSpecConstantCompositeReplicateEXT(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantCompositeReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantCompositeReplicateEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCompositeConstructReplicateEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstructReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstructReplicateEXT | (1 << 16);
    }

    public OpCompositeConstructReplicateEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCompositeConstructReplicateEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeConstructReplicateEXT inst) => inst.ResultId;
    public OpCompositeConstructReplicateEXT(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstructReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCompositeConstructReplicateEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeRayQueryKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeRayQueryKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeRayQueryKHR | (1 << 16);
    }

    public OpTypeRayQueryKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeRayQueryKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeRayQueryKHR inst) => inst.ResultId;
    public OpTypeRayQueryKHR(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeRayQueryKHR, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeRayQueryKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryInitializeKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryInitializeKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryInitializeKHR | (1 << 16);
    }

    public OpRayQueryInitializeKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryInitializeKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryInitializeKHR(int rayQuery, int accel, int rayFlags, int cullMask, int rayOrigin, int rayTMin, int rayDirection, int rayTMax)
    {
        RayQuery = rayQuery;
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        RayOrigin = rayOrigin;
        RayTMin = rayTMin;
        RayDirection = rayDirection;
        RayTMax = rayTMax;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryInitializeKHR, RayQuery, Accel, RayFlags, CullMask, RayOrigin, RayTMin, RayDirection, RayTMax];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTMin":
                    RayTMin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTMax":
                    RayTMax = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryInitializeKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryTerminateKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryTerminateKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryTerminateKHR | (1 << 16);
    }

    public OpRayQueryTerminateKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryTerminateKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryTerminateKHR(int rayQuery)
    {
        RayQuery = rayQuery;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryTerminateKHR, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryTerminateKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGenerateIntersectionKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGenerateIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGenerateIntersectionKHR | (1 << 16);
    }

    public OpRayQueryGenerateIntersectionKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGenerateIntersectionKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitT
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGenerateIntersectionKHR(int rayQuery, int hitT)
    {
        RayQuery = rayQuery;
        HitT = hitT;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGenerateIntersectionKHR, RayQuery, HitT];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "hitT":
                    HitT = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGenerateIntersectionKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryConfirmIntersectionKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryConfirmIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryConfirmIntersectionKHR | (1 << 16);
    }

    public OpRayQueryConfirmIntersectionKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryConfirmIntersectionKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryConfirmIntersectionKHR(int rayQuery)
    {
        RayQuery = rayQuery;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryConfirmIntersectionKHR, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryConfirmIntersectionKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryProceedKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryProceedKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryProceedKHR | (1 << 16);
    }

    public OpRayQueryProceedKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryProceedKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryProceedKHR inst) => inst.ResultId;
    public OpRayQueryProceedKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryProceedKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryProceedKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionTypeKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTypeKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTypeKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionTypeKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionTypeKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionTypeKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionTypeKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTypeKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTypeKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageSampleWeightedQCOM : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleWeightedQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleWeightedQCOM | (1 << 16);
    }

    public OpImageSampleWeightedQCOM(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleWeightedQCOM(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texture
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Weights
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleWeightedQCOM inst) => inst.ResultId;
    public OpImageSampleWeightedQCOM(int resultType, int resultId, int texture, int coordinates, int weights)
    {
        ResultType = resultType;
        ResultId = resultId;
        Texture = texture;
        Coordinates = coordinates;
        Weights = weights;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleWeightedQCOM, ResultType, ResultId, Texture, Coordinates, Weights];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "texture":
                    Texture = o.ToLiteral<int>();
                    break;
                case "coordinates":
                    Coordinates = o.ToLiteral<int>();
                    break;
                case "weights":
                    Weights = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleWeightedQCOM(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageBoxFilterQCOM : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBoxFilterQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBoxFilterQCOM | (1 << 16);
    }

    public OpImageBoxFilterQCOM(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageBoxFilterQCOM(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texture
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BoxSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBoxFilterQCOM inst) => inst.ResultId;
    public OpImageBoxFilterQCOM(int resultType, int resultId, int texture, int coordinates, int boxSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Texture = texture;
        Coordinates = coordinates;
        BoxSize = boxSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBoxFilterQCOM, ResultType, ResultId, Texture, Coordinates, BoxSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "texture":
                    Texture = o.ToLiteral<int>();
                    break;
                case "coordinates":
                    Coordinates = o.ToLiteral<int>();
                    break;
                case "boxSize":
                    BoxSize = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageBoxFilterQCOM(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageBlockMatchSSDQCOM : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchSSDQCOM | (1 << 16);
    }

    public OpImageBlockMatchSSDQCOM(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageBlockMatchSSDQCOM(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Reference
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchSSDQCOM inst) => inst.ResultId;
    public OpImageBlockMatchSSDQCOM(int resultType, int resultId, int target, int targetCoordinates, int reference, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        TargetCoordinates = targetCoordinates;
        Reference = reference;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchSSDQCOM, ResultType, ResultId, Target, TargetCoordinates, Reference, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "reference":
                    Reference = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchSSDQCOM(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageBlockMatchSADQCOM : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchSADQCOM | (1 << 16);
    }

    public OpImageBlockMatchSADQCOM(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageBlockMatchSADQCOM(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Reference
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchSADQCOM inst) => inst.ResultId;
    public OpImageBlockMatchSADQCOM(int resultType, int resultId, int target, int targetCoordinates, int reference, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        TargetCoordinates = targetCoordinates;
        Reference = reference;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchSADQCOM, ResultType, ResultId, Target, TargetCoordinates, Reference, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "reference":
                    Reference = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchSADQCOM(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageBlockMatchWindowSSDQCOM : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchWindowSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchWindowSSDQCOM | (1 << 16);
    }

    public OpImageBlockMatchWindowSSDQCOM(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageBlockMatchWindowSSDQCOM(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchWindowSSDQCOM inst) => inst.ResultId;
    public OpImageBlockMatchWindowSSDQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchWindowSSDQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "targetSampledImage":
                    TargetSampledImage = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "referenceSampledImage":
                    ReferenceSampledImage = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchWindowSSDQCOM(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageBlockMatchWindowSADQCOM : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchWindowSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchWindowSADQCOM | (1 << 16);
    }

    public OpImageBlockMatchWindowSADQCOM(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageBlockMatchWindowSADQCOM(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchWindowSADQCOM inst) => inst.ResultId;
    public OpImageBlockMatchWindowSADQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchWindowSADQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "targetSampledImage":
                    TargetSampledImage = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "referenceSampledImage":
                    ReferenceSampledImage = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchWindowSADQCOM(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageBlockMatchGatherSSDQCOM : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchGatherSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchGatherSSDQCOM | (1 << 16);
    }

    public OpImageBlockMatchGatherSSDQCOM(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageBlockMatchGatherSSDQCOM(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchGatherSSDQCOM inst) => inst.ResultId;
    public OpImageBlockMatchGatherSSDQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchGatherSSDQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "targetSampledImage":
                    TargetSampledImage = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "referenceSampledImage":
                    ReferenceSampledImage = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchGatherSSDQCOM(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageBlockMatchGatherSADQCOM : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchGatherSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchGatherSADQCOM | (1 << 16);
    }

    public OpImageBlockMatchGatherSADQCOM(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageBlockMatchGatherSADQCOM(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchGatherSADQCOM inst) => inst.ResultId;
    public OpImageBlockMatchGatherSADQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchGatherSADQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "targetSampledImage":
                    TargetSampledImage = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "referenceSampledImage":
                    ReferenceSampledImage = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchGatherSADQCOM(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupIAddNonUniformAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIAddNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIAddNonUniformAMD | (1 << 16);
    }

    public OpGroupIAddNonUniformAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupIAddNonUniformAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupIAddNonUniformAMD inst) => inst.ResultId;
    public OpGroupIAddNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIAddNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupIAddNonUniformAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupFAddNonUniformAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFAddNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFAddNonUniformAMD | (1 << 16);
    }

    public OpGroupFAddNonUniformAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupFAddNonUniformAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFAddNonUniformAMD inst) => inst.ResultId;
    public OpGroupFAddNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFAddNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupFAddNonUniformAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupFMinNonUniformAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMinNonUniformAMD | (1 << 16);
    }

    public OpGroupFMinNonUniformAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupFMinNonUniformAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMinNonUniformAMD inst) => inst.ResultId;
    public OpGroupFMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupUMinNonUniformAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMinNonUniformAMD | (1 << 16);
    }

    public OpGroupUMinNonUniformAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupUMinNonUniformAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupUMinNonUniformAMD inst) => inst.ResultId;
    public OpGroupUMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupUMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupSMinNonUniformAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMinNonUniformAMD | (1 << 16);
    }

    public OpGroupSMinNonUniformAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupSMinNonUniformAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupSMinNonUniformAMD inst) => inst.ResultId;
    public OpGroupSMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupSMinNonUniformAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupFMaxNonUniformAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMaxNonUniformAMD | (1 << 16);
    }

    public OpGroupFMaxNonUniformAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupFMaxNonUniformAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMaxNonUniformAMD inst) => inst.ResultId;
    public OpGroupFMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupUMaxNonUniformAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMaxNonUniformAMD | (1 << 16);
    }

    public OpGroupUMaxNonUniformAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupUMaxNonUniformAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupUMaxNonUniformAMD inst) => inst.ResultId;
    public OpGroupUMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupUMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupSMaxNonUniformAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMaxNonUniformAMD | (1 << 16);
    }

    public OpGroupSMaxNonUniformAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupSMaxNonUniformAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupSMaxNonUniformAMD inst) => inst.ResultId;
    public OpGroupSMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupSMaxNonUniformAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFragmentMaskFetchAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFragmentMaskFetchAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFragmentMaskFetchAMD | (1 << 16);
    }

    public OpFragmentMaskFetchAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFragmentMaskFetchAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFragmentMaskFetchAMD inst) => inst.ResultId;
    public OpFragmentMaskFetchAMD(int resultType, int resultId, int image, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFragmentMaskFetchAMD, ResultType, ResultId, Image, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFragmentMaskFetchAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFragmentFetchAMD : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFragmentFetchAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFragmentFetchAMD | (1 << 16);
    }

    public OpFragmentFetchAMD(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFragmentFetchAMD(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FragmentIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFragmentFetchAMD inst) => inst.ResultId;
    public OpFragmentFetchAMD(int resultType, int resultId, int image, int coordinate, int fragmentIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        FragmentIndex = fragmentIndex;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFragmentFetchAMD, ResultType, ResultId, Image, Coordinate, FragmentIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "fragmentIndex":
                    FragmentIndex = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFragmentFetchAMD(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReadClockKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadClockKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadClockKHR | (1 << 16);
    }

    public OpReadClockKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReadClockKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scope
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReadClockKHR inst) => inst.ResultId;
    public OpReadClockKHR(int resultType, int resultId, int scope)
    {
        ResultType = resultType;
        ResultId = resultId;
        Scope = scope;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadClockKHR, ResultType, ResultId, Scope];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "scope":
                    Scope = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReadClockKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAllocateNodePayloadsAMDX : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAllocateNodePayloadsAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAllocateNodePayloadsAMDX | (1 << 16);
    }

    public OpAllocateNodePayloadsAMDX(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAllocateNodePayloadsAMDX(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Visibility
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NodeIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAllocateNodePayloadsAMDX inst) => inst.ResultId;
    public OpAllocateNodePayloadsAMDX(int resultType, int resultId, int visibility, int payloadCount, int nodeIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        Visibility = visibility;
        PayloadCount = payloadCount;
        NodeIndex = nodeIndex;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAllocateNodePayloadsAMDX, ResultType, ResultId, Visibility, PayloadCount, NodeIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "visibility":
                    Visibility = o.ToLiteral<int>();
                    break;
                case "payloadCount":
                    PayloadCount = o.ToLiteral<int>();
                    break;
                case "nodeIndex":
                    NodeIndex = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAllocateNodePayloadsAMDX(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEnqueueNodePayloadsAMDX : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueNodePayloadsAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueNodePayloadsAMDX | (1 << 16);
    }

    public OpEnqueueNodePayloadsAMDX(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEnqueueNodePayloadsAMDX(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int PayloadArray
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEnqueueNodePayloadsAMDX(int payloadArray)
    {
        PayloadArray = payloadArray;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueNodePayloadsAMDX, PayloadArray];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "payloadArray":
                    PayloadArray = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpEnqueueNodePayloadsAMDX(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeNodePayloadArrayAMDX : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeNodePayloadArrayAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeNodePayloadArrayAMDX | (1 << 16);
    }

    public OpTypeNodePayloadArrayAMDX(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeNodePayloadArrayAMDX(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeNodePayloadArrayAMDX inst) => inst.ResultId;
    public OpTypeNodePayloadArrayAMDX(int resultId, int payloadType)
    {
        ResultId = resultId;
        PayloadType = payloadType;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeNodePayloadArrayAMDX, ResultId, PayloadType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payloadType":
                    PayloadType = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeNodePayloadArrayAMDX(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFinishWritingNodePayloadAMDX : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFinishWritingNodePayloadAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFinishWritingNodePayloadAMDX | (1 << 16);
    }

    public OpFinishWritingNodePayloadAMDX(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFinishWritingNodePayloadAMDX(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFinishWritingNodePayloadAMDX inst) => inst.ResultId;
    public OpFinishWritingNodePayloadAMDX(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFinishWritingNodePayloadAMDX, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFinishWritingNodePayloadAMDX(OpDataIndex odi) => new(odi);
}

public ref partial struct OpNodePayloadArrayLengthAMDX : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNodePayloadArrayLengthAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNodePayloadArrayLengthAMDX | (1 << 16);
    }

    public OpNodePayloadArrayLengthAMDX(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpNodePayloadArrayLengthAMDX(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadArray
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpNodePayloadArrayLengthAMDX inst) => inst.ResultId;
    public OpNodePayloadArrayLengthAMDX(int resultType, int resultId, int payloadArray)
    {
        ResultType = resultType;
        ResultId = resultId;
        PayloadArray = payloadArray;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNodePayloadArrayLengthAMDX, ResultType, ResultId, PayloadArray];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payloadArray":
                    PayloadArray = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpNodePayloadArrayLengthAMDX(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIsNodePayloadValidAMDX : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNodePayloadValidAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNodePayloadValidAMDX | (1 << 16);
    }

    public OpIsNodePayloadValidAMDX(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIsNodePayloadValidAMDX(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NodeIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsNodePayloadValidAMDX inst) => inst.ResultId;
    public OpIsNodePayloadValidAMDX(int resultType, int resultId, int payloadType, int nodeIndex)
    {
        ResultType = resultType;
        ResultId = resultId;
        PayloadType = payloadType;
        NodeIndex = nodeIndex;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNodePayloadValidAMDX, ResultType, ResultId, PayloadType, NodeIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payloadType":
                    PayloadType = o.ToLiteral<int>();
                    break;
                case "nodeIndex":
                    NodeIndex = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIsNodePayloadValidAMDX(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantStringAMDX : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantStringAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantStringAMDX | (1 << 16);
    }

    public OpConstantStringAMDX(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantStringAMDX(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string LiteralString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantStringAMDX inst) => inst.ResultId;
    public OpConstantStringAMDX(int resultId, string literalString)
    {
        ResultId = resultId;
        LiteralString = literalString;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantStringAMDX, ResultId, ..LiteralString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "literalString":
                    LiteralString = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantStringAMDX(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSpecConstantStringAMDX : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantStringAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantStringAMDX | (1 << 16);
    }

    public OpSpecConstantStringAMDX(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSpecConstantStringAMDX(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string LiteralString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantStringAMDX inst) => inst.ResultId;
    public OpSpecConstantStringAMDX(int resultId, string literalString)
    {
        ResultId = resultId;
        LiteralString = literalString;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantStringAMDX, ResultId, ..LiteralString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "literalString":
                    LiteralString = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantStringAMDX(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformQuadAllKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadAllKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadAllKHR | (1 << 16);
    }

    public OpGroupNonUniformQuadAllKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformQuadAllKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformQuadAllKHR inst) => inst.ResultId;
    public OpGroupNonUniformQuadAllKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadAllKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformQuadAllKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformQuadAnyKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadAnyKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadAnyKHR | (1 << 16);
    }

    public OpGroupNonUniformQuadAnyKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformQuadAnyKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformQuadAnyKHR inst) => inst.ResultId;
    public OpGroupNonUniformQuadAnyKHR(int resultType, int resultId, int predicate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadAnyKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformQuadAnyKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectRecordHitMotionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitMotionNV | (1 << 16);
    }

    public OpHitObjectRecordHitMotionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectRecordHitMotionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitMotionNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordOffset, int sBTRecordStride, int origin, int tMin, int direction, int tMax, int currentTime, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitMotionNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordOffset, SBTRecordStride, Origin, TMin, Direction, TMax, CurrentTime, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "primitiveId":
                    PrimitiveId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                case "sBTRecordOffset":
                    SBTRecordOffset = o.ToLiteral<int>();
                    break;
                case "sBTRecordStride":
                    SBTRecordStride = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "currentTime":
                    CurrentTime = o.ToLiteral<int>();
                    break;
                case "hitObjectAttributes":
                    HitObjectAttributes = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordHitMotionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectRecordHitWithIndexMotionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitWithIndexMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitWithIndexMotionNV | (1 << 16);
    }

    public OpHitObjectRecordHitWithIndexMotionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectRecordHitWithIndexMotionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitWithIndexMotionNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordIndex, int origin, int tMin, int direction, int tMax, int currentTime, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordIndex = sBTRecordIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitWithIndexMotionNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordIndex, Origin, TMin, Direction, TMax, CurrentTime, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "primitiveId":
                    PrimitiveId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                case "sBTRecordIndex":
                    SBTRecordIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "currentTime":
                    CurrentTime = o.ToLiteral<int>();
                    break;
                case "hitObjectAttributes":
                    HitObjectAttributes = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordHitWithIndexMotionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectRecordMissMotionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordMissMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordMissMotionNV | (1 << 16);
    }

    public OpHitObjectRecordMissMotionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectRecordMissMotionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordMissMotionNV(int hitObject, int sBTIndex, int origin, int tMin, int direction, int tMax, int currentTime)
    {
        HitObject = hitObject;
        SBTIndex = sBTIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordMissMotionNV, HitObject, SBTIndex, Origin, TMin, Direction, TMax, CurrentTime];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "sBTIndex":
                    SBTIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "currentTime":
                    CurrentTime = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordMissMotionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetWorldToObjectNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldToObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldToObjectNV | (1 << 16);
    }

    public OpHitObjectGetWorldToObjectNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetWorldToObjectNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetWorldToObjectNV inst) => inst.ResultId;
    public OpHitObjectGetWorldToObjectNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldToObjectNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetWorldToObjectNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetObjectToWorldNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectToWorldNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectToWorldNV | (1 << 16);
    }

    public OpHitObjectGetObjectToWorldNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetObjectToWorldNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetObjectToWorldNV inst) => inst.ResultId;
    public OpHitObjectGetObjectToWorldNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectToWorldNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetObjectToWorldNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetObjectRayDirectionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectRayDirectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectRayDirectionNV | (1 << 16);
    }

    public OpHitObjectGetObjectRayDirectionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetObjectRayDirectionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetObjectRayDirectionNV inst) => inst.ResultId;
    public OpHitObjectGetObjectRayDirectionNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectRayDirectionNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetObjectRayDirectionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetObjectRayOriginNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectRayOriginNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectRayOriginNV | (1 << 16);
    }

    public OpHitObjectGetObjectRayOriginNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetObjectRayOriginNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetObjectRayOriginNV inst) => inst.ResultId;
    public OpHitObjectGetObjectRayOriginNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectRayOriginNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetObjectRayOriginNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectTraceRayMotionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectTraceRayMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectTraceRayMotionNV | (1 << 16);
    }

    public OpHitObjectTraceRayMotionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectTraceRayMotionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Cullmask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectTraceRayMotionNV(int hitObject, int accelerationStructure, int rayFlags, int cullmask, int sBTRecordOffset, int sBTRecordStride, int missIndex, int origin, int tMin, int direction, int tMax, int time, int payload)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        RayFlags = rayFlags;
        Cullmask = cullmask;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        MissIndex = missIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        Time = time;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectTraceRayMotionNV, HitObject, AccelerationStructure, RayFlags, Cullmask, SBTRecordOffset, SBTRecordStride, MissIndex, Origin, TMin, Direction, TMax, Time, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullmask":
                    Cullmask = o.ToLiteral<int>();
                    break;
                case "sBTRecordOffset":
                    SBTRecordOffset = o.ToLiteral<int>();
                    break;
                case "sBTRecordStride":
                    SBTRecordStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "time":
                    Time = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectTraceRayMotionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetShaderRecordBufferHandleNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetShaderRecordBufferHandleNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetShaderRecordBufferHandleNV | (1 << 16);
    }

    public OpHitObjectGetShaderRecordBufferHandleNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetShaderRecordBufferHandleNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetShaderRecordBufferHandleNV inst) => inst.ResultId;
    public OpHitObjectGetShaderRecordBufferHandleNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetShaderRecordBufferHandleNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetShaderRecordBufferHandleNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetShaderBindingTableRecordIndexNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetShaderBindingTableRecordIndexNV | (1 << 16);
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetShaderBindingTableRecordIndexNV inst) => inst.ResultId;
    public OpHitObjectGetShaderBindingTableRecordIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetShaderBindingTableRecordIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetShaderBindingTableRecordIndexNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectRecordEmptyNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordEmptyNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordEmptyNV | (1 << 16);
    }

    public OpHitObjectRecordEmptyNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectRecordEmptyNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordEmptyNV(int hitObject)
    {
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordEmptyNV, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordEmptyNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectTraceRayNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectTraceRayNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectTraceRayNV | (1 << 16);
    }

    public OpHitObjectTraceRayNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectTraceRayNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Cullmask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectTraceRayNV(int hitObject, int accelerationStructure, int rayFlags, int cullmask, int sBTRecordOffset, int sBTRecordStride, int missIndex, int origin, int tMin, int direction, int tMax, int payload)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        RayFlags = rayFlags;
        Cullmask = cullmask;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        MissIndex = missIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectTraceRayNV, HitObject, AccelerationStructure, RayFlags, Cullmask, SBTRecordOffset, SBTRecordStride, MissIndex, Origin, TMin, Direction, TMax, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullmask":
                    Cullmask = o.ToLiteral<int>();
                    break;
                case "sBTRecordOffset":
                    SBTRecordOffset = o.ToLiteral<int>();
                    break;
                case "sBTRecordStride":
                    SBTRecordStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectTraceRayNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectRecordHitNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitNV | (1 << 16);
    }

    public OpHitObjectRecordHitNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectRecordHitNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordOffset, int sBTRecordStride, int origin, int tMin, int direction, int tMax, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordOffset, SBTRecordStride, Origin, TMin, Direction, TMax, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "primitiveId":
                    PrimitiveId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                case "sBTRecordOffset":
                    SBTRecordOffset = o.ToLiteral<int>();
                    break;
                case "sBTRecordStride":
                    SBTRecordStride = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "hitObjectAttributes":
                    HitObjectAttributes = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordHitNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectRecordHitWithIndexNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitWithIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitWithIndexNV | (1 << 16);
    }

    public OpHitObjectRecordHitWithIndexNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectRecordHitWithIndexNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitWithIndexNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordIndex, int origin, int tMin, int direction, int tMax, int hitObjectAttributes)
    {
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordIndex = sBTRecordIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        HitObjectAttributes = hitObjectAttributes;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitWithIndexNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordIndex, Origin, TMin, Direction, TMax, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "primitiveId":
                    PrimitiveId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                case "sBTRecordIndex":
                    SBTRecordIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "hitObjectAttributes":
                    HitObjectAttributes = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordHitWithIndexNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectRecordMissNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordMissNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordMissNV | (1 << 16);
    }

    public OpHitObjectRecordMissNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectRecordMissNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordMissNV(int hitObject, int sBTIndex, int origin, int tMin, int direction, int tMax)
    {
        HitObject = hitObject;
        SBTIndex = sBTIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordMissNV, HitObject, SBTIndex, Origin, TMin, Direction, TMax];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "sBTIndex":
                    SBTIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordMissNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectExecuteShaderNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectExecuteShaderNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectExecuteShaderNV | (1 << 16);
    }

    public OpHitObjectExecuteShaderNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectExecuteShaderNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectExecuteShaderNV(int hitObject, int payload)
    {
        HitObject = hitObject;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectExecuteShaderNV, HitObject, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectExecuteShaderNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetCurrentTimeNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetCurrentTimeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetCurrentTimeNV | (1 << 16);
    }

    public OpHitObjectGetCurrentTimeNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetCurrentTimeNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetCurrentTimeNV inst) => inst.ResultId;
    public OpHitObjectGetCurrentTimeNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetCurrentTimeNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetCurrentTimeNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetAttributesNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetAttributesNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetAttributesNV | (1 << 16);
    }

    public OpHitObjectGetAttributesNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetAttributesNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttribute
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetAttributesNV(int hitObject, int hitObjectAttribute)
    {
        HitObject = hitObject;
        HitObjectAttribute = hitObjectAttribute;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetAttributesNV, HitObject, HitObjectAttribute];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "hitObjectAttribute":
                    HitObjectAttribute = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetAttributesNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetHitKindNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetHitKindNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetHitKindNV | (1 << 16);
    }

    public OpHitObjectGetHitKindNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetHitKindNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetHitKindNV inst) => inst.ResultId;
    public OpHitObjectGetHitKindNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetHitKindNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetHitKindNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetPrimitiveIndexNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetPrimitiveIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetPrimitiveIndexNV | (1 << 16);
    }

    public OpHitObjectGetPrimitiveIndexNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetPrimitiveIndexNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetPrimitiveIndexNV inst) => inst.ResultId;
    public OpHitObjectGetPrimitiveIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetPrimitiveIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetPrimitiveIndexNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetGeometryIndexNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetGeometryIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetGeometryIndexNV | (1 << 16);
    }

    public OpHitObjectGetGeometryIndexNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetGeometryIndexNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetGeometryIndexNV inst) => inst.ResultId;
    public OpHitObjectGetGeometryIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetGeometryIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetGeometryIndexNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetInstanceIdNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetInstanceIdNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetInstanceIdNV | (1 << 16);
    }

    public OpHitObjectGetInstanceIdNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetInstanceIdNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetInstanceIdNV inst) => inst.ResultId;
    public OpHitObjectGetInstanceIdNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetInstanceIdNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetInstanceIdNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetInstanceCustomIndexNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetInstanceCustomIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetInstanceCustomIndexNV | (1 << 16);
    }

    public OpHitObjectGetInstanceCustomIndexNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetInstanceCustomIndexNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetInstanceCustomIndexNV inst) => inst.ResultId;
    public OpHitObjectGetInstanceCustomIndexNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetInstanceCustomIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetInstanceCustomIndexNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetWorldRayDirectionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldRayDirectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldRayDirectionNV | (1 << 16);
    }

    public OpHitObjectGetWorldRayDirectionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetWorldRayDirectionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetWorldRayDirectionNV inst) => inst.ResultId;
    public OpHitObjectGetWorldRayDirectionNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldRayDirectionNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetWorldRayDirectionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetWorldRayOriginNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldRayOriginNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldRayOriginNV | (1 << 16);
    }

    public OpHitObjectGetWorldRayOriginNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetWorldRayOriginNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetWorldRayOriginNV inst) => inst.ResultId;
    public OpHitObjectGetWorldRayOriginNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldRayOriginNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetWorldRayOriginNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetRayTMaxNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetRayTMaxNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetRayTMaxNV | (1 << 16);
    }

    public OpHitObjectGetRayTMaxNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetRayTMaxNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetRayTMaxNV inst) => inst.ResultId;
    public OpHitObjectGetRayTMaxNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetRayTMaxNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetRayTMaxNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectGetRayTMinNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetRayTMinNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetRayTMinNV | (1 << 16);
    }

    public OpHitObjectGetRayTMinNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectGetRayTMinNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetRayTMinNV inst) => inst.ResultId;
    public OpHitObjectGetRayTMinNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetRayTMinNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetRayTMinNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectIsEmptyNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsEmptyNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsEmptyNV | (1 << 16);
    }

    public OpHitObjectIsEmptyNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectIsEmptyNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectIsEmptyNV inst) => inst.ResultId;
    public OpHitObjectIsEmptyNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsEmptyNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectIsEmptyNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectIsHitNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsHitNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsHitNV | (1 << 16);
    }

    public OpHitObjectIsHitNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectIsHitNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectIsHitNV inst) => inst.ResultId;
    public OpHitObjectIsHitNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsHitNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectIsHitNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpHitObjectIsMissNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsMissNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsMissNV | (1 << 16);
    }

    public OpHitObjectIsMissNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpHitObjectIsMissNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectIsMissNV inst) => inst.ResultId;
    public OpHitObjectIsMissNV(int resultType, int resultId, int hitObject)
    {
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsMissNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectIsMissNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReorderThreadWithHitObjectNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReorderThreadWithHitObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReorderThreadWithHitObjectNV | (1 << 16);
    }

    public OpReorderThreadWithHitObjectNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReorderThreadWithHitObjectNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Hint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Bits
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReorderThreadWithHitObjectNV(int hitObject, int? hint, int? bits)
    {
        HitObject = hitObject;
        Hint = hint;
        Bits = bits;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReorderThreadWithHitObjectNV, HitObject, ..(Hint is null ? (Span<int>)[] : [Hint.Value]), ..(Bits is null ? (Span<int>)[] : [Bits.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "hint":
                    if (o.Words.Length > 0)
                    {
                        Hint = o.ToLiteral<int>();
                    }

                    break;
                case "bits":
                    if (o.Words.Length > 0)
                    {
                        Bits = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReorderThreadWithHitObjectNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReorderThreadWithHintNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReorderThreadWithHintNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReorderThreadWithHintNV | (1 << 16);
    }

    public OpReorderThreadWithHintNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReorderThreadWithHintNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Hint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Bits
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReorderThreadWithHintNV(int hint, int bits)
    {
        Hint = hint;
        Bits = bits;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReorderThreadWithHintNV, Hint, Bits];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hint":
                    Hint = o.ToLiteral<int>();
                    break;
                case "bits":
                    Bits = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReorderThreadWithHintNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeHitObjectNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeHitObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeHitObjectNV | (1 << 16);
    }

    public OpTypeHitObjectNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeHitObjectNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeHitObjectNV inst) => inst.ResultId;
    public OpTypeHitObjectNV(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeHitObjectNV, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeHitObjectNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpImageSampleFootprintNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleFootprintNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleFootprintNV | (1 << 16);
    }

    public OpImageSampleFootprintNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpImageSampleFootprintNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Granularity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coarse
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageOperandsMask? Imageoperands { get; set; }

    public EnumerantParameters ImageoperandsParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleFootprintNV inst) => inst.ResultId;
    public OpImageSampleFootprintNV(int resultType, int resultId, int sampledImage, int coordinate, int granularity, int coarse, ImageOperandsMask? imageoperands, EnumerantParameters imageoperandsParameters)
    {
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Granularity = granularity;
        Coarse = coarse;
        Imageoperands = imageoperands;
        ImageoperandsParameters = imageoperandsParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleFootprintNV, ResultType, ResultId, SampledImage, Coordinate, Granularity, Coarse, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value, ..ImageoperandsParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "granularity":
                    Granularity = o.ToLiteral<int>();
                    break;
                case "coarse":
                    Coarse = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                    {
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            ImageoperandsParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleFootprintNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        ImageoperandsParameters.Dispose();
    }
}

public ref partial struct OpCooperativeMatrixConvertNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixConvertNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixConvertNV | (1 << 16);
    }

    public OpCooperativeMatrixConvertNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCooperativeMatrixConvertNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixConvertNV inst) => inst.ResultId;
    public OpCooperativeMatrixConvertNV(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixConvertNV, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixConvertNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEmitMeshTasksEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitMeshTasksEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitMeshTasksEXT | (1 << 16);
    }

    public OpEmitMeshTasksEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEmitMeshTasksEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int GroupCountX
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GroupCountY
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GroupCountZ
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEmitMeshTasksEXT(int groupCountX, int groupCountY, int groupCountZ, int? payload)
    {
        GroupCountX = groupCountX;
        GroupCountY = groupCountY;
        GroupCountZ = groupCountZ;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEmitMeshTasksEXT, GroupCountX, GroupCountY, GroupCountZ, ..(Payload is null ? (Span<int>)[] : [Payload.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "groupCountX":
                    GroupCountX = o.ToLiteral<int>();
                    break;
                case "groupCountY":
                    GroupCountY = o.ToLiteral<int>();
                    break;
                case "groupCountZ":
                    GroupCountZ = o.ToLiteral<int>();
                    break;
                case "payload":
                    if (o.Words.Length > 0)
                    {
                        Payload = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpEmitMeshTasksEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSetMeshOutputsEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSetMeshOutputsEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSetMeshOutputsEXT | (1 << 16);
    }

    public OpSetMeshOutputsEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSetMeshOutputsEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int VertexCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSetMeshOutputsEXT(int vertexCount, int primitiveCount)
    {
        VertexCount = vertexCount;
        PrimitiveCount = primitiveCount;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSetMeshOutputsEXT, VertexCount, PrimitiveCount];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "vertexCount":
                    VertexCount = o.ToLiteral<int>();
                    break;
                case "primitiveCount":
                    PrimitiveCount = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSetMeshOutputsEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupNonUniformPartitionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformPartitionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformPartitionNV | (1 << 16);
    }

    public OpGroupNonUniformPartitionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupNonUniformPartitionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformPartitionNV inst) => inst.ResultId;
    public OpGroupNonUniformPartitionNV(int resultType, int resultId, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformPartitionNV, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformPartitionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpWritePackedPrimitiveIndices4x8NV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePackedPrimitiveIndices4x8NV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePackedPrimitiveIndices4x8NV | (1 << 16);
    }

    public OpWritePackedPrimitiveIndices4x8NV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpWritePackedPrimitiveIndices4x8NV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int IndexOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedIndices
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpWritePackedPrimitiveIndices4x8NV(int indexOffset, int packedIndices)
    {
        IndexOffset = indexOffset;
        PackedIndices = packedIndices;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePackedPrimitiveIndices4x8NV, IndexOffset, PackedIndices];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "indexOffset":
                    IndexOffset = o.ToLiteral<int>();
                    break;
                case "packedIndices":
                    PackedIndices = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpWritePackedPrimitiveIndices4x8NV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFetchMicroTriangleVertexPositionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFetchMicroTriangleVertexPositionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFetchMicroTriangleVertexPositionNV | (1 << 16);
    }

    public OpFetchMicroTriangleVertexPositionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFetchMicroTriangleVertexPositionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Barycentric
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFetchMicroTriangleVertexPositionNV inst) => inst.ResultId;
    public OpFetchMicroTriangleVertexPositionNV(int resultType, int resultId, int accel, int instanceId, int geometryIndex, int primitiveIndex, int barycentric)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        InstanceId = instanceId;
        GeometryIndex = geometryIndex;
        PrimitiveIndex = primitiveIndex;
        Barycentric = barycentric;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFetchMicroTriangleVertexPositionNV, ResultType, ResultId, Accel, InstanceId, GeometryIndex, PrimitiveIndex, Barycentric];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "primitiveIndex":
                    PrimitiveIndex = o.ToLiteral<int>();
                    break;
                case "barycentric":
                    Barycentric = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFetchMicroTriangleVertexPositionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFetchMicroTriangleVertexBarycentricNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFetchMicroTriangleVertexBarycentricNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFetchMicroTriangleVertexBarycentricNV | (1 << 16);
    }

    public OpFetchMicroTriangleVertexBarycentricNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFetchMicroTriangleVertexBarycentricNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Barycentric
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFetchMicroTriangleVertexBarycentricNV inst) => inst.ResultId;
    public OpFetchMicroTriangleVertexBarycentricNV(int resultType, int resultId, int accel, int instanceId, int geometryIndex, int primitiveIndex, int barycentric)
    {
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        InstanceId = instanceId;
        GeometryIndex = geometryIndex;
        PrimitiveIndex = primitiveIndex;
        Barycentric = barycentric;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFetchMicroTriangleVertexBarycentricNV, ResultType, ResultId, Accel, InstanceId, GeometryIndex, PrimitiveIndex, Barycentric];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "primitiveIndex":
                    PrimitiveIndex = o.ToLiteral<int>();
                    break;
                case "barycentric":
                    Barycentric = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFetchMicroTriangleVertexBarycentricNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReportIntersectionKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReportIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReportIntersectionKHR | (1 << 16);
    }

    public OpReportIntersectionKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReportIntersectionKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Hit
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReportIntersectionKHR inst) => inst.ResultId;
    public OpReportIntersectionKHR(int resultType, int resultId, int hit, int hitKind)
    {
        ResultType = resultType;
        ResultId = resultId;
        Hit = hit;
        HitKind = hitKind;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReportIntersectionKHR, ResultType, ResultId, Hit, HitKind];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hit":
                    Hit = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReportIntersectionKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIgnoreIntersectionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIgnoreIntersectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIgnoreIntersectionNV | (1 << 16);
    }

    public OpIgnoreIntersectionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIgnoreIntersectionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIgnoreIntersectionNV];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIgnoreIntersectionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTerminateRayNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateRayNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateRayNV | (1 << 16);
    }

    public OpTerminateRayNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTerminateRayNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTerminateRayNV];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTerminateRayNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTraceNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceNV | (1 << 16);
    }

    public OpTraceNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTraceNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int payloadId)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        PayloadId = payloadId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, PayloadId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "sBTOffset":
                    SBTOffset = o.ToLiteral<int>();
                    break;
                case "sBTStride":
                    SBTStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTmin":
                    RayTmin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTmax":
                    RayTmax = o.ToLiteral<int>();
                    break;
                case "payloadId":
                    PayloadId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTraceNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTraceMotionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceMotionNV | (1 << 16);
    }

    public OpTraceMotionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTraceMotionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceMotionNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int time, int payloadId)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Time = time;
        PayloadId = payloadId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceMotionNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Time, PayloadId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "sBTOffset":
                    SBTOffset = o.ToLiteral<int>();
                    break;
                case "sBTStride":
                    SBTStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTmin":
                    RayTmin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTmax":
                    RayTmax = o.ToLiteral<int>();
                    break;
                case "time":
                    Time = o.ToLiteral<int>();
                    break;
                case "payloadId":
                    PayloadId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTraceMotionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTraceRayMotionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceRayMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceRayMotionNV | (1 << 16);
    }

    public OpTraceRayMotionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTraceRayMotionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceRayMotionNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int time, int payload)
    {
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Time = time;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceRayMotionNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Time, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "sBTOffset":
                    SBTOffset = o.ToLiteral<int>();
                    break;
                case "sBTStride":
                    SBTStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTmin":
                    RayTmin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTmax":
                    RayTmax = o.ToLiteral<int>();
                    break;
                case "time":
                    Time = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTraceRayMotionNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionTriangleVertexPositionsKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTriangleVertexPositionsKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionTriangleVertexPositionsKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTriangleVertexPositionsKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAccelerationStructureKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAccelerationStructureKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAccelerationStructureKHR | (1 << 16);
    }

    public OpTypeAccelerationStructureKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAccelerationStructureKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAccelerationStructureKHR inst) => inst.ResultId;
    public OpTypeAccelerationStructureKHR(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAccelerationStructureKHR, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAccelerationStructureKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpExecuteCallableNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecuteCallableNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecuteCallableNV | (1 << 16);
    }

    public OpExecuteCallableNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExecuteCallableNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CallableDataId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecuteCallableNV(int sBTIndex, int callableDataId)
    {
        SBTIndex = sBTIndex;
        CallableDataId = callableDataId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecuteCallableNV, SBTIndex, CallableDataId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "sBTIndex":
                    SBTIndex = o.ToLiteral<int>();
                    break;
                case "callableDataId":
                    CallableDataId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpExecuteCallableNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeCooperativeMatrixNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeCooperativeMatrixNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeCooperativeMatrixNV | (1 << 16);
    }

    public OpTypeCooperativeMatrixNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeCooperativeMatrixNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Rows
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Columns
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeCooperativeMatrixNV inst) => inst.ResultId;
    public OpTypeCooperativeMatrixNV(int resultId, int componentType, int execution, int rows, int columns)
    {
        ResultId = resultId;
        ComponentType = componentType;
        Execution = execution;
        Rows = rows;
        Columns = columns;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeCooperativeMatrixNV, ResultId, ComponentType, Execution, Rows, Columns];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "componentType":
                    ComponentType = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "rows":
                    Rows = o.ToLiteral<int>();
                    break;
                case "columns":
                    Columns = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeCooperativeMatrixNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCooperativeMatrixMulAddNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixMulAddNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixMulAddNV | (1 << 16);
    }

    public OpCooperativeMatrixMulAddNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCooperativeMatrixMulAddNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixMulAddNV inst) => inst.ResultId;
    public OpCooperativeMatrixMulAddNV(int resultType, int resultId, int a, int b, int c)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        B = b;
        C = c;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixMulAddNV, ResultType, ResultId, A, B, C];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "c":
                    C = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixMulAddNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCooperativeMatrixLengthNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLengthNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLengthNV | (1 << 16);
    }

    public OpCooperativeMatrixLengthNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCooperativeMatrixLengthNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixLengthNV inst) => inst.ResultId;
    public OpCooperativeMatrixLengthNV(int resultType, int resultId, int type)
    {
        ResultType = resultType;
        ResultId = resultId;
        Type = type;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLengthNV, ResultType, ResultId, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "type":
                    Type = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixLengthNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpBeginInvocationInterlockEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBeginInvocationInterlockEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBeginInvocationInterlockEXT | (1 << 16);
    }

    public OpBeginInvocationInterlockEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpBeginInvocationInterlockEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBeginInvocationInterlockEXT];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpBeginInvocationInterlockEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpEndInvocationInterlockEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndInvocationInterlockEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndInvocationInterlockEXT | (1 << 16);
    }

    public OpEndInvocationInterlockEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpEndInvocationInterlockEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEndInvocationInterlockEXT];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpEndInvocationInterlockEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCooperativeMatrixReduceNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixReduceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixReduceNV | (1 << 16);
    }

    public OpCooperativeMatrixReduceNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCooperativeMatrixReduceNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public CooperativeMatrixReduceMask Reduce
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CombineFunc
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixReduceNV inst) => inst.ResultId;
    public OpCooperativeMatrixReduceNV(int resultType, int resultId, int matrix, CooperativeMatrixReduceMask reduce, int combineFunc)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Reduce = reduce;
        CombineFunc = combineFunc;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixReduceNV, ResultType, ResultId, Matrix, (int)Reduce, CombineFunc];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                case "reduce":
                    Reduce = o.ToEnum<CooperativeMatrixReduceMask>();
                    break;
                case "combineFunc":
                    CombineFunc = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixReduceNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCooperativeMatrixPerElementOpNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixPerElementOpNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixPerElementOpNV | (1 << 16);
    }

    public OpCooperativeMatrixPerElementOpNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCooperativeMatrixPerElementOpNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Func
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixPerElementOpNV inst) => inst.ResultId;
    public OpCooperativeMatrixPerElementOpNV(int resultType, int resultId, int matrix, int func, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Func = func;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixPerElementOpNV, ResultType, ResultId, Matrix, Func, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                case "func":
                    Func = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpCooperativeMatrixPerElementOpNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpTypeTensorLayoutNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeTensorLayoutNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeTensorLayoutNV | (1 << 16);
    }

    public OpTypeTensorLayoutNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeTensorLayoutNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClampMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeTensorLayoutNV inst) => inst.ResultId;
    public OpTypeTensorLayoutNV(int resultId, int dim, int clampMode)
    {
        ResultId = resultId;
        Dim = dim;
        ClampMode = clampMode;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeTensorLayoutNV, ResultId, Dim, ClampMode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "dim":
                    Dim = o.ToLiteral<int>();
                    break;
                case "clampMode":
                    ClampMode = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeTensorLayoutNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeTensorViewNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeTensorViewNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeTensorViewNV | (1 << 16);
    }

    public OpTypeTensorViewNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeTensorViewNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HasDimensions
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeTensorViewNV inst) => inst.ResultId;
    public OpTypeTensorViewNV(int resultId, int dim, int hasDimensions, LiteralArray<int> values)
    {
        ResultId = resultId;
        Dim = dim;
        HasDimensions = hasDimensions;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeTensorViewNV, ResultId, Dim, HasDimensions, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "dim":
                    Dim = o.ToLiteral<int>();
                    break;
                case "hasDimensions":
                    HasDimensions = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTypeTensorViewNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpCreateTensorLayoutNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateTensorLayoutNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateTensorLayoutNV | (1 << 16);
    }

    public OpCreateTensorLayoutNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCreateTensorLayoutNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCreateTensorLayoutNV inst) => inst.ResultId;
    public OpCreateTensorLayoutNV(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateTensorLayoutNV, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCreateTensorLayoutNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTensorLayoutSetDimensionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetDimensionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetDimensionNV | (1 << 16);
    }

    public OpTensorLayoutSetDimensionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTensorLayoutSetDimensionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSetDimensionNV inst) => inst.ResultId;
    public OpTensorLayoutSetDimensionNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetDimensionNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTensorLayoutSetDimensionNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpTensorLayoutSetStrideNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetStrideNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetStrideNV | (1 << 16);
    }

    public OpTensorLayoutSetStrideNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTensorLayoutSetStrideNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSetStrideNV inst) => inst.ResultId;
    public OpTensorLayoutSetStrideNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetStrideNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTensorLayoutSetStrideNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpTensorLayoutSliceNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSliceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSliceNV | (1 << 16);
    }

    public OpTensorLayoutSliceNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTensorLayoutSliceNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSliceNV inst) => inst.ResultId;
    public OpTensorLayoutSliceNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSliceNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTensorLayoutSliceNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpTensorLayoutSetClampValueNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetClampValueNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetClampValueNV | (1 << 16);
    }

    public OpTensorLayoutSetClampValueNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTensorLayoutSetClampValueNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSetClampValueNV inst) => inst.ResultId;
    public OpTensorLayoutSetClampValueNV(int resultType, int resultId, int tensorLayout, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetClampValueNV, ResultType, ResultId, TensorLayout, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTensorLayoutSetClampValueNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCreateTensorViewNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateTensorViewNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateTensorViewNV | (1 << 16);
    }

    public OpCreateTensorViewNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCreateTensorViewNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCreateTensorViewNV inst) => inst.ResultId;
    public OpCreateTensorViewNV(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateTensorViewNV, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCreateTensorViewNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTensorViewSetDimensionNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetDimensionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetDimensionNV | (1 << 16);
    }

    public OpTensorViewSetDimensionNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTensorViewSetDimensionNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorViewSetDimensionNV inst) => inst.ResultId;
    public OpTensorViewSetDimensionNV(int resultType, int resultId, int tensorView, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetDimensionNV, ResultType, ResultId, TensorView, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorView":
                    TensorView = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTensorViewSetDimensionNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpTensorViewSetStrideNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetStrideNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetStrideNV | (1 << 16);
    }

    public OpTensorViewSetStrideNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTensorViewSetStrideNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorViewSetStrideNV inst) => inst.ResultId;
    public OpTensorViewSetStrideNV(int resultType, int resultId, int tensorView, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetStrideNV, ResultType, ResultId, TensorView, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorView":
                    TensorView = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTensorViewSetStrideNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpDemoteToHelperInvocation : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDemoteToHelperInvocation()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDemoteToHelperInvocation | (1 << 16);
    }

    public OpDemoteToHelperInvocation(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDemoteToHelperInvocation(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDemoteToHelperInvocation];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDemoteToHelperInvocation(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIsHelperInvocationEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsHelperInvocationEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsHelperInvocationEXT | (1 << 16);
    }

    public OpIsHelperInvocationEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIsHelperInvocationEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsHelperInvocationEXT inst) => inst.ResultId;
    public OpIsHelperInvocationEXT(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsHelperInvocationEXT, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIsHelperInvocationEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTensorViewSetClipNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetClipNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetClipNV | (1 << 16);
    }

    public OpTensorViewSetClipNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTensorViewSetClipNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipRowOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipRowSpan
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipColOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipColSpan
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorViewSetClipNV inst) => inst.ResultId;
    public OpTensorViewSetClipNV(int resultType, int resultId, int tensorView, int clipRowOffset, int clipRowSpan, int clipColOffset, int clipColSpan)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        ClipRowOffset = clipRowOffset;
        ClipRowSpan = clipRowSpan;
        ClipColOffset = clipColOffset;
        ClipColSpan = clipColSpan;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetClipNV, ResultType, ResultId, TensorView, ClipRowOffset, ClipRowSpan, ClipColOffset, ClipColSpan];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorView":
                    TensorView = o.ToLiteral<int>();
                    break;
                case "clipRowOffset":
                    ClipRowOffset = o.ToLiteral<int>();
                    break;
                case "clipRowSpan":
                    ClipRowSpan = o.ToLiteral<int>();
                    break;
                case "clipColOffset":
                    ClipColOffset = o.ToLiteral<int>();
                    break;
                case "clipColSpan":
                    ClipColSpan = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTensorViewSetClipNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTensorLayoutSetBlockSizeNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetBlockSizeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetBlockSizeNV | (1 << 16);
    }

    public OpTensorLayoutSetBlockSizeNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTensorLayoutSetBlockSizeNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSetBlockSizeNV inst) => inst.ResultId;
    public OpTensorLayoutSetBlockSizeNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetBlockSizeNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTensorLayoutSetBlockSizeNV(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpCooperativeMatrixTransposeNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixTransposeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixTransposeNV | (1 << 16);
    }

    public OpCooperativeMatrixTransposeNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCooperativeMatrixTransposeNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixTransposeNV inst) => inst.ResultId;
    public OpCooperativeMatrixTransposeNV(int resultType, int resultId, int matrix)
    {
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixTransposeNV, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixTransposeNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertUToImageNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToImageNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToImageNV | (1 << 16);
    }

    public OpConvertUToImageNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertUToImageNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToImageNV inst) => inst.ResultId;
    public OpConvertUToImageNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToImageNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToImageNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertUToSamplerNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToSamplerNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToSamplerNV | (1 << 16);
    }

    public OpConvertUToSamplerNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertUToSamplerNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToSamplerNV inst) => inst.ResultId;
    public OpConvertUToSamplerNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToSamplerNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToSamplerNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertImageToUNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertImageToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertImageToUNV | (1 << 16);
    }

    public OpConvertImageToUNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertImageToUNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertImageToUNV inst) => inst.ResultId;
    public OpConvertImageToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertImageToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertImageToUNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertSamplerToUNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSamplerToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSamplerToUNV | (1 << 16);
    }

    public OpConvertSamplerToUNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertSamplerToUNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertSamplerToUNV inst) => inst.ResultId;
    public OpConvertSamplerToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSamplerToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertSamplerToUNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertUToSampledImageNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToSampledImageNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToSampledImageNV | (1 << 16);
    }

    public OpConvertUToSampledImageNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertUToSampledImageNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToSampledImageNV inst) => inst.ResultId;
    public OpConvertUToSampledImageNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToSampledImageNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToSampledImageNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertSampledImageToUNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSampledImageToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSampledImageToUNV | (1 << 16);
    }

    public OpConvertSampledImageToUNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertSampledImageToUNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertSampledImageToUNV inst) => inst.ResultId;
    public OpConvertSampledImageToUNV(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSampledImageToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertSampledImageToUNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSamplerImageAddressingModeNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSamplerImageAddressingModeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSamplerImageAddressingModeNV | (1 << 16);
    }

    public OpSamplerImageAddressingModeNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSamplerImageAddressingModeNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int BitWidth
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSamplerImageAddressingModeNV(int bitWidth)
    {
        BitWidth = bitWidth;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSamplerImageAddressingModeNV, ..BitWidth.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "bitWidth":
                    BitWidth = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSamplerImageAddressingModeNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRawAccessChainNV : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRawAccessChainNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRawAccessChainNV | (1 << 16);
    }

    public OpRawAccessChainNV(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRawAccessChainNV(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Bytestride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Elementindex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Byteoffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public RawAccessChainOperandsMask? Rawaccesschainoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRawAccessChainNV inst) => inst.ResultId;
    public OpRawAccessChainNV(int resultType, int resultId, int baseId, int bytestride, int elementindex, int byteoffset, RawAccessChainOperandsMask? rawaccesschainoperands)
    {
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Bytestride = bytestride;
        Elementindex = elementindex;
        Byteoffset = byteoffset;
        Rawaccesschainoperands = rawaccesschainoperands;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRawAccessChainNV, ResultType, ResultId, BaseId, Bytestride, Elementindex, Byteoffset, ..(Rawaccesschainoperands is null ? (Span<int>)[] : [(int)Rawaccesschainoperands.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "bytestride":
                    Bytestride = o.ToLiteral<int>();
                    break;
                case "elementindex":
                    Elementindex = o.ToLiteral<int>();
                    break;
                case "byteoffset":
                    Byteoffset = o.ToLiteral<int>();
                    break;
                case "rawaccesschainoperands":
                    if (o.Words.Length > 0)
                    {
                        Rawaccesschainoperands = o.ToEnum<RawAccessChainOperandsMask>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRawAccessChainNV(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupShuffleINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleINTEL | (1 << 16);
    }

    public OpSubgroupShuffleINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupShuffleINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InvocationId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupShuffleINTEL inst) => inst.ResultId;
    public OpSubgroupShuffleINTEL(int resultType, int resultId, int data, int invocationId)
    {
        ResultType = resultType;
        ResultId = resultId;
        Data = data;
        InvocationId = invocationId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleINTEL, ResultType, ResultId, Data, InvocationId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
                case "invocationId":
                    InvocationId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupShuffleINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupShuffleDownINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleDownINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleDownINTEL | (1 << 16);
    }

    public OpSubgroupShuffleDownINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupShuffleDownINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Current
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Next
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupShuffleDownINTEL inst) => inst.ResultId;
    public OpSubgroupShuffleDownINTEL(int resultType, int resultId, int current, int next, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Current = current;
        Next = next;
        Delta = delta;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleDownINTEL, ResultType, ResultId, Current, Next, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "current":
                    Current = o.ToLiteral<int>();
                    break;
                case "next":
                    Next = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupShuffleDownINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupShuffleUpINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleUpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleUpINTEL | (1 << 16);
    }

    public OpSubgroupShuffleUpINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupShuffleUpINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Previous
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Current
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupShuffleUpINTEL inst) => inst.ResultId;
    public OpSubgroupShuffleUpINTEL(int resultType, int resultId, int previous, int current, int delta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Previous = previous;
        Current = current;
        Delta = delta;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleUpINTEL, ResultType, ResultId, Previous, Current, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "previous":
                    Previous = o.ToLiteral<int>();
                    break;
                case "current":
                    Current = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupShuffleUpINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupShuffleXorINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleXorINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleXorINTEL | (1 << 16);
    }

    public OpSubgroupShuffleXorINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupShuffleXorINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupShuffleXorINTEL inst) => inst.ResultId;
    public OpSubgroupShuffleXorINTEL(int resultType, int resultId, int data, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Data = data;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleXorINTEL, ResultType, ResultId, Data, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupShuffleXorINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupBlockReadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockReadINTEL | (1 << 16);
    }

    public OpSubgroupBlockReadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupBlockReadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupBlockReadINTEL inst) => inst.ResultId;
    public OpSubgroupBlockReadINTEL(int resultType, int resultId, int ptr)
    {
        ResultType = resultType;
        ResultId = resultId;
        Ptr = ptr;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockReadINTEL, ResultType, ResultId, Ptr];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "ptr":
                    Ptr = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupBlockWriteINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockWriteINTEL | (1 << 16);
    }

    public OpSubgroupBlockWriteINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupBlockWriteINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockWriteINTEL(int ptr, int data)
    {
        Ptr = ptr;
        Data = data;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockWriteINTEL, Ptr, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "ptr":
                    Ptr = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupImageBlockReadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageBlockReadINTEL | (1 << 16);
    }

    public OpSubgroupImageBlockReadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupImageBlockReadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupImageBlockReadINTEL inst) => inst.ResultId;
    public OpSubgroupImageBlockReadINTEL(int resultType, int resultId, int image, int coordinate)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageBlockReadINTEL, ResultType, ResultId, Image, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupImageBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupImageBlockWriteINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageBlockWriteINTEL | (1 << 16);
    }

    public OpSubgroupImageBlockWriteINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupImageBlockWriteINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageBlockWriteINTEL(int image, int coordinate, int data)
    {
        Image = image;
        Coordinate = coordinate;
        Data = data;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageBlockWriteINTEL, Image, Coordinate, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupImageBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupImageMediaBlockReadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageMediaBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageMediaBlockReadINTEL | (1 << 16);
    }

    public OpSubgroupImageMediaBlockReadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupImageMediaBlockReadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Height
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupImageMediaBlockReadINTEL inst) => inst.ResultId;
    public OpSubgroupImageMediaBlockReadINTEL(int resultType, int resultId, int image, int coordinate, int width, int height)
    {
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Width = width;
        Height = height;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageMediaBlockReadINTEL, ResultType, ResultId, Image, Coordinate, Width, Height];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "width":
                    Width = o.ToLiteral<int>();
                    break;
                case "height":
                    Height = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupImageMediaBlockReadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupImageMediaBlockWriteINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageMediaBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageMediaBlockWriteINTEL | (1 << 16);
    }

    public OpSubgroupImageMediaBlockWriteINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupImageMediaBlockWriteINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Height
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageMediaBlockWriteINTEL(int image, int coordinate, int width, int height, int data)
    {
        Image = image;
        Coordinate = coordinate;
        Width = width;
        Height = height;
        Data = data;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageMediaBlockWriteINTEL, Image, Coordinate, Width, Height, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "width":
                    Width = o.ToLiteral<int>();
                    break;
                case "height":
                    Height = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupImageMediaBlockWriteINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUCountLeadingZerosINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUCountLeadingZerosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUCountLeadingZerosINTEL | (1 << 16);
    }

    public OpUCountLeadingZerosINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUCountLeadingZerosINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUCountLeadingZerosINTEL inst) => inst.ResultId;
    public OpUCountLeadingZerosINTEL(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUCountLeadingZerosINTEL, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUCountLeadingZerosINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUCountTrailingZerosINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUCountTrailingZerosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUCountTrailingZerosINTEL | (1 << 16);
    }

    public OpUCountTrailingZerosINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUCountTrailingZerosINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUCountTrailingZerosINTEL inst) => inst.ResultId;
    public OpUCountTrailingZerosINTEL(int resultType, int resultId, int operand)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUCountTrailingZerosINTEL, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUCountTrailingZerosINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAbsISubINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAbsISubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAbsISubINTEL | (1 << 16);
    }

    public OpAbsISubINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAbsISubINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAbsISubINTEL inst) => inst.ResultId;
    public OpAbsISubINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAbsISubINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAbsISubINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAbsUSubINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAbsUSubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAbsUSubINTEL | (1 << 16);
    }

    public OpAbsUSubINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAbsUSubINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAbsUSubINTEL inst) => inst.ResultId;
    public OpAbsUSubINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAbsUSubINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAbsUSubINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIAddSatINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAddSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAddSatINTEL | (1 << 16);
    }

    public OpIAddSatINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIAddSatINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAddSatINTEL inst) => inst.ResultId;
    public OpIAddSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAddSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIAddSatINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUAddSatINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAddSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAddSatINTEL | (1 << 16);
    }

    public OpUAddSatINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUAddSatINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUAddSatINTEL inst) => inst.ResultId;
    public OpUAddSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAddSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUAddSatINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIAverageINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAverageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAverageINTEL | (1 << 16);
    }

    public OpIAverageINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIAverageINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAverageINTEL inst) => inst.ResultId;
    public OpIAverageINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAverageINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIAverageINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUAverageINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAverageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAverageINTEL | (1 << 16);
    }

    public OpUAverageINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUAverageINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUAverageINTEL inst) => inst.ResultId;
    public OpUAverageINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAverageINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUAverageINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIAverageRoundedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAverageRoundedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAverageRoundedINTEL | (1 << 16);
    }

    public OpIAverageRoundedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIAverageRoundedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAverageRoundedINTEL inst) => inst.ResultId;
    public OpIAverageRoundedINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAverageRoundedINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIAverageRoundedINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUAverageRoundedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAverageRoundedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAverageRoundedINTEL | (1 << 16);
    }

    public OpUAverageRoundedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUAverageRoundedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUAverageRoundedINTEL inst) => inst.ResultId;
    public OpUAverageRoundedINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAverageRoundedINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUAverageRoundedINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpISubSatINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISubSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISubSatINTEL | (1 << 16);
    }

    public OpISubSatINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpISubSatINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpISubSatINTEL inst) => inst.ResultId;
    public OpISubSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISubSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpISubSatINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUSubSatINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUSubSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUSubSatINTEL | (1 << 16);
    }

    public OpUSubSatINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUSubSatINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUSubSatINTEL inst) => inst.ResultId;
    public OpUSubSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUSubSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUSubSatINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpIMul32x16INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIMul32x16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIMul32x16INTEL | (1 << 16);
    }

    public OpIMul32x16INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpIMul32x16INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIMul32x16INTEL inst) => inst.ResultId;
    public OpIMul32x16INTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIMul32x16INTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpIMul32x16INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpUMul32x16INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMul32x16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMul32x16INTEL | (1 << 16);
    }

    public OpUMul32x16INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpUMul32x16INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUMul32x16INTEL inst) => inst.ResultId;
    public OpUMul32x16INTEL(int resultType, int resultId, int operand1, int operand2)
    {
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMul32x16INTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpUMul32x16INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConstantFunctionPointerINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantFunctionPointerINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantFunctionPointerINTEL | (1 << 16);
    }

    public OpConstantFunctionPointerINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantFunctionPointerINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Function
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantFunctionPointerINTEL inst) => inst.ResultId;
    public OpConstantFunctionPointerINTEL(int resultType, int resultId, int function)
    {
        ResultType = resultType;
        ResultId = resultId;
        Function = function;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantFunctionPointerINTEL, ResultType, ResultId, Function];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "function":
                    Function = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConstantFunctionPointerINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFunctionPointerCallINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionPointerCallINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionPointerCallINTEL | (1 << 16);
    }

    public OpFunctionPointerCallINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFunctionPointerCallINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFunctionPointerCallINTEL inst) => inst.ResultId;
    public OpFunctionPointerCallINTEL(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionPointerCallINTEL, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpFunctionPointerCallINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpAsmTargetINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmTargetINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmTargetINTEL | (1 << 16);
    }

    public OpAsmTargetINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAsmTargetINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Asmtarget
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAsmTargetINTEL inst) => inst.ResultId;
    public OpAsmTargetINTEL(int resultType, int resultId, string asmtarget)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asmtarget = asmtarget;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmTargetINTEL, ResultType, ResultId, ..Asmtarget.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "asmtarget":
                    Asmtarget = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAsmTargetINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAsmINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmINTEL | (1 << 16);
    }

    public OpAsmINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAsmINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Asmtype
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Asminstructions
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Constraints
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAsmINTEL inst) => inst.ResultId;
    public OpAsmINTEL(int resultType, int resultId, int asmtype, int target, string asminstructions, string constraints)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asmtype = asmtype;
        Target = target;
        Asminstructions = asminstructions;
        Constraints = constraints;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmINTEL, ResultType, ResultId, Asmtype, Target, ..Asminstructions.AsDisposableLiteralValue().Words, ..Constraints.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "asmtype":
                    Asmtype = o.ToLiteral<int>();
                    break;
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "asminstructions":
                    Asminstructions = o.ToLiteral<string>();
                    break;
                case "constraints":
                    Constraints = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAsmINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAsmCallINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmCallINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmCallINTEL | (1 << 16);
    }

    public OpAsmCallINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAsmCallINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Asm
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAsmCallINTEL inst) => inst.ResultId;
    public OpAsmCallINTEL(int resultType, int resultId, int asm, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Asm = asm;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmCallINTEL, ResultType, ResultId, Asm, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "asm":
                    Asm = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpAsmCallINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpAtomicFMinEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFMinEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFMinEXT | (1 << 16);
    }

    public OpAtomicFMinEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicFMinEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicFMinEXT inst) => inst.ResultId;
    public OpAtomicFMinEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFMinEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFMinEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicFMaxEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFMaxEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFMaxEXT | (1 << 16);
    }

    public OpAtomicFMaxEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicFMaxEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicFMaxEXT inst) => inst.ResultId;
    public OpAtomicFMaxEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFMaxEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFMaxEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAssumeTrueKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAssumeTrueKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAssumeTrueKHR | (1 << 16);
    }

    public OpAssumeTrueKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAssumeTrueKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAssumeTrueKHR(int condition)
    {
        Condition = condition;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAssumeTrueKHR, Condition];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "condition":
                    Condition = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAssumeTrueKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpExpectKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExpectKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExpectKHR | (1 << 16);
    }

    public OpExpectKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpExpectKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ExpectedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpExpectKHR inst) => inst.ResultId;
    public OpExpectKHR(int resultType, int resultId, int value, int expectedValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        ExpectedValue = expectedValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExpectKHR, ResultType, ResultId, Value, ExpectedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "expectedValue":
                    ExpectedValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpExpectKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpDecorateString : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorateString()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorateString | (1 << 16);
    }

    public OpDecorateString(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpDecorateString(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorateString(int target, Decoration decoration, string value)
    {
        Target = target;
        Decoration = decoration;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorateString, Target, (int)Decoration, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    break;
                case "value":
                    Value = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpDecorateString(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMemberDecorateString : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberDecorateString()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberDecorateString | (1 << 16);
    }

    public OpMemberDecorateString(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMemberDecorateString(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int StructType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberDecorateString(int structType, int member, Decoration decoration, string value)
    {
        StructType = structType;
        Member = member;
        Decoration = decoration;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberDecorateString, StructType, ..Member.AsDisposableLiteralValue().Words, (int)Decoration, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "structType":
                    StructType = o.ToLiteral<int>();
                    break;
                case "member":
                    Member = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    break;
                case "value":
                    Value = o.ToLiteral<string>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMemberDecorateString(OpDataIndex odi) => new(odi);
}

public ref partial struct OpVmeImageINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVmeImageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVmeImageINTEL | (1 << 16);
    }

    public OpVmeImageINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVmeImageINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampler
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVmeImageINTEL inst) => inst.ResultId;
    public OpVmeImageINTEL(int resultType, int resultId, int imageType, int sampler)
    {
        ResultType = resultType;
        ResultId = resultId;
        ImageType = imageType;
        Sampler = sampler;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVmeImageINTEL, ResultType, ResultId, ImageType, Sampler];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "imageType":
                    ImageType = o.ToLiteral<int>();
                    break;
                case "sampler":
                    Sampler = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpVmeImageINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeVmeImageINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVmeImageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVmeImageINTEL | (1 << 16);
    }

    public OpTypeVmeImageINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeVmeImageINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeVmeImageINTEL inst) => inst.ResultId;
    public OpTypeVmeImageINTEL(int resultId, int imageType)
    {
        ResultId = resultId;
        ImageType = imageType;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVmeImageINTEL, ResultId, ImageType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "imageType":
                    ImageType = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeVmeImageINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcImePayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImePayloadINTEL | (1 << 16);
    }

    public OpTypeAvcImePayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcImePayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImePayloadINTEL inst) => inst.ResultId;
    public OpTypeAvcImePayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImePayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImePayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcRefPayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcRefPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcRefPayloadINTEL | (1 << 16);
    }

    public OpTypeAvcRefPayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcRefPayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcRefPayloadINTEL inst) => inst.ResultId;
    public OpTypeAvcRefPayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcRefPayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcRefPayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcSicPayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcSicPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcSicPayloadINTEL | (1 << 16);
    }

    public OpTypeAvcSicPayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcSicPayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcSicPayloadINTEL inst) => inst.ResultId;
    public OpTypeAvcSicPayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcSicPayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcSicPayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcMcePayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcMcePayloadINTEL | (1 << 16);
    }

    public OpTypeAvcMcePayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcMcePayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcMcePayloadINTEL inst) => inst.ResultId;
    public OpTypeAvcMcePayloadINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcMcePayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcMceResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcMceResultINTEL | (1 << 16);
    }

    public OpTypeAvcMceResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcMceResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcMceResultINTEL inst) => inst.ResultId;
    public OpTypeAvcMceResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcMceResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcMceResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcImeResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultINTEL | (1 << 16);
    }

    public OpTypeAvcImeResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcImeResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeResultINTEL inst) => inst.ResultId;
    public OpTypeAvcImeResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcImeResultSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeResultSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultSingleReferenceStreamoutINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcImeResultDualReferenceStreamoutINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultDualReferenceStreamoutINTEL | (1 << 16);
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeResultDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultDualReferenceStreamoutINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcImeSingleReferenceStreaminINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeSingleReferenceStreaminINTEL | (1 << 16);
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public OpTypeAvcImeSingleReferenceStreaminINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeSingleReferenceStreaminINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcImeDualReferenceStreaminINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeDualReferenceStreaminINTEL | (1 << 16);
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeDualReferenceStreaminINTEL inst) => inst.ResultId;
    public OpTypeAvcImeDualReferenceStreaminINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeDualReferenceStreaminINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcRefResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcRefResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcRefResultINTEL | (1 << 16);
    }

    public OpTypeAvcRefResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcRefResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcRefResultINTEL inst) => inst.ResultId;
    public OpTypeAvcRefResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcRefResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcRefResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeAvcSicResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcSicResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcSicResultINTEL | (1 << 16);
    }

    public OpTypeAvcSicResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeAvcSicResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcSicResultINTEL inst) => inst.ResultId;
    public OpTypeAvcSicResultINTEL(int resultId)
    {
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcSicResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcSicResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceBasePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(int resultType, int resultId, int referenceBasePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReferenceBasePenalty = referenceBasePenalty;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL, ResultType, ResultId, ReferenceBasePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "referenceBasePenalty":
                    ReferenceBasePenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceSetInterShapePenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterShapePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedShapePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetInterShapePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(int resultType, int resultId, int packedShapePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedShapePenalty = packedShapePenalty;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterShapePenaltyINTEL, ResultType, ResultId, PackedShapePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedShapePenalty":
                    PackedShapePenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceSetInterDirectionPenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DirectionCost
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetInterDirectionPenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(int resultType, int resultId, int directionCost, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        DirectionCost = directionCost;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL, ResultType, ResultId, DirectionCost, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "directionCost":
                    DirectionCost = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedCostCenterDelta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedCostTable
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CostPrecision
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(int resultType, int resultId, int packedCostCenterDelta, int packedCostTable, int costPrecision, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedCostCenterDelta = packedCostCenterDelta;
        PackedCostTable = packedCostTable;
        CostPrecision = costPrecision;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL, ResultType, ResultId, PackedCostCenterDelta, PackedCostTable, CostPrecision, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedCostCenterDelta":
                    PackedCostCenterDelta = o.ToLiteral<int>();
                    break;
                case "packedCostTable":
                    PackedCostTable = o.ToLiteral<int>();
                    break;
                case "costPrecision":
                    CostPrecision = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceSetAcOnlyHaarINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetAcOnlyHaarINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetAcOnlyHaarINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetAcOnlyHaarINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SourceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(int resultType, int resultId, int sourceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SourceFieldPolarity = sourceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL, ResultType, ResultId, SourceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sourceFieldPolarity":
                    SourceFieldPolarity = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(int resultType, int resultId, int referenceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ReferenceFieldPolarity = referenceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL, ResultType, ResultId, ReferenceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "referenceFieldPolarity":
                    ReferenceFieldPolarity = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ForwardReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BackwardReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(int resultType, int resultId, int forwardReferenceFieldPolarity, int backwardReferenceFieldPolarity, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ForwardReferenceFieldPolarity = forwardReferenceFieldPolarity;
        BackwardReferenceFieldPolarity = backwardReferenceFieldPolarity;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL, ResultType, ResultId, ForwardReferenceFieldPolarity, BackwardReferenceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "forwardReferenceFieldPolarity":
                    ForwardReferenceFieldPolarity = o.ToLiteral<int>();
                    break;
                case "backwardReferenceFieldPolarity":
                    BackwardReferenceFieldPolarity = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceConvertToImePayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToImePayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToImePayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToImePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToImePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToImePayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceConvertToImeResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToImeResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToImeResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToImeResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToImeResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToImeResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceConvertToRefPayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToRefPayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToRefPayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToRefPayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToRefPayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToRefPayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceConvertToRefResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToRefResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToRefResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToRefResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToRefResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToRefResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceConvertToSicPayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToSicPayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToSicPayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToSicPayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToSicPayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToSicPayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceConvertToSicResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToSicResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToSicResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToSicResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToSicResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToSicResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetMotionVectorsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetMotionVectorsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetMotionVectorsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetMotionVectorsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetMotionVectorsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetInterDistortionsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterDistortionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterDistortionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterDistortionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterDistortionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetBestInterDistortionsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetBestInterDistortionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetBestInterDistortionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetBestInterDistortionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetInterMajorShapeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMajorShapeINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterMajorShapeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterMajorShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMajorShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMajorShapeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetInterMinorShapeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMinorShapeINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterMinorShapeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterMinorShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMinorShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMinorShapeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetInterDirectionsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterDirectionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterDirectionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterDirectionsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterDirectionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterDirectionsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetInterMotionVectorCountINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMotionVectorCountINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterMotionVectorCountINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMotionVectorCountINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetInterReferenceIdsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterReferenceIdsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterReferenceIdsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterReferenceIdsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceParameterFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(int resultType, int resultId, int packedReferenceIds, int packedReferenceParameterFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceParameterFieldPolarities = packedReferenceParameterFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL, ResultType, ResultId, PackedReferenceIds, PackedReferenceParameterFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "packedReferenceParameterFieldPolarities":
                    PackedReferenceParameterFieldPolarities = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeInitializeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeInitializeINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeInitializeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeInitializeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SADAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeInitializeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeInitializeINTEL(int resultType, int resultId, int srcCoord, int partitionMask, int sADAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        PartitionMask = partitionMask;
        SADAdjustment = sADAdjustment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeInitializeINTEL, ResultType, ResultId, SrcCoord, PartitionMask, SADAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                case "partitionMask":
                    PartitionMask = o.ToLiteral<int>();
                    break;
                case "sADAdjustment":
                    SADAdjustment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeSetSingleReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetSingleReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetSingleReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetSingleReferenceINTEL(int resultType, int resultId, int refOffset, int searchWindowConfig, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        RefOffset = refOffset;
        SearchWindowConfig = searchWindowConfig;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetSingleReferenceINTEL, ResultType, ResultId, RefOffset, SearchWindowConfig, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "refOffset":
                    RefOffset = o.ToLiteral<int>();
                    break;
                case "searchWindowConfig":
                    SearchWindowConfig = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeSetDualReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetDualReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IdSearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetDualReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetDualReferenceINTEL(int resultType, int resultId, int fwdRefOffset, int bwdRefOffset, int idSearchWindowConfig, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        FwdRefOffset = fwdRefOffset;
        BwdRefOffset = bwdRefOffset;
        IdSearchWindowConfig = idSearchWindowConfig;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetDualReferenceINTEL, ResultType, ResultId, FwdRefOffset, BwdRefOffset, IdSearchWindowConfig, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "fwdRefOffset":
                    FwdRefOffset = o.ToLiteral<int>();
                    break;
                case "bwdRefOffset":
                    BwdRefOffset = o.ToLiteral<int>();
                    break;
                case "idSearchWindowConfig":
                    IdSearchWindowConfig = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeRefWindowSizeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeRefWindowSizeINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DualRef
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeRefWindowSizeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeRefWindowSizeINTEL(int resultType, int resultId, int searchWindowConfig, int dualRef)
    {
        ResultType = resultType;
        ResultId = resultId;
        SearchWindowConfig = searchWindowConfig;
        DualRef = dualRef;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeRefWindowSizeINTEL, ResultType, ResultId, SearchWindowConfig, DualRef];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "searchWindowConfig":
                    SearchWindowConfig = o.ToLiteral<int>();
                    break;
                case "dualRef":
                    DualRef = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeRefWindowSizeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeAdjustRefOffsetINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeAdjustRefOffsetINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefWindowSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeAdjustRefOffsetINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeAdjustRefOffsetINTEL(int resultType, int resultId, int refOffset, int srcCoord, int refWindowSize, int imageSize)
    {
        ResultType = resultType;
        ResultId = resultId;
        RefOffset = refOffset;
        SrcCoord = srcCoord;
        RefWindowSize = refWindowSize;
        ImageSize = imageSize;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeAdjustRefOffsetINTEL, ResultType, ResultId, RefOffset, SrcCoord, RefWindowSize, ImageSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "refOffset":
                    RefOffset = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                case "refWindowSize":
                    RefWindowSize = o.ToLiteral<int>();
                    break;
                case "imageSize":
                    ImageSize = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeAdjustRefOffsetINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeConvertToMcePayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeConvertToMcePayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeConvertToMcePayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeSetMaxMotionVectorCountINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxMotionVectorCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetMaxMotionVectorCountINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(int resultType, int resultId, int maxMotionVectorCount, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        MaxMotionVectorCount = maxMotionVectorCount;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL, ResultType, ResultId, MaxMotionVectorCount, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "maxMotionVectorCount":
                    MaxMotionVectorCount = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Threshold
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(int resultType, int resultId, int threshold, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Threshold = threshold;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL, ResultType, ResultId, Threshold, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "threshold":
                    Threshold = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeSetWeightedSadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetWeightedSadINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedSadWeights
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetWeightedSadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetWeightedSadINTEL(int resultType, int resultId, int packedSadWeights, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedSadWeights = packedSadWeights;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetWeightedSadINTEL, ResultType, ResultId, PackedSadWeights, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedSadWeights":
                    PackedSadWeights = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetWeightedSadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(int resultType, int resultId, int srcImage, int refImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL, ResultType, ResultId, SrcImage, RefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "streaminComponents":
                    StreaminComponents = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "streaminComponents":
                    StreaminComponents = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(int resultType, int resultId, int srcImage, int refImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL, ResultType, ResultId, SrcImage, RefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "streaminComponents":
                    StreaminComponents = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload, int streaminComponents)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "streaminComponents":
                    StreaminComponents = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeConvertToMceResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeConvertToMceResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeConvertToMceResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetSingleReferenceStreaminINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetDualReferenceStreaminINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetDualReferenceStreaminINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetDualReferenceStreaminINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetDualReferenceStreaminINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeStripDualReferenceStreamoutINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeStripDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetBorderReachedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetBorderReachedINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageSelect
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetBorderReachedINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetBorderReachedINTEL(int resultType, int resultId, int imageSelect, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ImageSelect = imageSelect;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetBorderReachedINTEL, ResultType, ResultId, ImageSelect, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "imageSelect":
                    ImageSelect = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetBorderReachedINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcFmeInitializeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcFmeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcFmeInitializeINTEL | (1 << 16);
    }

    public OpSubgroupAvcFmeInitializeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcFmeInitializeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PixelResolution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcFmeInitializeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcFmeInitializeINTEL(int resultType, int resultId, int srcCoord, int motionVectors, int majorShapes, int minorShapes, int direction, int pixelResolution, int sadAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        MotionVectors = motionVectors;
        MajorShapes = majorShapes;
        MinorShapes = minorShapes;
        Direction = direction;
        PixelResolution = pixelResolution;
        SadAdjustment = sadAdjustment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcFmeInitializeINTEL, ResultType, ResultId, SrcCoord, MotionVectors, MajorShapes, MinorShapes, Direction, PixelResolution, SadAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                case "motionVectors":
                    MotionVectors = o.ToLiteral<int>();
                    break;
                case "majorShapes":
                    MajorShapes = o.ToLiteral<int>();
                    break;
                case "minorShapes":
                    MinorShapes = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "pixelResolution":
                    PixelResolution = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcFmeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcBmeInitializeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcBmeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcBmeInitializeINTEL | (1 << 16);
    }

    public OpSubgroupAvcBmeInitializeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcBmeInitializeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PixelResolution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BidirectionalWeight
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcBmeInitializeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcBmeInitializeINTEL(int resultType, int resultId, int srcCoord, int motionVectors, int majorShapes, int minorShapes, int direction, int pixelResolution, int bidirectionalWeight, int sadAdjustment)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        MotionVectors = motionVectors;
        MajorShapes = majorShapes;
        MinorShapes = minorShapes;
        Direction = direction;
        PixelResolution = pixelResolution;
        BidirectionalWeight = bidirectionalWeight;
        SadAdjustment = sadAdjustment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcBmeInitializeINTEL, ResultType, ResultId, SrcCoord, MotionVectors, MajorShapes, MinorShapes, Direction, PixelResolution, BidirectionalWeight, SadAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                case "motionVectors":
                    MotionVectors = o.ToLiteral<int>();
                    break;
                case "majorShapes":
                    MajorShapes = o.ToLiteral<int>();
                    break;
                case "minorShapes":
                    MinorShapes = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "pixelResolution":
                    PixelResolution = o.ToLiteral<int>();
                    break;
                case "bidirectionalWeight":
                    BidirectionalWeight = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcBmeInitializeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcRefConvertToMcePayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefConvertToMcePayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefConvertToMcePayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcRefSetBidirectionalMixDisableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefSetBidirectionalMixDisableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcRefSetBilinearFilterEnableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefSetBilinearFilterEnableINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefSetBilinearFilterEnableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefSetBilinearFilterEnableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcRefEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int packedReferenceFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceFieldPolarities = packedReferenceFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, PackedReferenceFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "packedReferenceFieldPolarities":
                    PackedReferenceFieldPolarities = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcRefConvertToMceResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefConvertToMceResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefConvertToMceResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicInitializeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicInitializeINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicInitializeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicInitializeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicInitializeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicInitializeINTEL(int resultType, int resultId, int srcCoord)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicInitializeINTEL, ResultType, ResultId, SrcCoord];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicInitializeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicConfigureSkcINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureSkcINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureSkcINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConfigureSkcINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicConfigureSkcINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipBlockPartitionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipMotionVectorMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BidirectionalWeight
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConfigureSkcINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConfigureSkcINTEL(int resultType, int resultId, int skipBlockPartitionType, int skipMotionVectorMask, int motionVectors, int bidirectionalWeight, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SkipBlockPartitionType = skipBlockPartitionType;
        SkipMotionVectorMask = skipMotionVectorMask;
        MotionVectors = motionVectors;
        BidirectionalWeight = bidirectionalWeight;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureSkcINTEL, ResultType, ResultId, SkipBlockPartitionType, SkipMotionVectorMask, MotionVectors, BidirectionalWeight, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "skipBlockPartitionType":
                    SkipBlockPartitionType = o.ToLiteral<int>();
                    break;
                case "skipMotionVectorMask":
                    SkipMotionVectorMask = o.ToLiteral<int>();
                    break;
                case "motionVectors":
                    MotionVectors = o.ToLiteral<int>();
                    break;
                case "bidirectionalWeight":
                    BidirectionalWeight = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureSkcINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicConfigureIpeLumaINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureIpeLumaINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaIntraPartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntraNeighbourAvailabilty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerLumaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperRightEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConfigureIpeLumaINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConfigureIpeLumaINTEL(int resultType, int resultId, int lumaIntraPartitionMask, int intraNeighbourAvailabilty, int leftEdgeLumaPixels, int upperLeftCornerLumaPixel, int upperEdgeLumaPixels, int upperRightEdgeLumaPixels, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaIntraPartitionMask = lumaIntraPartitionMask;
        IntraNeighbourAvailabilty = intraNeighbourAvailabilty;
        LeftEdgeLumaPixels = leftEdgeLumaPixels;
        UpperLeftCornerLumaPixel = upperLeftCornerLumaPixel;
        UpperEdgeLumaPixels = upperEdgeLumaPixels;
        UpperRightEdgeLumaPixels = upperRightEdgeLumaPixels;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureIpeLumaINTEL, ResultType, ResultId, LumaIntraPartitionMask, IntraNeighbourAvailabilty, LeftEdgeLumaPixels, UpperLeftCornerLumaPixel, UpperEdgeLumaPixels, UpperRightEdgeLumaPixels, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "lumaIntraPartitionMask":
                    LumaIntraPartitionMask = o.ToLiteral<int>();
                    break;
                case "intraNeighbourAvailabilty":
                    IntraNeighbourAvailabilty = o.ToLiteral<int>();
                    break;
                case "leftEdgeLumaPixels":
                    LeftEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "upperLeftCornerLumaPixel":
                    UpperLeftCornerLumaPixel = o.ToLiteral<int>();
                    break;
                case "upperEdgeLumaPixels":
                    UpperEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "upperRightEdgeLumaPixels":
                    UpperRightEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicConfigureIpeLumaChromaINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaIntraPartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntraNeighbourAvailabilty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerLumaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperRightEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeChromaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerChromaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeChromaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConfigureIpeLumaChromaINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(int resultType, int resultId, int lumaIntraPartitionMask, int intraNeighbourAvailabilty, int leftEdgeLumaPixels, int upperLeftCornerLumaPixel, int upperEdgeLumaPixels, int upperRightEdgeLumaPixels, int leftEdgeChromaPixels, int upperLeftCornerChromaPixel, int upperEdgeChromaPixels, int sadAdjustment, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaIntraPartitionMask = lumaIntraPartitionMask;
        IntraNeighbourAvailabilty = intraNeighbourAvailabilty;
        LeftEdgeLumaPixels = leftEdgeLumaPixels;
        UpperLeftCornerLumaPixel = upperLeftCornerLumaPixel;
        UpperEdgeLumaPixels = upperEdgeLumaPixels;
        UpperRightEdgeLumaPixels = upperRightEdgeLumaPixels;
        LeftEdgeChromaPixels = leftEdgeChromaPixels;
        UpperLeftCornerChromaPixel = upperLeftCornerChromaPixel;
        UpperEdgeChromaPixels = upperEdgeChromaPixels;
        SadAdjustment = sadAdjustment;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL, ResultType, ResultId, LumaIntraPartitionMask, IntraNeighbourAvailabilty, LeftEdgeLumaPixels, UpperLeftCornerLumaPixel, UpperEdgeLumaPixels, UpperRightEdgeLumaPixels, LeftEdgeChromaPixels, UpperLeftCornerChromaPixel, UpperEdgeChromaPixels, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "lumaIntraPartitionMask":
                    LumaIntraPartitionMask = o.ToLiteral<int>();
                    break;
                case "intraNeighbourAvailabilty":
                    IntraNeighbourAvailabilty = o.ToLiteral<int>();
                    break;
                case "leftEdgeLumaPixels":
                    LeftEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "upperLeftCornerLumaPixel":
                    UpperLeftCornerLumaPixel = o.ToLiteral<int>();
                    break;
                case "upperEdgeLumaPixels":
                    UpperEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "upperRightEdgeLumaPixels":
                    UpperRightEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "leftEdgeChromaPixels":
                    LeftEdgeChromaPixels = o.ToLiteral<int>();
                    break;
                case "upperLeftCornerChromaPixel":
                    UpperLeftCornerChromaPixel = o.ToLiteral<int>();
                    break;
                case "upperEdgeChromaPixels":
                    UpperEdgeChromaPixels = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetMotionVectorMaskINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetMotionVectorMaskINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipBlockPartitionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetMotionVectorMaskINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(int resultType, int resultId, int skipBlockPartitionType, int direction)
    {
        ResultType = resultType;
        ResultId = resultId;
        SkipBlockPartitionType = skipBlockPartitionType;
        Direction = direction;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetMotionVectorMaskINTEL, ResultType, ResultId, SkipBlockPartitionType, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "skipBlockPartitionType":
                    SkipBlockPartitionType = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicConvertToMcePayloadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConvertToMcePayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConvertToMcePayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedShapePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(int resultType, int resultId, int packedShapePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedShapePenalty = packedShapePenalty;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL, ResultType, ResultId, PackedShapePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedShapePenalty":
                    PackedShapePenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaModePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaPackedNeighborModes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaPackedNonDcPenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(int resultType, int resultId, int lumaModePenalty, int lumaPackedNeighborModes, int lumaPackedNonDcPenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        LumaModePenalty = lumaModePenalty;
        LumaPackedNeighborModes = lumaPackedNeighborModes;
        LumaPackedNonDcPenalty = lumaPackedNonDcPenalty;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL, ResultType, ResultId, LumaModePenalty, LumaPackedNeighborModes, LumaPackedNonDcPenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "lumaModePenalty":
                    LumaModePenalty = o.ToLiteral<int>();
                    break;
                case "lumaPackedNeighborModes":
                    LumaPackedNeighborModes = o.ToLiteral<int>();
                    break;
                case "lumaPackedNonDcPenalty":
                    LumaPackedNonDcPenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ChromaModeBasePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(int resultType, int resultId, int chromaModeBasePenalty, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        ChromaModeBasePenalty = chromaModeBasePenalty;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL, ResultType, ResultId, ChromaModeBasePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "chromaModeBasePenalty":
                    ChromaModeBasePenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicSetBilinearFilterEnableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetBilinearFilterEnableINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetBilinearFilterEnableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetBilinearFilterEnableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedSadCoefficients
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(int resultType, int resultId, int packedSadCoefficients, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        PackedSadCoefficients = packedSadCoefficients;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL, ResultType, ResultId, PackedSadCoefficients, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedSadCoefficients":
                    PackedSadCoefficients = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockBasedSkipType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(int resultType, int resultId, int blockBasedSkipType, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        BlockBasedSkipType = blockBasedSkipType;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL, ResultType, ResultId, BlockBasedSkipType, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "blockBasedSkipType":
                    BlockBasedSkipType = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicEvaluateIpeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateIpeINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateIpeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateIpeINTEL(int resultType, int resultId, int srcImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateIpeINTEL, ResultType, ResultId, SrcImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateIpeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int packedReferenceFieldPolarities, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceFieldPolarities = packedReferenceFieldPolarities;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, PackedReferenceFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "packedReferenceFieldPolarities":
                    PackedReferenceFieldPolarities = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicConvertToMceResultINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConvertToMceResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConvertToMceResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetIpeLumaShapeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetIpeLumaShapeINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetIpeLumaShapeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetIpeLumaShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetPackedIpeLumaModesINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetPackedIpeLumaModesINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetIpeChromaModeINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetIpeChromaModeINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetIpeChromaModeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetIpeChromaModeINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetIpeChromaModeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetIpeChromaModeINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupAvcSicGetInterRawSadsINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetInterRawSadsINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetInterRawSadsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetInterRawSadsINTEL(int resultType, int resultId, int payload)
    {
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetInterRawSadsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetInterRawSadsINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpVariableLengthArrayINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVariableLengthArrayINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVariableLengthArrayINTEL | (1 << 16);
    }

    public OpVariableLengthArrayINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpVariableLengthArrayINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Lenght
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVariableLengthArrayINTEL inst) => inst.ResultId;
    public OpVariableLengthArrayINTEL(int resultType, int resultId, int lenght)
    {
        ResultType = resultType;
        ResultId = resultId;
        Lenght = lenght;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVariableLengthArrayINTEL, ResultType, ResultId, Lenght];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "lenght":
                    Lenght = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpVariableLengthArrayINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSaveMemoryINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSaveMemoryINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSaveMemoryINTEL | (1 << 16);
    }

    public OpSaveMemoryINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSaveMemoryINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSaveMemoryINTEL inst) => inst.ResultId;
    public OpSaveMemoryINTEL(int resultType, int resultId)
    {
        ResultType = resultType;
        ResultId = resultId;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSaveMemoryINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSaveMemoryINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRestoreMemoryINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRestoreMemoryINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRestoreMemoryINTEL | (1 << 16);
    }

    public OpRestoreMemoryINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRestoreMemoryINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRestoreMemoryINTEL(int ptr)
    {
        Ptr = ptr;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRestoreMemoryINTEL, Ptr];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "ptr":
                    Ptr = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRestoreMemoryINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatSinCosPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinCosPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatSinCosPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatSinCosPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FromSign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSinCosPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSinCosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int fromSign, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        FromSign = fromSign;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinCosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..FromSign.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "fromSign":
                    FromSign = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSinCosPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatCastINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastINTEL | (1 << 16);
    }

    public OpArbitraryFloatCastINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatCastINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCastINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCastINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCastINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatCastFromIntINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastFromIntINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastFromIntINTEL | (1 << 16);
    }

    public OpArbitraryFloatCastFromIntINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatCastFromIntINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FromSign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCastFromIntINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCastFromIntINTEL(int resultType, int resultId, int a, int mout, int fromSign, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        Mout = mout;
        FromSign = fromSign;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastFromIntINTEL, ResultType, ResultId, A, ..Mout.AsDisposableLiteralValue().Words, ..FromSign.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "fromSign":
                    FromSign = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCastFromIntINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatCastToIntINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastToIntINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastToIntINTEL | (1 << 16);
    }

    public OpArbitraryFloatCastToIntINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatCastToIntINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCastToIntINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCastToIntINTEL(int resultType, int resultId, int a, int m1, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastToIntINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCastToIntINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatAddINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatAddINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatAddINTEL | (1 << 16);
    }

    public OpArbitraryFloatAddINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatAddINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatAddINTEL inst) => inst.ResultId;
    public OpArbitraryFloatAddINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatAddINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatAddINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatSubINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSubINTEL | (1 << 16);
    }

    public OpArbitraryFloatSubINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatSubINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSubINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSubINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSubINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSubINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatMulINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatMulINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatMulINTEL | (1 << 16);
    }

    public OpArbitraryFloatMulINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatMulINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatMulINTEL inst) => inst.ResultId;
    public OpArbitraryFloatMulINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatMulINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatMulINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatDivINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatDivINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatDivINTEL | (1 << 16);
    }

    public OpArbitraryFloatDivINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatDivINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatDivINTEL inst) => inst.ResultId;
    public OpArbitraryFloatDivINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatDivINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatDivINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatGTINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatGTINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatGTINTEL | (1 << 16);
    }

    public OpArbitraryFloatGTINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatGTINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatGTINTEL inst) => inst.ResultId;
    public OpArbitraryFloatGTINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatGTINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatGTINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatGEINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatGEINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatGEINTEL | (1 << 16);
    }

    public OpArbitraryFloatGEINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatGEINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatGEINTEL inst) => inst.ResultId;
    public OpArbitraryFloatGEINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatGEINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatGEINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatLTINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLTINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLTINTEL | (1 << 16);
    }

    public OpArbitraryFloatLTINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatLTINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLTINTEL inst) => inst.ResultId;
    public OpArbitraryFloatLTINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLTINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLTINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatLEINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLEINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLEINTEL | (1 << 16);
    }

    public OpArbitraryFloatLEINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatLEINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLEINTEL inst) => inst.ResultId;
    public OpArbitraryFloatLEINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLEINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLEINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatEQINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatEQINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatEQINTEL | (1 << 16);
    }

    public OpArbitraryFloatEQINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatEQINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatEQINTEL inst) => inst.ResultId;
    public OpArbitraryFloatEQINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatEQINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatEQINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatRecipINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatRecipINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatRecipINTEL | (1 << 16);
    }

    public OpArbitraryFloatRecipINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatRecipINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatRecipINTEL inst) => inst.ResultId;
    public OpArbitraryFloatRecipINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatRecipINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatRecipINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatRSqrtINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatRSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatRSqrtINTEL | (1 << 16);
    }

    public OpArbitraryFloatRSqrtINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatRSqrtINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatRSqrtINTEL inst) => inst.ResultId;
    public OpArbitraryFloatRSqrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatRSqrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatRSqrtINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatCbrtINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCbrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCbrtINTEL | (1 << 16);
    }

    public OpArbitraryFloatCbrtINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatCbrtINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCbrtINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCbrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCbrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCbrtINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatHypotINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatHypotINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatHypotINTEL | (1 << 16);
    }

    public OpArbitraryFloatHypotINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatHypotINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatHypotINTEL inst) => inst.ResultId;
    public OpArbitraryFloatHypotINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatHypotINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatHypotINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatSqrtINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSqrtINTEL | (1 << 16);
    }

    public OpArbitraryFloatSqrtINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatSqrtINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSqrtINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSqrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSqrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSqrtINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatLogINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLogINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLogINTEL | (1 << 16);
    }

    public OpArbitraryFloatLogINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatLogINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLogINTEL inst) => inst.ResultId;
    public OpArbitraryFloatLogINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLogINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLogINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatLog2INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog2INTEL | (1 << 16);
    }

    public OpArbitraryFloatLog2INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatLog2INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLog2INTEL inst) => inst.ResultId;
    public OpArbitraryFloatLog2INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLog2INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatLog10INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog10INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog10INTEL | (1 << 16);
    }

    public OpArbitraryFloatLog10INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatLog10INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLog10INTEL inst) => inst.ResultId;
    public OpArbitraryFloatLog10INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog10INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLog10INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatLog1pINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog1pINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog1pINTEL | (1 << 16);
    }

    public OpArbitraryFloatLog1pINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatLog1pINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLog1pINTEL inst) => inst.ResultId;
    public OpArbitraryFloatLog1pINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog1pINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLog1pINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatExpINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExpINTEL | (1 << 16);
    }

    public OpArbitraryFloatExpINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatExpINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatExpINTEL inst) => inst.ResultId;
    public OpArbitraryFloatExpINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExpINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatExpINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatExp2INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExp2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExp2INTEL | (1 << 16);
    }

    public OpArbitraryFloatExp2INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatExp2INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatExp2INTEL inst) => inst.ResultId;
    public OpArbitraryFloatExp2INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExp2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatExp2INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatExp10INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExp10INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExp10INTEL | (1 << 16);
    }

    public OpArbitraryFloatExp10INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatExp10INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatExp10INTEL inst) => inst.ResultId;
    public OpArbitraryFloatExp10INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExp10INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatExp10INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatExpm1INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExpm1INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExpm1INTEL | (1 << 16);
    }

    public OpArbitraryFloatExpm1INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatExpm1INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatExpm1INTEL inst) => inst.ResultId;
    public OpArbitraryFloatExpm1INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExpm1INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatExpm1INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatSinINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinINTEL | (1 << 16);
    }

    public OpArbitraryFloatSinINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatSinINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSinINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSinINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSinINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatCosINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCosINTEL | (1 << 16);
    }

    public OpArbitraryFloatCosINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatCosINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCosINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCosINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatSinCosINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinCosINTEL | (1 << 16);
    }

    public OpArbitraryFloatSinCosINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatSinCosINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSinCosINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSinCosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinCosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSinCosINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatSinPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatSinPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatSinPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSinPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSinPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSinPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatCosPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCosPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatCosPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatCosPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCosPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCosPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatASinINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatASinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatASinINTEL | (1 << 16);
    }

    public OpArbitraryFloatASinINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatASinINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatASinINTEL inst) => inst.ResultId;
    public OpArbitraryFloatASinINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatASinINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatASinINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatASinPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatASinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatASinPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatASinPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatASinPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatASinPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatASinPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatASinPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatASinPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatACosINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatACosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatACosINTEL | (1 << 16);
    }

    public OpArbitraryFloatACosINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatACosINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatACosINTEL inst) => inst.ResultId;
    public OpArbitraryFloatACosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatACosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatACosINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatACosPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatACosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatACosPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatACosPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatACosPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatACosPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatACosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatACosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatACosPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatATanINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATanINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATanINTEL | (1 << 16);
    }

    public OpArbitraryFloatATanINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatATanINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatATanINTEL inst) => inst.ResultId;
    public OpArbitraryFloatATanINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATanINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatATanINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatATanPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATanPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATanPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatATanPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatATanPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatATanPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatATanPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATanPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatATanPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatATan2INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATan2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATan2INTEL | (1 << 16);
    }

    public OpArbitraryFloatATan2INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatATan2INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatATan2INTEL inst) => inst.ResultId;
    public OpArbitraryFloatATan2INTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATan2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatATan2INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatPowINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowINTEL | (1 << 16);
    }

    public OpArbitraryFloatPowINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatPowINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatPowINTEL inst) => inst.ResultId;
    public OpArbitraryFloatPowINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatPowINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatPowRINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowRINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowRINTEL | (1 << 16);
    }

    public OpArbitraryFloatPowRINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatPowRINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatPowRINTEL inst) => inst.ResultId;
    public OpArbitraryFloatPowRINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowRINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatPowRINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArbitraryFloatPowNINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowNINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowNINTEL | (1 << 16);
    }

    public OpArbitraryFloatPowNINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArbitraryFloatPowNINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatPowNINTEL inst) => inst.ResultId;
    public OpArbitraryFloatPowNINTEL(int resultType, int resultId, int a, int m1, int b, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowNINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatPowNINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpLoopControlINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoopControlINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoopControlINTEL | (1 << 16);
    }

    public OpLoopControlINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpLoopControlINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLoopControlINTEL(LiteralArray<int> values)
    {
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoopControlINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpLoopControlINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpAliasDomainDeclINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasDomainDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasDomainDeclINTEL | (1 << 16);
    }

    public OpAliasDomainDeclINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAliasDomainDeclINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAliasDomainDeclINTEL inst) => inst.ResultId;
    public OpAliasDomainDeclINTEL(int resultId, int? name)
    {
        ResultId = resultId;
        Name = name;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasDomainDeclINTEL, ResultId, ..(Name is null ? (Span<int>)[] : [Name.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "name":
                    if (o.Words.Length > 0)
                    {
                        Name = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAliasDomainDeclINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAliasScopeDeclINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasScopeDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasScopeDeclINTEL | (1 << 16);
    }

    public OpAliasScopeDeclINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAliasScopeDeclINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AliasDomain
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAliasScopeDeclINTEL inst) => inst.ResultId;
    public OpAliasScopeDeclINTEL(int resultId, int aliasDomain, int? name)
    {
        ResultId = resultId;
        AliasDomain = aliasDomain;
        Name = name;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasScopeDeclINTEL, ResultId, AliasDomain, ..(Name is null ? (Span<int>)[] : [Name.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "aliasDomain":
                    AliasDomain = o.ToLiteral<int>();
                    break;
                case "name":
                    if (o.Words.Length > 0)
                    {
                        Name = o.ToLiteral<int>();
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAliasScopeDeclINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAliasScopeListDeclINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasScopeListDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasScopeListDeclINTEL | (1 << 16);
    }

    public OpAliasScopeListDeclINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAliasScopeListDeclINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAliasScopeListDeclINTEL inst) => inst.ResultId;
    public OpAliasScopeListDeclINTEL(int resultId, LiteralArray<int> values)
    {
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasScopeListDeclINTEL, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpAliasScopeListDeclINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpFixedSqrtINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSqrtINTEL | (1 << 16);
    }

    public OpFixedSqrtINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedSqrtINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSqrtINTEL inst) => inst.ResultId;
    public OpFixedSqrtINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSqrtINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedSqrtINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedRecipINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedRecipINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedRecipINTEL | (1 << 16);
    }

    public OpFixedRecipINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedRecipINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedRecipINTEL inst) => inst.ResultId;
    public OpFixedRecipINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedRecipINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedRecipINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedRsqrtINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedRsqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedRsqrtINTEL | (1 << 16);
    }

    public OpFixedRsqrtINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedRsqrtINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedRsqrtINTEL inst) => inst.ResultId;
    public OpFixedRsqrtINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedRsqrtINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedRsqrtINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedSinINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinINTEL | (1 << 16);
    }

    public OpFixedSinINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedSinINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSinINTEL inst) => inst.ResultId;
    public OpFixedSinINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedSinINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedCosINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedCosINTEL | (1 << 16);
    }

    public OpFixedCosINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedCosINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedCosINTEL inst) => inst.ResultId;
    public OpFixedCosINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedCosINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedCosINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedSinCosINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinCosINTEL | (1 << 16);
    }

    public OpFixedSinCosINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedSinCosINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSinCosINTEL inst) => inst.ResultId;
    public OpFixedSinCosINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinCosINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedSinCosINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedSinPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinPiINTEL | (1 << 16);
    }

    public OpFixedSinPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedSinPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSinPiINTEL inst) => inst.ResultId;
    public OpFixedSinPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedSinPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedCosPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedCosPiINTEL | (1 << 16);
    }

    public OpFixedCosPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedCosPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedCosPiINTEL inst) => inst.ResultId;
    public OpFixedCosPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedCosPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedCosPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedSinCosPiINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinCosPiINTEL | (1 << 16);
    }

    public OpFixedSinCosPiINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedSinCosPiINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSinCosPiINTEL inst) => inst.ResultId;
    public OpFixedSinCosPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinCosPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedSinCosPiINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedLogINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedLogINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedLogINTEL | (1 << 16);
    }

    public OpFixedLogINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedLogINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedLogINTEL inst) => inst.ResultId;
    public OpFixedLogINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedLogINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedLogINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFixedExpINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedExpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedExpINTEL | (1 << 16);
    }

    public OpFixedExpINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFixedExpINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedExpINTEL inst) => inst.ResultId;
    public OpFixedExpINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedExpINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFixedExpINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpPtrCastToCrossWorkgroupINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrCastToCrossWorkgroupINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrCastToCrossWorkgroupINTEL | (1 << 16);
    }

    public OpPtrCastToCrossWorkgroupINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpPtrCastToCrossWorkgroupINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrCastToCrossWorkgroupINTEL inst) => inst.ResultId;
    public OpPtrCastToCrossWorkgroupINTEL(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrCastToCrossWorkgroupINTEL, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpPtrCastToCrossWorkgroupINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpCrossWorkgroupCastToPtrINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCrossWorkgroupCastToPtrINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCrossWorkgroupCastToPtrINTEL | (1 << 16);
    }

    public OpCrossWorkgroupCastToPtrINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCrossWorkgroupCastToPtrINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCrossWorkgroupCastToPtrINTEL inst) => inst.ResultId;
    public OpCrossWorkgroupCastToPtrINTEL(int resultType, int resultId, int pointer)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCrossWorkgroupCastToPtrINTEL, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpCrossWorkgroupCastToPtrINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpReadPipeBlockingINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadPipeBlockingINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadPipeBlockingINTEL | (1 << 16);
    }

    public OpReadPipeBlockingINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpReadPipeBlockingINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReadPipeBlockingINTEL inst) => inst.ResultId;
    public OpReadPipeBlockingINTEL(int resultType, int resultId, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadPipeBlockingINTEL, ResultType, ResultId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpReadPipeBlockingINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpWritePipeBlockingINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePipeBlockingINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePipeBlockingINTEL | (1 << 16);
    }

    public OpWritePipeBlockingINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpWritePipeBlockingINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpWritePipeBlockingINTEL inst) => inst.ResultId;
    public OpWritePipeBlockingINTEL(int resultType, int resultId, int packetSize, int packetAlignment)
    {
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePipeBlockingINTEL, ResultType, ResultId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpWritePipeBlockingINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpFPGARegINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFPGARegINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFPGARegINTEL | (1 << 16);
    }

    public OpFPGARegINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpFPGARegINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Result
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFPGARegINTEL inst) => inst.ResultId;
    public OpFPGARegINTEL(int resultType, int resultId, int result, int input)
    {
        ResultType = resultType;
        ResultId = resultId;
        Result = result;
        Input = input;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFPGARegINTEL, ResultType, ResultId, Result, Input];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "result":
                    Result = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpFPGARegINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetRayTMinKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetRayTMinKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetRayTMinKHR | (1 << 16);
    }

    public OpRayQueryGetRayTMinKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetRayTMinKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetRayTMinKHR inst) => inst.ResultId;
    public OpRayQueryGetRayTMinKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetRayTMinKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetRayTMinKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetRayFlagsKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetRayFlagsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetRayFlagsKHR | (1 << 16);
    }

    public OpRayQueryGetRayFlagsKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetRayFlagsKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetRayFlagsKHR inst) => inst.ResultId;
    public OpRayQueryGetRayFlagsKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetRayFlagsKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetRayFlagsKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionTKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionTKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionTKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionTKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionTKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionInstanceCustomIndexKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceCustomIndexKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionInstanceCustomIndexKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceCustomIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionInstanceIdKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceIdKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceIdKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionInstanceIdKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionInstanceIdKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionInstanceIdKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionInstanceIdKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceIdKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceIdKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionGeometryIndexKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionGeometryIndexKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionGeometryIndexKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionGeometryIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionGeometryIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionGeometryIndexKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionPrimitiveIndexKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionPrimitiveIndexKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionPrimitiveIndexKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionPrimitiveIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionPrimitiveIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionPrimitiveIndexKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionBarycentricsKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionBarycentricsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionBarycentricsKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionBarycentricsKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionBarycentricsKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionBarycentricsKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionBarycentricsKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionBarycentricsKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionBarycentricsKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionFrontFaceKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionFrontFaceKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionFrontFaceKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionFrontFaceKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionFrontFaceKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionFrontFaceKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionFrontFaceKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionFrontFaceKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionFrontFaceKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionCandidateAABBOpaqueKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionCandidateAABBOpaqueKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionObjectRayDirectionKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectRayDirectionKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionObjectRayDirectionKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionObjectRayDirectionKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectRayDirectionKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectRayDirectionKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionObjectRayOriginKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectRayOriginKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionObjectRayOriginKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionObjectRayOriginKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectRayOriginKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectRayOriginKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetWorldRayDirectionKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetWorldRayDirectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetWorldRayDirectionKHR | (1 << 16);
    }

    public OpRayQueryGetWorldRayDirectionKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetWorldRayDirectionKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetWorldRayDirectionKHR inst) => inst.ResultId;
    public OpRayQueryGetWorldRayDirectionKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetWorldRayDirectionKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetWorldRayDirectionKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetWorldRayOriginKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetWorldRayOriginKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetWorldRayOriginKHR | (1 << 16);
    }

    public OpRayQueryGetWorldRayOriginKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetWorldRayOriginKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetWorldRayOriginKHR inst) => inst.ResultId;
    public OpRayQueryGetWorldRayOriginKHR(int resultType, int resultId, int rayQuery)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetWorldRayOriginKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetWorldRayOriginKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionObjectToWorldKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectToWorldKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionObjectToWorldKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionObjectToWorldKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectToWorldKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectToWorldKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpRayQueryGetIntersectionWorldToObjectKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionWorldToObjectKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionWorldToObjectKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionWorldToObjectKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionWorldToObjectKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionWorldToObjectKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpAtomicFAddEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFAddEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFAddEXT | (1 << 16);
    }

    public OpAtomicFAddEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpAtomicFAddEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicFAddEXT inst) => inst.ResultId;
    public OpAtomicFAddEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFAddEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFAddEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeBufferSurfaceINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeBufferSurfaceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeBufferSurfaceINTEL | (1 << 16);
    }

    public OpTypeBufferSurfaceINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeBufferSurfaceINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier AccessQualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeBufferSurfaceINTEL inst) => inst.ResultId;
    public OpTypeBufferSurfaceINTEL(int resultId, AccessQualifier accessQualifier)
    {
        ResultId = resultId;
        AccessQualifier = accessQualifier;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeBufferSurfaceINTEL, ResultId, (int)AccessQualifier];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "accessQualifier":
                    AccessQualifier = o.ToEnum<AccessQualifier>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpTypeBufferSurfaceINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpTypeStructContinuedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeStructContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeStructContinuedINTEL | (1 << 16);
    }

    public OpTypeStructContinuedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpTypeStructContinuedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeStructContinuedINTEL(LiteralArray<int> values)
    {
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeStructContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpTypeStructContinuedINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpConstantCompositeContinuedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantCompositeContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantCompositeContinuedINTEL | (1 << 16);
    }

    public OpConstantCompositeContinuedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConstantCompositeContinuedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantCompositeContinuedINTEL(LiteralArray<int> values)
    {
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantCompositeContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpConstantCompositeContinuedINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpSpecConstantCompositeContinuedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantCompositeContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantCompositeContinuedINTEL | (1 << 16);
    }

    public OpSpecConstantCompositeContinuedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSpecConstantCompositeContinuedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantCompositeContinuedINTEL(LiteralArray<int> values)
    {
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantCompositeContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpSpecConstantCompositeContinuedINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpCompositeConstructContinuedINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstructContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstructContinuedINTEL | (1 << 16);
    }

    public OpCompositeConstructContinuedINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpCompositeConstructContinuedINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeConstructContinuedINTEL inst) => inst.ResultId;
    public OpCompositeConstructContinuedINTEL(int resultType, int resultId, LiteralArray<int> values)
    {
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstructContinuedINTEL, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }

        if (Values.WordCount == -1)
            Values = new();
    }

    public static implicit operator OpCompositeConstructContinuedINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        Values.Dispose();
    }
}

public ref partial struct OpConvertFToBF16INTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToBF16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToBF16INTEL | (1 << 16);
    }

    public OpConvertFToBF16INTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertFToBF16INTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertFToBF16INTEL inst) => inst.ResultId;
    public OpConvertFToBF16INTEL(int resultType, int resultId, int floatValue)
    {
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToBF16INTEL, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "floatValue":
                    FloatValue = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertFToBF16INTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpConvertBF16ToFINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertBF16ToFINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertBF16ToFINTEL | (1 << 16);
    }

    public OpConvertBF16ToFINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpConvertBF16ToFINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BFloat16Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertBF16ToFINTEL inst) => inst.ResultId;
    public OpConvertBF16ToFINTEL(int resultType, int resultId, int bFloat16Value)
    {
        ResultType = resultType;
        ResultId = resultId;
        BFloat16Value = bFloat16Value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertBF16ToFINTEL, ResultType, ResultId, BFloat16Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "bFloat16Value":
                    BFloat16Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpConvertBF16ToFINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpControlBarrierArriveINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrierArriveINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrierArriveINTEL | (1 << 16);
    }

    public OpControlBarrierArriveINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpControlBarrierArriveINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrierArriveINTEL(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrierArriveINTEL, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpControlBarrierArriveINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpControlBarrierWaitINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrierWaitINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrierWaitINTEL | (1 << 16);
    }

    public OpControlBarrierWaitINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpControlBarrierWaitINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrierWaitINTEL(int execution, int memory, int semantics)
    {
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrierWaitINTEL, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpControlBarrierWaitINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpArithmeticFenceEXT : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArithmeticFenceEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArithmeticFenceEXT | (1 << 16);
    }

    public OpArithmeticFenceEXT(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpArithmeticFenceEXT(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArithmeticFenceEXT inst) => inst.ResultId;
    public OpArithmeticFenceEXT(int resultType, int resultId, int target)
    {
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArithmeticFenceEXT, ResultType, ResultId, Target];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpArithmeticFenceEXT(OpDataIndex odi) => new(odi);
}

public ref partial struct OpSubgroupBlockPrefetchINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockPrefetchINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockPrefetchINTEL | (1 << 16);
    }

    public OpSubgroupBlockPrefetchINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpSubgroupBlockPrefetchINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumBytes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryAccessMask? Memoryaccess { get; set; }

    public EnumerantParameters MemoryaccessParameters
    {
        get;
        set
        {
            field.Dispose();
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockPrefetchINTEL(int ptr, int numBytes, MemoryAccessMask? memoryaccess, EnumerantParameters memoryaccessParameters)
    {
        Ptr = ptr;
        NumBytes = numBytes;
        Memoryaccess = memoryaccess;
        MemoryaccessParameters = memoryaccessParameters;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockPrefetchINTEL, Ptr, NumBytes, ..(Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value, ..MemoryaccessParameters])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "ptr":
                    Ptr = o.ToLiteral<int>();
                    break;
                case "numBytes":
                    NumBytes = o.ToLiteral<int>();
                    break;
                case "memoryaccess":
                    if (o.Words.Length > 0)
                    {
                        Memoryaccess = o.ToEnum<MemoryAccessMask>();
                        if (data.Memory.Span.Length > o.Offset + 1)
                            MemoryaccessParameters = new(data.Memory.Span[(o.Offset + 2)..]);
                    }

                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupBlockPrefetchINTEL(OpDataIndex odi) => new(odi);
    public void Dispose()
    {
        MemoryaccessParameters.Dispose();
    }
}

public ref partial struct OpGroupIMulKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIMulKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIMulKHR | (1 << 16);
    }

    public OpGroupIMulKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupIMulKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupIMulKHR inst) => inst.ResultId;
    public OpGroupIMulKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIMulKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupIMulKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupFMulKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMulKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMulKHR | (1 << 16);
    }

    public OpGroupFMulKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupFMulKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMulKHR inst) => inst.ResultId;
    public OpGroupFMulKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMulKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMulKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupBitwiseAndKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseAndKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseAndKHR | (1 << 16);
    }

    public OpGroupBitwiseAndKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupBitwiseAndKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupBitwiseAndKHR inst) => inst.ResultId;
    public OpGroupBitwiseAndKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseAndKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupBitwiseAndKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupBitwiseOrKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseOrKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseOrKHR | (1 << 16);
    }

    public OpGroupBitwiseOrKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupBitwiseOrKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupBitwiseOrKHR inst) => inst.ResultId;
    public OpGroupBitwiseOrKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseOrKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupBitwiseOrKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupBitwiseXorKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseXorKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseXorKHR | (1 << 16);
    }

    public OpGroupBitwiseXorKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupBitwiseXorKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupBitwiseXorKHR inst) => inst.ResultId;
    public OpGroupBitwiseXorKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseXorKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupBitwiseXorKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupLogicalAndKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalAndKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalAndKHR | (1 << 16);
    }

    public OpGroupLogicalAndKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupLogicalAndKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupLogicalAndKHR inst) => inst.ResultId;
    public OpGroupLogicalAndKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalAndKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupLogicalAndKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupLogicalOrKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalOrKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalOrKHR | (1 << 16);
    }

    public OpGroupLogicalOrKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupLogicalOrKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupLogicalOrKHR inst) => inst.ResultId;
    public OpGroupLogicalOrKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalOrKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupLogicalOrKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpGroupLogicalXorKHR : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalXorKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalXorKHR | (1 << 16);
    }

    public OpGroupLogicalXorKHR(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpGroupLogicalXorKHR(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupLogicalXorKHR inst) => inst.ResultId;
    public OpGroupLogicalXorKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalXorKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpGroupLogicalXorKHR(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMaskedGatherINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMaskedGatherINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMaskedGatherINTEL | (1 << 16);
    }

    public OpMaskedGatherINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMaskedGatherINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PtrVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Alignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FillEmpty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMaskedGatherINTEL inst) => inst.ResultId;
    public OpMaskedGatherINTEL(int resultType, int resultId, int ptrVector, int alignment, int mask, int fillEmpty)
    {
        ResultType = resultType;
        ResultId = resultId;
        PtrVector = ptrVector;
        Alignment = alignment;
        Mask = mask;
        FillEmpty = fillEmpty;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMaskedGatherINTEL, ResultType, ResultId, PtrVector, ..Alignment.AsDisposableLiteralValue().Words, Mask, FillEmpty];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "ptrVector":
                    PtrVector = o.ToLiteral<int>();
                    break;
                case "alignment":
                    Alignment = o.ToLiteral<int>();
                    break;
                case "mask":
                    Mask = o.ToLiteral<int>();
                    break;
                case "fillEmpty":
                    FillEmpty = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMaskedGatherINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct OpMaskedScatterINTEL : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMaskedScatterINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMaskedScatterINTEL | (1 << 16);
    }

    public OpMaskedScatterINTEL(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public OpMaskedScatterINTEL(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int InputVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PtrVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Alignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMaskedScatterINTEL(int inputVector, int ptrVector, int alignment, int mask)
    {
        InputVector = inputVector;
        PtrVector = ptrVector;
        Alignment = alignment;
        Mask = mask;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMaskedScatterINTEL, InputVector, PtrVector, ..Alignment.AsDisposableLiteralValue().Words, Mask];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "inputVector":
                    InputVector = o.ToLiteral<int>();
                    break;
                case "ptrVector":
                    PtrVector = o.ToLiteral<int>();
                    break;
                case "alignment":
                    Alignment = o.ToLiteral<int>();
                    break;
                case "mask":
                    Mask = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator OpMaskedScatterINTEL(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLRound : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLRound()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLRound(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLRound(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLRound inst) => inst.ResultId;
    public GLSLRound(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLRound, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLRound(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLRoundEven : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLRoundEven()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLRoundEven(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLRoundEven(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLRoundEven inst) => inst.ResultId;
    public GLSLRoundEven(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLRoundEven, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLRoundEven(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLTrunc : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLTrunc()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLTrunc(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLTrunc(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLTrunc inst) => inst.ResultId;
    public GLSLTrunc(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLTrunc, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLTrunc(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFAbs : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFAbs()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFAbs(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFAbs(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFAbs inst) => inst.ResultId;
    public GLSLFAbs(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFAbs, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFAbs(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSAbs : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSAbs()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSAbs(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSAbs(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSAbs inst) => inst.ResultId;
    public GLSLSAbs(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSAbs, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSAbs(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFSign : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFSign()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFSign(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFSign(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFSign inst) => inst.ResultId;
    public GLSLFSign(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFSign, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFSign(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSSign : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSSign()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSSign(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSSign(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSSign inst) => inst.ResultId;
    public GLSLSSign(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSSign, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSSign(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFloor : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFloor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFloor(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFloor(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFloor inst) => inst.ResultId;
    public GLSLFloor(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFloor, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFloor(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLCeil : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLCeil()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLCeil(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLCeil(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLCeil inst) => inst.ResultId;
    public GLSLCeil(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLCeil, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLCeil(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFract : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFract(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFract(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFract inst) => inst.ResultId;
    public GLSLFract(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFract, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFract(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLRadians : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLRadians()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLRadians(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLRadians(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Degrees
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLRadians inst) => inst.ResultId;
    public GLSLRadians(int resultType, int resultId, int set, int degrees)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Degrees = degrees;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLRadians, Degrees];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "degrees":
                    Degrees = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLRadians(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLDegrees : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLDegrees()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLDegrees(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLDegrees(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Radians
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLDegrees inst) => inst.ResultId;
    public GLSLDegrees(int resultType, int resultId, int set, int radians)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Radians = radians;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLDegrees, Radians];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "radians":
                    Radians = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLDegrees(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSin inst) => inst.ResultId;
    public GLSLSin(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSin, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSin(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLCos : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLCos()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLCos(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLCos(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLCos inst) => inst.ResultId;
    public GLSLCos(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLCos, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLCos(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLTan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLTan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLTan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLTan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLTan inst) => inst.ResultId;
    public GLSLTan(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLTan, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLTan(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLAsin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAsin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAsin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLAsin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAsin inst) => inst.ResultId;
    public GLSLAsin(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLAsin, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLAsin(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLAcos : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAcos()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAcos(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLAcos(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAcos inst) => inst.ResultId;
    public GLSLAcos(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLAcos, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLAcos(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLAtan : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAtan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAtan(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLAtan(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y_over_x
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAtan inst) => inst.ResultId;
    public GLSLAtan(int resultType, int resultId, int set, int y_over_x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Y_over_x = y_over_x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLAtan, Y_over_x];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "y_over_x":
                    Y_over_x = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLAtan(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSinh : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSinh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSinh(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSinh(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSinh inst) => inst.ResultId;
    public GLSLSinh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSinh, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSinh(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLCosh : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLCosh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLCosh(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLCosh(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLCosh inst) => inst.ResultId;
    public GLSLCosh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLCosh, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLCosh(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLTanh : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLTanh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLTanh(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLTanh(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLTanh inst) => inst.ResultId;
    public GLSLTanh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLTanh, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLTanh(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLAsinh : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAsinh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAsinh(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLAsinh(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAsinh inst) => inst.ResultId;
    public GLSLAsinh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLAsinh, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLAsinh(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLAcosh : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAcosh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAcosh(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLAcosh(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAcosh inst) => inst.ResultId;
    public GLSLAcosh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLAcosh, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLAcosh(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLAtanh : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAtanh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAtanh(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLAtanh(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAtanh inst) => inst.ResultId;
    public GLSLAtanh(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLAtanh, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLAtanh(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLAtan2 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAtan2()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAtan2(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLAtan2(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAtan2 inst) => inst.ResultId;
    public GLSLAtan2(int resultType, int resultId, int set, int y, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Y = y;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLAtan2, Y, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLAtan2(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLPow : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPow()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPow(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLPow(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPow inst) => inst.ResultId;
    public GLSLPow(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLPow, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLPow(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLExp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLExp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLExp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLExp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLExp inst) => inst.ResultId;
    public GLSLExp(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLExp, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLExp(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLLog : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLLog()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLLog(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLLog(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLLog inst) => inst.ResultId;
    public GLSLLog(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLLog, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLLog(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLExp2 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLExp2()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLExp2(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLExp2(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLExp2 inst) => inst.ResultId;
    public GLSLExp2(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLExp2, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLExp2(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLLog2 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLLog2()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLLog2(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLLog2(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLLog2 inst) => inst.ResultId;
    public GLSLLog2(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLLog2, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLLog2(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSqrt : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSqrt()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSqrt(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSqrt(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSqrt inst) => inst.ResultId;
    public GLSLSqrt(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSqrt, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSqrt(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLInverseSqrt : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLInverseSqrt()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLInverseSqrt(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLInverseSqrt(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLInverseSqrt inst) => inst.ResultId;
    public GLSLInverseSqrt(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLInverseSqrt, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLInverseSqrt(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLDeterminant : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLDeterminant()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLDeterminant(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLDeterminant(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLDeterminant inst) => inst.ResultId;
    public GLSLDeterminant(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLDeterminant, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLDeterminant(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLMatrixInverse : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLMatrixInverse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLMatrixInverse(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLMatrixInverse(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLMatrixInverse inst) => inst.ResultId;
    public GLSLMatrixInverse(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLMatrixInverse, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLMatrixInverse(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLModf : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLModf()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLModf(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLModf(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLModf inst) => inst.ResultId;
    public GLSLModf(int resultType, int resultId, int set, int x, int i)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        I = i;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLModf, X, I];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLModf(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLModfStruct : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLModfStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLModfStruct(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLModfStruct(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLModfStruct inst) => inst.ResultId;
    public GLSLModfStruct(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLModfStruct, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLModfStruct(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFMin inst) => inst.ResultId;
    public GLSLFMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFMin, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFMin(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUMin inst) => inst.ResultId;
    public GLSLUMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUMin, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUMin(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSMin inst) => inst.ResultId;
    public GLSLSMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSMin, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSMin(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFMax inst) => inst.ResultId;
    public GLSLFMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFMax, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFMax(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUMax inst) => inst.ResultId;
    public GLSLUMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUMax, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUMax(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSMax inst) => inst.ResultId;
    public GLSLSMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSMax, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSMax(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFClamp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFClamp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFClamp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFClamp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFClamp inst) => inst.ResultId;
    public GLSLFClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFClamp, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "minVal":
                    MinVal = o.ToLiteral<int>();
                    break;
                case "maxVal":
                    MaxVal = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFClamp(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUClamp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUClamp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUClamp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUClamp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUClamp inst) => inst.ResultId;
    public GLSLUClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUClamp, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "minVal":
                    MinVal = o.ToLiteral<int>();
                    break;
                case "maxVal":
                    MaxVal = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUClamp(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSClamp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSClamp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSClamp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSClamp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSClamp inst) => inst.ResultId;
    public GLSLSClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSClamp, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "minVal":
                    MinVal = o.ToLiteral<int>();
                    break;
                case "maxVal":
                    MaxVal = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSClamp(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFMix : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFMix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFMix(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFMix(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFMix inst) => inst.ResultId;
    public GLSLFMix(int resultType, int resultId, int set, int x, int y, int a)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        A = a;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFMix, X, Y, A];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFMix(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLIMix : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLIMix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLIMix(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLIMix(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLIMix inst) => inst.ResultId;
    public GLSLIMix(int resultType, int resultId, int set, int x, int y, int a)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        A = a;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLIMix, X, Y, A];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLIMix(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLStep : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLStep()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLStep(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLStep(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLStep inst) => inst.ResultId;
    public GLSLStep(int resultType, int resultId, int set, int edge, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Edge = edge;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLStep, Edge, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "edge":
                    Edge = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLStep(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLSmoothStep : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSmoothStep()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSmoothStep(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLSmoothStep(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge0
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSmoothStep inst) => inst.ResultId;
    public GLSLSmoothStep(int resultType, int resultId, int set, int edge0, int edge1, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Edge0 = edge0;
        Edge1 = edge1;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLSmoothStep, Edge0, Edge1, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "edge0":
                    Edge0 = o.ToLiteral<int>();
                    break;
                case "edge1":
                    Edge1 = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLSmoothStep(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFma : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFma()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFma(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFma(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFma inst) => inst.ResultId;
    public GLSLFma(int resultType, int resultId, int set, int a, int b, int c)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        A = a;
        B = b;
        C = c;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFma, A, B, C];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "c":
                    C = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFma(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFrexp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFrexp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFrexp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFrexp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Exp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFrexp inst) => inst.ResultId;
    public GLSLFrexp(int resultType, int resultId, int set, int x, int exp)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Exp = exp;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFrexp, X, Exp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "exp":
                    Exp = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFrexp(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFrexpStruct : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFrexpStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFrexpStruct(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFrexpStruct(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFrexpStruct inst) => inst.ResultId;
    public GLSLFrexpStruct(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFrexpStruct, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFrexpStruct(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLLdexp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLLdexp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLLdexp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLLdexp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Exp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLLdexp inst) => inst.ResultId;
    public GLSLLdexp(int resultType, int resultId, int set, int x, int exp)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Exp = exp;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLLdexp, X, Exp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "exp":
                    Exp = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLLdexp(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLPackSnorm4x8 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackSnorm4x8()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackSnorm4x8(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLPackSnorm4x8(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackSnorm4x8 inst) => inst.ResultId;
    public GLSLPackSnorm4x8(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLPackSnorm4x8, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLPackSnorm4x8(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLPackUnorm4x8 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackUnorm4x8()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackUnorm4x8(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLPackUnorm4x8(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackUnorm4x8 inst) => inst.ResultId;
    public GLSLPackUnorm4x8(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLPackUnorm4x8, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLPackUnorm4x8(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLPackSnorm2x16 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackSnorm2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackSnorm2x16(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLPackSnorm2x16(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackSnorm2x16 inst) => inst.ResultId;
    public GLSLPackSnorm2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLPackSnorm2x16, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLPackSnorm2x16(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLPackUnorm2x16 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackUnorm2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackUnorm2x16(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLPackUnorm2x16(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackUnorm2x16 inst) => inst.ResultId;
    public GLSLPackUnorm2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLPackUnorm2x16, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLPackUnorm2x16(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLPackHalf2x16 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackHalf2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackHalf2x16(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLPackHalf2x16(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackHalf2x16 inst) => inst.ResultId;
    public GLSLPackHalf2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLPackHalf2x16, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLPackHalf2x16(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLPackDouble2x32 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackDouble2x32()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackDouble2x32(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLPackDouble2x32(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackDouble2x32 inst) => inst.ResultId;
    public GLSLPackDouble2x32(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLPackDouble2x32, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLPackDouble2x32(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUnpackSnorm2x16 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackSnorm2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackSnorm2x16(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUnpackSnorm2x16(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackSnorm2x16 inst) => inst.ResultId;
    public GLSLUnpackSnorm2x16(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUnpackSnorm2x16, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackSnorm2x16(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUnpackUnorm2x16 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackUnorm2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackUnorm2x16(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUnpackUnorm2x16(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackUnorm2x16 inst) => inst.ResultId;
    public GLSLUnpackUnorm2x16(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUnpackUnorm2x16, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackUnorm2x16(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUnpackHalf2x16 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackHalf2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackHalf2x16(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUnpackHalf2x16(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackHalf2x16 inst) => inst.ResultId;
    public GLSLUnpackHalf2x16(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUnpackHalf2x16, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackHalf2x16(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUnpackSnorm4x8 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackSnorm4x8()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackSnorm4x8(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUnpackSnorm4x8(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackSnorm4x8 inst) => inst.ResultId;
    public GLSLUnpackSnorm4x8(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUnpackSnorm4x8, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackSnorm4x8(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUnpackUnorm4x8 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackUnorm4x8()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackUnorm4x8(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUnpackUnorm4x8(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackUnorm4x8 inst) => inst.ResultId;
    public GLSLUnpackUnorm4x8(int resultType, int resultId, int set, int p)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUnpackUnorm4x8, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackUnorm4x8(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLUnpackDouble2x32 : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackDouble2x32()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackDouble2x32(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLUnpackDouble2x32(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackDouble2x32 inst) => inst.ResultId;
    public GLSLUnpackDouble2x32(int resultType, int resultId, int set, int v)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLUnpackDouble2x32, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackDouble2x32(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLLength : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLLength()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLLength(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLLength(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLLength inst) => inst.ResultId;
    public GLSLLength(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLLength, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLLength(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLDistance : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLDistance()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLDistance(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLDistance(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P0
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLDistance inst) => inst.ResultId;
    public GLSLDistance(int resultType, int resultId, int set, int p0, int p1)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P0 = p0;
        P1 = p1;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLDistance, P0, P1];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p0":
                    P0 = o.ToLiteral<int>();
                    break;
                case "p1":
                    P1 = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLDistance(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLCross : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLCross()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLCross(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLCross(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLCross inst) => inst.ResultId;
    public GLSLCross(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLCross, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLCross(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLNormalize : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLNormalize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLNormalize(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLNormalize(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLNormalize inst) => inst.ResultId;
    public GLSLNormalize(int resultType, int resultId, int set, int x)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLNormalize, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLNormalize(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFaceForward : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFaceForward()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFaceForward(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFaceForward(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Nref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFaceForward inst) => inst.ResultId;
    public GLSLFaceForward(int resultType, int resultId, int set, int n, int i, int nref)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        N = n;
        I = i;
        Nref = nref;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFaceForward, N, I, Nref];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "n":
                    N = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "nref":
                    Nref = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFaceForward(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLReflect : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLReflect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLReflect(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLReflect(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLReflect inst) => inst.ResultId;
    public GLSLReflect(int resultType, int resultId, int set, int i, int n)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        I = i;
        N = n;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLReflect, I, N];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "n":
                    N = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLReflect(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLRefract : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLRefract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLRefract(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLRefract(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Eta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLRefract inst) => inst.ResultId;
    public GLSLRefract(int resultType, int resultId, int set, int i, int n, int eta)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        I = i;
        N = n;
        Eta = eta;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLRefract, I, N, Eta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "n":
                    N = o.ToLiteral<int>();
                    break;
                case "eta":
                    Eta = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLRefract(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFindILsb : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFindILsb()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFindILsb(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFindILsb(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFindILsb inst) => inst.ResultId;
    public GLSLFindILsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFindILsb, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFindILsb(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFindSMsb : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFindSMsb()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFindSMsb(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFindSMsb(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFindSMsb inst) => inst.ResultId;
    public GLSLFindSMsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFindSMsb, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFindSMsb(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLFindUMsb : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFindUMsb()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFindUMsb(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLFindUMsb(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFindUMsb inst) => inst.ResultId;
    public GLSLFindUMsb(int resultType, int resultId, int set, int value)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLFindUMsb, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLFindUMsb(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLInterpolateAtCentroid : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLInterpolateAtCentroid()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLInterpolateAtCentroid(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLInterpolateAtCentroid(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLInterpolateAtCentroid inst) => inst.ResultId;
    public GLSLInterpolateAtCentroid(int resultType, int resultId, int set, int interpolant)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLInterpolateAtCentroid, Interpolant];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "interpolant":
                    Interpolant = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLInterpolateAtCentroid(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLInterpolateAtSample : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLInterpolateAtSample()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLInterpolateAtSample(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLInterpolateAtSample(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLInterpolateAtSample inst) => inst.ResultId;
    public GLSLInterpolateAtSample(int resultType, int resultId, int set, int interpolant, int sample)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        Sample = sample;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLInterpolateAtSample, Interpolant, Sample];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "interpolant":
                    Interpolant = o.ToLiteral<int>();
                    break;
                case "sample":
                    Sample = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLInterpolateAtSample(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLInterpolateAtOffset : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLInterpolateAtOffset()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLInterpolateAtOffset(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLInterpolateAtOffset(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLInterpolateAtOffset inst) => inst.ResultId;
    public GLSLInterpolateAtOffset(int resultType, int resultId, int set, int interpolant, int offset)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        Offset = offset;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLInterpolateAtOffset, Interpolant, Offset];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "interpolant":
                    Interpolant = o.ToLiteral<int>();
                    break;
                case "offset":
                    Offset = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLInterpolateAtOffset(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLNMin : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLNMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLNMin(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLNMin(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLNMin inst) => inst.ResultId;
    public GLSLNMin(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLNMin, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLNMin(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLNMax : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLNMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLNMax(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLNMax(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLNMax inst) => inst.ResultId;
    public GLSLNMax(int resultType, int resultId, int set, int x, int y)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLNMax, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLNMax(OpDataIndex odi) => new(odi);
}

public ref partial struct GLSLNClamp : IMemoryInstruction
{
    private ref OpData opData;
    public ref OpData OpData => ref opData;

    public MemoryOwner<int> InstructionMemory
    {
        get
        {
            if (!Unsafe.IsNullRef(ref OpData))
                return OpData.Memory;
            else
                return field;
        }

        private set
        {
            if (!Unsafe.IsNullRef(ref OpData))
            {
                OpData.Memory.Dispose();
                OpData.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLNClamp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLNClamp(OpDataIndex index)
    {
        InitializeProperties(ref index.Data);
        opData = ref index.Data;
    }

    public GLSLNClamp(ref OpData data)
    {
        InitializeProperties(ref data);
        opData = ref data;
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLNClamp inst) => inst.ResultId;
    public GLSLNClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
        UpdateInstructionMemory();
        opData = ref Unsafe.NullRef<OpData>();
    }

    public void Attach(OpDataIndex index)
    {
        opData = ref index.Data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, (int)GLSLOp.GLSLNClamp, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(ref OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "minVal":
                    MinVal = o.ToLiteral<int>();
                    break;
                case "maxVal":
                    MaxVal = o.ToLiteral<int>();
                    break;
                // We ignore unrecognized operands
                default:
                    break;
            }
        }
    }

    public static implicit operator GLSLNClamp(OpDataIndex odi) => new(odi);
}