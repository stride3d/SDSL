using static Spv.Specification;
using Stride.Shaders.Spirv.Core.Buffers;

namespace Stride.Shaders.Spirv.Core;
public static class SpirvBufferExtensions
{
    public static Instruction AddOpSDSLDecorateSemantic(this SpirvBuffer buffer, IdRef target, LiteralString semantic)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(semantic);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLDecorateSemantic, ..target.AsSpirvSpan(), ..semantic.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLDecorateSemantic(this SpirvBuffer buffer, int position, IdRef target, LiteralString semantic)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(semantic);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLDecorateSemantic, ..target.AsSpirvSpan(), ..semantic.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLMixinName(this SpirvBuffer buffer, LiteralString mixinName)
    {
        var wordLength = 1 + buffer.GetWordLength(mixinName);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLMixinName, ..mixinName.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLMixinName(this SpirvBuffer buffer, int position, LiteralString mixinName)
    {
        var wordLength = 1 + buffer.GetWordLength(mixinName);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLMixinName, ..mixinName.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLMixinEnd(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpSDSLMixinEnd]);
    }

    public static Instruction InsertOpSDSLMixinEnd(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpSDSLMixinEnd]);
    }

    public static Instruction AddOpSDSLMixinOffset(this SpirvBuffer buffer, LiteralInteger mixinName)
    {
        var wordLength = 1 + buffer.GetWordLength(mixinName);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLMixinOffset, ..mixinName.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLMixinOffset(this SpirvBuffer buffer, int position, LiteralInteger mixinName)
    {
        var wordLength = 1 + buffer.GetWordLength(mixinName);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLMixinOffset, ..mixinName.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLMixinInherit(this SpirvBuffer buffer, LiteralString mixinName)
    {
        var wordLength = 1 + buffer.GetWordLength(mixinName);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLMixinInherit, ..mixinName.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLMixinInherit(this SpirvBuffer buffer, int position, LiteralString mixinName)
    {
        var wordLength = 1 + buffer.GetWordLength(mixinName);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLMixinInherit, ..mixinName.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLCompose(this SpirvBuffer buffer, LiteralString mixin, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(mixin) + buffer.GetWordLength(name);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLCompose, ..mixin.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLCompose(this SpirvBuffer buffer, int position, LiteralString mixin, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(mixin) + buffer.GetWordLength(name);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLCompose, ..mixin.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLStage(this SpirvBuffer buffer, IdRef stagedElement)
    {
        var wordLength = 1 + buffer.GetWordLength(stagedElement);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLStage, ..stagedElement.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLStage(this SpirvBuffer buffer, int position, IdRef stagedElement)
    {
        var wordLength = 1 + buffer.GetWordLength(stagedElement);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLStage, ..stagedElement.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLImportFunction(this SpirvBuffer buffer, IdResult resultId, LiteralString functionName, LiteralString mixinName, LiteralInteger id, LiteralInteger typeId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(functionName) + buffer.GetWordLength(mixinName) + buffer.GetWordLength(id) + buffer.GetWordLength(typeId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLImportFunction, ..resultId.AsSpirvSpan(), ..functionName.AsSpirvSpan(), ..mixinName.AsSpirvSpan(), ..id.AsSpirvSpan(), ..typeId.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLImportFunction(this SpirvBuffer buffer, int position, IdResult resultId, LiteralString functionName, LiteralString mixinName, LiteralInteger id, LiteralInteger typeId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(functionName) + buffer.GetWordLength(mixinName) + buffer.GetWordLength(id) + buffer.GetWordLength(typeId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLImportFunction, ..resultId.AsSpirvSpan(), ..functionName.AsSpirvSpan(), ..mixinName.AsSpirvSpan(), ..id.AsSpirvSpan(), ..typeId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLImportVariable(this SpirvBuffer buffer, IdResult resultId, LiteralString variableName, LiteralString mixinName, LiteralInteger id)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(variableName) + buffer.GetWordLength(mixinName) + buffer.GetWordLength(id);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLImportVariable, ..resultId.AsSpirvSpan(), ..variableName.AsSpirvSpan(), ..mixinName.AsSpirvSpan(), ..id.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLImportVariable(this SpirvBuffer buffer, int position, IdResult resultId, LiteralString variableName, LiteralString mixinName, LiteralInteger id)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(variableName) + buffer.GetWordLength(mixinName) + buffer.GetWordLength(id);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLImportVariable, ..resultId.AsSpirvSpan(), ..variableName.AsSpirvSpan(), ..mixinName.AsSpirvSpan(), ..id.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLImportIdRef(this SpirvBuffer buffer, IdResult resultId, LiteralString mixinName, LiteralInteger id)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(mixinName) + buffer.GetWordLength(id);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLImportIdRef, ..resultId.AsSpirvSpan(), ..mixinName.AsSpirvSpan(), ..id.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLImportIdRef(this SpirvBuffer buffer, int position, IdResult resultId, LiteralString mixinName, LiteralInteger id)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(mixinName) + buffer.GetWordLength(id);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLImportIdRef, ..resultId.AsSpirvSpan(), ..mixinName.AsSpirvSpan(), ..id.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLMixinVariable(this SpirvBuffer buffer, IdResult resultId, IdRef mixinId, IdRef variableId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(mixinId) + buffer.GetWordLength(variableId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLMixinVariable, ..resultId.AsSpirvSpan(), ..mixinId.AsSpirvSpan(), ..variableId.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLMixinVariable(this SpirvBuffer buffer, int position, IdResult resultId, IdRef mixinId, IdRef variableId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(mixinId) + buffer.GetWordLength(variableId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLMixinVariable, ..resultId.AsSpirvSpan(), ..mixinId.AsSpirvSpan(), ..variableId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLVariable(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, StorageClass storageclass, LiteralString name, IdRef? initializer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(name) + buffer.GetWordLength(initializer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLVariable, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..name.AsSpirvSpan(), ..initializer.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLVariable(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, StorageClass storageclass, LiteralString name, IdRef? initializer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(name) + buffer.GetWordLength(initializer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLVariable, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..name.AsSpirvSpan(), ..initializer.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLFunctionParameter(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(name);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLFunctionParameter, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLFunctionParameter(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(name);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLFunctionParameter, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLIOVariable(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, StorageClass storageclass, ExecutionModel executionmodel, LiteralString name, LiteralString semantic, IdRef? initializer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(executionmodel) + buffer.GetWordLength(name) + buffer.GetWordLength(semantic) + buffer.GetWordLength(initializer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLIOVariable, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..executionmodel.AsSpirvSpan(), ..name.AsSpirvSpan(), ..semantic.AsSpirvSpan(), ..initializer.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLIOVariable(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, StorageClass storageclass, ExecutionModel executionmodel, LiteralString name, LiteralString semantic, IdRef? initializer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(executionmodel) + buffer.GetWordLength(name) + buffer.GetWordLength(semantic) + buffer.GetWordLength(initializer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLIOVariable, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..executionmodel.AsSpirvSpan(), ..name.AsSpirvSpan(), ..semantic.AsSpirvSpan(), ..initializer.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDSLFunction(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, FunctionControlMask functioncontrol, IdRef functionType, LiteralString functionName)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(functioncontrol) + buffer.GetWordLength(functionType) + buffer.GetWordLength(functionName);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDSLFunction, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..functioncontrol.AsSpirvSpan(), ..functionType.AsSpirvSpan(), ..functionName.AsSpirvSpan()]);
    }

    public static Instruction InsertOpSDSLFunction(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, FunctionControlMask functioncontrol, IdRef functionType, LiteralString functionName)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(functioncontrol) + buffer.GetWordLength(functionType) + buffer.GetWordLength(functionName);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDSLFunction, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..functioncontrol.AsSpirvSpan(), ..functionType.AsSpirvSpan(), ..functionName.AsSpirvSpan()]);
    }

    public static Instruction AddOpNop(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpNop]);
    }

    /// <summary>
    /// <para><c>OpNop</c></para>
    /// <para> This has no semantic impact and can safely be removed from a module.</para>
    /// </summary>
    public static Instruction InsertOpNop(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpNop]);
    }

    public static Instruction AddOpUndef(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUndef, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUndef</c></para>
    /// <para>Make an intermediate object whose value is undefined.</para>
    /// <para>Result Type is the type of object to make.  Result Type can be any type except OpTypeVoid.</para>
    /// <para>Each consumption of Result <c>id</c> yields an arbitrary, possibly different bit pattern or abstract value resulting in possibly different concrete, abstract, or opaque values.</para>
    /// </summary>
    public static Instruction InsertOpUndef(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUndef, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSourceContinued(this SpirvBuffer buffer, LiteralString continuedSource)
    {
        var wordLength = 1 + buffer.GetWordLength(continuedSource);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSourceContinued, ..continuedSource.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSourceContinued</c></para>
    /// <para>Continue specifying the Source text from the previous instruction. This has no semantic impact and can safely be removed from a module.</para>
    /// <para>Continued Source is a continuation of the source text in the previous Source.</para>
    /// <para>The previous instruction must be an OpSource or an OpSourceContinued instruction. As is true for all literal strings, the previous instruction’s string was nul terminated. That terminating nul from the previous instruction is not part of the source text; the first character of Continued Source logically immediately follows the last character of Source before its nul.</para>
    /// </summary>
    public static Instruction InsertOpSourceContinued(this SpirvBuffer buffer, int position, LiteralString continuedSource)
    {
        var wordLength = 1 + buffer.GetWordLength(continuedSource);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSourceContinued, ..continuedSource.AsSpirvSpan()]);
    }

    public static Instruction AddOpSource(this SpirvBuffer buffer, SourceLanguage sourcelanguage, LiteralInteger version, IdRef? file, LiteralString? source)
    {
        var wordLength = 1 + buffer.GetWordLength(sourcelanguage) + buffer.GetWordLength(version) + buffer.GetWordLength(file) + buffer.GetWordLength(source);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSource, ..sourcelanguage.AsSpirvSpan(), ..version.AsSpirvSpan(), ..file.AsSpirvSpan(), ..source.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSource</c></para>
    /// <para>Document what source language and text this module was translated from. This has no semantic impact and can safely be removed from a module.</para>
    /// <para>Version is the version of the source language. It is an unsigned 32-bit integer. </para>
    /// <para>File is an OpString instruction and is the source-level file name.</para>
    /// <para>Source is the text of the source-level file.</para>
    /// <para>Each client API specifies what form the Version operand takes, per source language.</para>
    /// </summary>
    public static Instruction InsertOpSource(this SpirvBuffer buffer, int position, SourceLanguage sourcelanguage, LiteralInteger version, IdRef? file, LiteralString? source)
    {
        var wordLength = 1 + buffer.GetWordLength(sourcelanguage) + buffer.GetWordLength(version) + buffer.GetWordLength(file) + buffer.GetWordLength(source);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSource, ..sourcelanguage.AsSpirvSpan(), ..version.AsSpirvSpan(), ..file.AsSpirvSpan(), ..source.AsSpirvSpan()]);
    }

    public static Instruction AddOpSourceExtension(this SpirvBuffer buffer, LiteralString extension)
    {
        var wordLength = 1 + buffer.GetWordLength(extension);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSourceExtension, ..extension.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSourceExtension</c></para>
    /// <para>Document an extension to the source language. This has no semantic impact and can safely be removed from a module.</para>
    /// <para>Extension is a string describing a source-language extension. Its form is dependent on the how the source language describes extensions.</para>
    /// </summary>
    public static Instruction InsertOpSourceExtension(this SpirvBuffer buffer, int position, LiteralString extension)
    {
        var wordLength = 1 + buffer.GetWordLength(extension);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSourceExtension, ..extension.AsSpirvSpan()]);
    }

    public static Instruction AddOpName(this SpirvBuffer buffer, IdRef target, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(name);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpName, ..target.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpName</c></para>
    /// <para>Assign a name string to another instruction’s Result <c>id</c>. This has no semantic impact and can safely be removed from a module.</para>
    /// <para>Target is the Result <c>id</c> to assign a name to. It can be the Result <c>id</c> of any other instruction; a variable, function, type, intermediate result, etc.</para>
    /// <para>Name is the string to assign.</para>
    /// </summary>
    public static Instruction InsertOpName(this SpirvBuffer buffer, int position, IdRef target, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(name);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpName, ..target.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction AddOpMemberName(this SpirvBuffer buffer, IdRef type, LiteralInteger member, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(type) + buffer.GetWordLength(member) + buffer.GetWordLength(name);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMemberName, ..type.AsSpirvSpan(), ..member.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberName</c></para>
    /// <para>Assign a name string to a member of a structure type. This has no semantic impact and can safely be removed from a module.</para>
    /// <para>Type is the <c>id</c> from an OpTypeStruct instruction.</para>
    /// <para>Member is the number of the member to assign in the structure. The first member is member 0, the next is member 1, …​ Member is an unsigned 32-bit integer. </para>
    /// <para>Name is the string to assign to the member.</para>
    /// </summary>
    public static Instruction InsertOpMemberName(this SpirvBuffer buffer, int position, IdRef type, LiteralInteger member, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(type) + buffer.GetWordLength(member) + buffer.GetWordLength(name);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMemberName, ..type.AsSpirvSpan(), ..member.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction AddOpString(this SpirvBuffer buffer, IdResult resultId, LiteralString value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpString, ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpString</c></para>
    /// <para>Assign a Result <c>id</c> to a string for use by other debug instructions (see OpLine and OpSource). This has no semantic impact and can safely be removed from a module. (Removal also requires removal of all instructions referencing Result <c>id</c>.)</para>
    /// <para>String is the string being assigned a Result <c>id</c>.</para>
    /// </summary>
    public static Instruction InsertOpString(this SpirvBuffer buffer, int position, IdResult resultId, LiteralString value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpString, ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpLine(this SpirvBuffer buffer, IdRef file, LiteralInteger line, LiteralInteger column)
    {
        var wordLength = 1 + buffer.GetWordLength(file) + buffer.GetWordLength(line) + buffer.GetWordLength(column);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLine, ..file.AsSpirvSpan(), ..line.AsSpirvSpan(), ..column.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLine</c></para>
    /// <para>Add source-level location information. This has no semantic impact and can safely be removed from a module.</para>
    /// <para> This location information applies to the instructions physically following this instruction, up to the first occurrence of any of the following: the next end of block, the next OpLine instruction, or the next OpNoLine instruction.</para>
    /// <para>File must be an OpString instruction and is the source-level file name.</para>
    /// <para>Line is the source-level line number. Line is an unsigned 32-bit integer. </para>
    /// <para>Column is the source-level column number. Column is an unsigned 32-bit integer. </para>
    /// <para>OpLine can generally immediately precede other instructions, with the following exceptions:</para>
    /// <para> - it may not be used until after the annotation instructions,</para>
    /// <para>   (see the Logical Layout section)</para>
    /// <para> - must not be the last instruction in a block, which is defined to end with a termination instruction</para>
    /// <para> - if a branch merge instruction is used, the last OpLine in the block must be before its merge instruction</para>
    /// </summary>
    public static Instruction InsertOpLine(this SpirvBuffer buffer, int position, IdRef file, LiteralInteger line, LiteralInteger column)
    {
        var wordLength = 1 + buffer.GetWordLength(file) + buffer.GetWordLength(line) + buffer.GetWordLength(column);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLine, ..file.AsSpirvSpan(), ..line.AsSpirvSpan(), ..column.AsSpirvSpan()]);
    }

    public static Instruction AddOpExtension(this SpirvBuffer buffer, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(name);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExtension, ..name.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExtension</c></para>
    /// <para>Declare use of an extension to SPIR-V. This allows validation of additional instructions, tokens, semantics, etc.</para>
    /// <para>Name is the extension’s name string.</para>
    /// </summary>
    public static Instruction InsertOpExtension(this SpirvBuffer buffer, int position, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(name);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExtension, ..name.AsSpirvSpan()]);
    }

    public static Instruction AddOpExtInstImport(this SpirvBuffer buffer, IdResult resultId, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(name);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExtInstImport, ..resultId.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExtInstImport</c></para>
    /// <para>Import an extended set of instructions. It can be later referenced by the Result <c>id</c>.</para>
    /// <para>Name is the extended instruction-set’s name string. Before version 1.6, there must be an external specification defining the semantics for this extended instruction set. Starting with version 1.6, if Name starts with "NonSemantic.", including the period that separates the namespace "NonSemantic" from the rest of the name, it is encouraged for a specification to exist on the SPIR-V Registry, but it is not required.</para>
    /// <para>Starting with version 1.6, an extended instruction-set name which is prefixed with "NonSemantic." is guaranteed to contain only non-semantic instructions, and all OpExtInst instructions referencing this set can be ignored. All instructions within such a set must have only <c>id</c> operands; no literals. When literals are needed, then the Result <c>id</c> from an OpConstant or OpString instruction is referenced as appropriate. Result <c>id</c>s from these non-semantic instruction-set instructions must be used only in other non-semantic instructions.</para>
    /// <para>See Extended Instruction Sets for more information.</para>
    /// </summary>
    public static Instruction InsertOpExtInstImport(this SpirvBuffer buffer, int position, IdResult resultId, LiteralString name)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(name);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExtInstImport, ..resultId.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction AddOpExtInst(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef set, LiteralInteger instruction, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(set) + buffer.GetWordLength(instruction) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExtInst, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..set.AsSpirvSpan(), ..instruction.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExtInst</c></para>
    /// <para>Execute an instruction in an imported set of extended instructions.</para>
    /// <para>Result Type is defined, per Instruction, in the external specification for Set.</para>
    /// <para>Set is the result of an OpExtInstImport instruction.</para>
    /// <para>Instruction is the enumerant of the instruction to execute within Set. It is an unsigned 32-bit integer.  The semantics of the instruction are defined in the external specification for Set.</para>
    /// <para>Operand 1, …​ are the operands to the extended instruction.</para>
    /// </summary>
    public static Instruction InsertOpExtInst(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef set, LiteralInteger instruction, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(set) + buffer.GetWordLength(instruction) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExtInst, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..set.AsSpirvSpan(), ..instruction.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpMemoryModel(this SpirvBuffer buffer, AddressingModel addressingmodel, MemoryModel memorymodel)
    {
        var wordLength = 1 + buffer.GetWordLength(addressingmodel) + buffer.GetWordLength(memorymodel);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMemoryModel, ..addressingmodel.AsSpirvSpan(), ..memorymodel.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemoryModel</c></para>
    /// <para>Set addressing model and memory model for the entire module.</para>
    /// <para>Addressing Model selects the module’s Addressing Model.</para>
    /// <para>Memory Model selects the module’s memory model, see Memory Model.</para>
    /// </summary>
    public static Instruction InsertOpMemoryModel(this SpirvBuffer buffer, int position, AddressingModel addressingmodel, MemoryModel memorymodel)
    {
        var wordLength = 1 + buffer.GetWordLength(addressingmodel) + buffer.GetWordLength(memorymodel);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMemoryModel, ..addressingmodel.AsSpirvSpan(), ..memorymodel.AsSpirvSpan()]);
    }

    public static Instruction AddOpEntryPoint(this SpirvBuffer buffer, ExecutionModel executionmodel, IdRef entryPoint, LiteralString name, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(executionmodel) + buffer.GetWordLength(entryPoint) + buffer.GetWordLength(name) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpEntryPoint, ..executionmodel.AsSpirvSpan(), ..entryPoint.AsSpirvSpan(), ..name.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpEntryPoint</c></para>
    /// <para>Declare an entry point, its execution model, and its interface.</para>
    /// <para>Execution Model is the execution model for the entry point and its static call tree. See Execution Model.</para>
    /// <para>Entry Point must be the Result <c>id</c> of an OpFunction instruction.</para>
    /// <para>Name is a name string for the entry point. A module must not have two OpEntryPoint instructions with the same Execution Model and the same Name string.</para>
    /// <para>Interface is a list of <c>id</c> of global OpVariable instructions. These declare the set of global variables from a module that form the interface of this entry point. The set of Interface <c>id</c> must be equal to or a superset of the global OpVariable Result <c>id</c> referenced by the entry point’s static call tree, within the interface’s storage classes. Before version 1.4, the interface’s storage classes are limited to the Input and Output storage classes. Starting with version 1.4, the interface’s storage classes are all storage classes used in declaring all global variables referenced by the entry point’s call tree.</para>
    /// <para>Interface <c>id</c> are forward references. Before version 1.4, duplication of these <c>id</c> is tolerated. Starting with version 1.4, an <c>id</c> must not appear more than once.</para>
    /// </summary>
    public static Instruction InsertOpEntryPoint(this SpirvBuffer buffer, int position, ExecutionModel executionmodel, IdRef entryPoint, LiteralString name, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(executionmodel) + buffer.GetWordLength(entryPoint) + buffer.GetWordLength(name) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpEntryPoint, ..executionmodel.AsSpirvSpan(), ..entryPoint.AsSpirvSpan(), ..name.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpExecutionMode(this SpirvBuffer buffer, IdRef entryPoint, ExecutionMode mode)
    {
        var wordLength = 1 + buffer.GetWordLength(entryPoint) + buffer.GetWordLength(mode);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExecutionMode, ..entryPoint.AsSpirvSpan(), ..mode.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExecutionMode</c></para>
    /// <para>Declare an execution mode for an entry point.</para>
    /// <para>Entry Point must be the Entry Point <c>id</c> operand of an OpEntryPoint instruction.</para>
    /// <para>Mode is the execution mode. See Execution Mode.</para>
    /// <para>This instruction is only valid if the Mode operand is an execution mode that takes no Extra Operands, or takes Extra Operands that are not <c>id</c> operands.</para>
    /// </summary>
    public static Instruction InsertOpExecutionMode(this SpirvBuffer buffer, int position, IdRef entryPoint, ExecutionMode mode)
    {
        var wordLength = 1 + buffer.GetWordLength(entryPoint) + buffer.GetWordLength(mode);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExecutionMode, ..entryPoint.AsSpirvSpan(), ..mode.AsSpirvSpan()]);
    }

    public static Instruction AddOpCapability(this SpirvBuffer buffer, Capability capability)
    {
        var wordLength = 1 + buffer.GetWordLength(capability);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCapability, ..capability.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCapability</c></para>
    /// <para>Declare a capability used by this module.</para>
    /// <para>Capability is the capability declared by this instruction.  There are no restrictions on the order in which capabilities are declared.</para>
    /// <para>See the capabilities section for more detail.</para>
    /// </summary>
    public static Instruction InsertOpCapability(this SpirvBuffer buffer, int position, Capability capability)
    {
        var wordLength = 1 + buffer.GetWordLength(capability);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCapability, ..capability.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeVoid(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeVoid, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeVoid</c></para>
    /// <para>Declare the void type.</para>
    /// </summary>
    public static Instruction InsertOpTypeVoid(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeVoid, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeBool(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeBool, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeBool</c></para>
    /// <para>Declare the Boolean type.  Values of this type can only be either true or false. There is no physical size or bit pattern defined for these values.  If they are stored (in conjunction with OpVariable), they must only be used with logical addressing operations, not physical, and only with non-externally visible shader storage classes: UniformConstant, Workgroup, CrossWorkgroup, Private, Function, Input, and Output.</para>
    /// </summary>
    public static Instruction InsertOpTypeBool(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeBool, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeInt(this SpirvBuffer buffer, IdResult resultId, LiteralInteger width, LiteralInteger signedness)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(width) + buffer.GetWordLength(signedness);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeInt, ..resultId.AsSpirvSpan(), ..width.AsSpirvSpan(), ..signedness.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeInt</c></para>
    /// <para>Declare a new integer type.</para>
    /// <para>Width specifies how many bits wide the type is. Width is an unsigned 32-bit integer.  The bit pattern of a signed integer value is two’s complement.</para>
    /// <para>Signedness specifies whether there are signed semantics to preserve or validate.</para>
    /// <para>0 indicates unsigned, or no signedness semantics</para>
    /// <para>1 indicates signed semantics.</para>
    /// <para>In all cases, the type of operation of an instruction comes from the instruction’s opcode, not the signedness of the operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeInt(this SpirvBuffer buffer, int position, IdResult resultId, LiteralInteger width, LiteralInteger signedness)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(width) + buffer.GetWordLength(signedness);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeInt, ..resultId.AsSpirvSpan(), ..width.AsSpirvSpan(), ..signedness.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeFloat(this SpirvBuffer buffer, IdResult resultId, LiteralInteger width, FPEncoding? floatingPointEncoding)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(width) + buffer.GetWordLength(floatingPointEncoding);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeFloat, ..resultId.AsSpirvSpan(), ..width.AsSpirvSpan(), ..floatingPointEncoding.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeFloat</c></para>
    /// <para>Declare a new floating-point type.</para>
    /// <para>Width specifies how many bits wide the type is. Width is an unsigned 32-bit integer. </para>
    /// <para>Floating Point Encoding specifies the bit pattern of values.</para>
    /// <para>Unless Floating Point Encoding is present, the bit pattern of a floating-point value is the binary format described by the IEEE 754 encoding for the specified Width.</para>
    /// </summary>
    public static Instruction InsertOpTypeFloat(this SpirvBuffer buffer, int position, IdResult resultId, LiteralInteger width, FPEncoding? floatingPointEncoding)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(width) + buffer.GetWordLength(floatingPointEncoding);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeFloat, ..resultId.AsSpirvSpan(), ..width.AsSpirvSpan(), ..floatingPointEncoding.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeVector(this SpirvBuffer buffer, IdResult resultId, IdRef componentType, LiteralInteger componentCount)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(componentType) + buffer.GetWordLength(componentCount);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeVector, ..resultId.AsSpirvSpan(), ..componentType.AsSpirvSpan(), ..componentCount.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeVector</c></para>
    /// <para>Declare a new vector type.</para>
    /// <para>Component Type is the type of each component in the resulting type.  It must be a scalar type.</para>
    /// <para>Component Count is the number of components in the resulting type. Component Count is an unsigned 32-bit integer.  It must be at least 2.</para>
    /// <para>Components are numbered consecutively, starting with 0.</para>
    /// </summary>
    public static Instruction InsertOpTypeVector(this SpirvBuffer buffer, int position, IdResult resultId, IdRef componentType, LiteralInteger componentCount)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(componentType) + buffer.GetWordLength(componentCount);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeVector, ..resultId.AsSpirvSpan(), ..componentType.AsSpirvSpan(), ..componentCount.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeMatrix(this SpirvBuffer buffer, IdResult resultId, IdRef columnType, LiteralInteger columnCount)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(columnType) + buffer.GetWordLength(columnCount);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeMatrix, ..resultId.AsSpirvSpan(), ..columnType.AsSpirvSpan(), ..columnCount.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeMatrix</c></para>
    /// <para>Declare a new matrix type.</para>
    /// <para>Column Type is the type of each column in the matrix.  It must be vector type.</para>
    /// <para>Column Count is the number of columns in the new matrix type. Column Count is an unsigned 32-bit integer.  It must be at least 2.</para>
    /// <para>Matrix columns are numbered consecutively, starting with 0. This is true independently of any Decorations describing the memory layout of a matrix (e.g., RowMajor or MatrixStride).</para>
    /// </summary>
    public static Instruction InsertOpTypeMatrix(this SpirvBuffer buffer, int position, IdResult resultId, IdRef columnType, LiteralInteger columnCount)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(columnType) + buffer.GetWordLength(columnCount);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeMatrix, ..resultId.AsSpirvSpan(), ..columnType.AsSpirvSpan(), ..columnCount.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeImage(this SpirvBuffer buffer, IdResult resultId, IdRef sampledType, Dim dim, LiteralInteger depth, LiteralInteger arrayed, LiteralInteger mS, LiteralInteger sampled, ImageFormat imageformat, AccessQualifier? accessqualifier)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledType) + buffer.GetWordLength(dim) + buffer.GetWordLength(depth) + buffer.GetWordLength(arrayed) + buffer.GetWordLength(mS) + buffer.GetWordLength(sampled) + buffer.GetWordLength(imageformat) + buffer.GetWordLength(accessqualifier);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeImage, ..resultId.AsSpirvSpan(), ..sampledType.AsSpirvSpan(), ..dim.AsSpirvSpan(), ..depth.AsSpirvSpan(), ..arrayed.AsSpirvSpan(), ..mS.AsSpirvSpan(), ..sampled.AsSpirvSpan(), ..imageformat.AsSpirvSpan(), ..accessqualifier.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeImage</c></para>
    /// <para>Declare a new image type. Consumed, for example, by OpTypeSampledImage. This type is opaque: values of this type have no defined physical size or bit pattern.</para>
    /// <para>Sampled Type is the type of the components that result from sampling or reading from this image type. Must be a scalar numerical type or OpTypeVoid.</para>
    /// <para>Dim is the image dimensionality (Dim).</para>
    /// <para>All the following literals are integers taking one operand each.</para>
    /// <para>Depth is whether or not this image is a depth image. (Note that whether or not depth comparisons are actually done is a property of the sampling opcode, not of this type declaration.)</para>
    /// <para>0 indicates not a depth image</para>
    /// <para>1 indicates a depth image</para>
    /// <para>2 means no indication as to whether this is a depth or non-depth image</para>
    /// <para>Arrayed must be one of the following indicated values:</para>
    /// <para>0 indicates non-arrayed content</para>
    /// <para>1 indicates arrayed content</para>
    /// <para>MS must be one of the following indicated values:</para>
    /// <para>0 indicates single-sampled content</para>
    /// <para>1 indicates multisampled content</para>
    /// <para>Sampled indicates whether or not this image is accessed in combination with a sampler, and must be one of the following values:</para>
    /// <para>0 indicates this is only known at run time, not at compile time</para>
    /// <para>1 indicates an image compatible with sampling operations</para>
    /// <para>2 indicates an image compatible with read/write operations (a storage or subpass data image).</para>
    /// <para>Image Format is the Image Format, which can be Unknown, as specified by the client API.</para>
    /// <para>If Dim is SubpassData, Sampled must be 2, Image Format must be Unknown, and the Execution Model must be Fragment.</para>
    /// <para>Access Qualifier is an image Access Qualifier.</para>
    /// </summary>
    public static Instruction InsertOpTypeImage(this SpirvBuffer buffer, int position, IdResult resultId, IdRef sampledType, Dim dim, LiteralInteger depth, LiteralInteger arrayed, LiteralInteger mS, LiteralInteger sampled, ImageFormat imageformat, AccessQualifier? accessqualifier)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledType) + buffer.GetWordLength(dim) + buffer.GetWordLength(depth) + buffer.GetWordLength(arrayed) + buffer.GetWordLength(mS) + buffer.GetWordLength(sampled) + buffer.GetWordLength(imageformat) + buffer.GetWordLength(accessqualifier);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeImage, ..resultId.AsSpirvSpan(), ..sampledType.AsSpirvSpan(), ..dim.AsSpirvSpan(), ..depth.AsSpirvSpan(), ..arrayed.AsSpirvSpan(), ..mS.AsSpirvSpan(), ..sampled.AsSpirvSpan(), ..imageformat.AsSpirvSpan(), ..accessqualifier.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeSampler(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeSampler, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeSampler</c></para>
    /// <para>Declare the sampler type. Consumed by OpSampledImage. This type is opaque: values of this type have no defined physical size or bit pattern.</para>
    /// </summary>
    public static Instruction InsertOpTypeSampler(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeSampler, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeSampledImage(this SpirvBuffer buffer, IdResult resultId, IdRef imageType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(imageType);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeSampledImage, ..resultId.AsSpirvSpan(), ..imageType.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeSampledImage</c></para>
    /// <para>Declare a sampled image type, the Result Type of OpSampledImage, or an externally combined sampler and image. This type is opaque: values of this type have no defined physical size or bit pattern.</para>
    /// <para>Image Type must be an OpTypeImage.  It is the type of the image in the combined sampler and image type. It must not have a Dim of SubpassData. Additionally, starting with version 1.6, it must not have a Dim of Buffer.</para>
    /// </summary>
    public static Instruction InsertOpTypeSampledImage(this SpirvBuffer buffer, int position, IdResult resultId, IdRef imageType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(imageType);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeSampledImage, ..resultId.AsSpirvSpan(), ..imageType.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeArray(this SpirvBuffer buffer, IdResult resultId, IdRef elementType, IdRef length)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(elementType) + buffer.GetWordLength(length);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeArray, ..resultId.AsSpirvSpan(), ..elementType.AsSpirvSpan(), ..length.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeArray</c></para>
    /// <para>Declare a new array type.</para>
    /// <para>Element Type is the type of each element in the array.</para>
    /// <para>Length is the number of elements in the array.  It must be at least 1. Length must come from a constant instruction of an integer-type scalar whose value is at least 1.</para>
    /// <para>Array elements are numbered consecutively, starting with 0.</para>
    /// </summary>
    public static Instruction InsertOpTypeArray(this SpirvBuffer buffer, int position, IdResult resultId, IdRef elementType, IdRef length)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(elementType) + buffer.GetWordLength(length);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeArray, ..resultId.AsSpirvSpan(), ..elementType.AsSpirvSpan(), ..length.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeRuntimeArray(this SpirvBuffer buffer, IdResult resultId, IdRef elementType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(elementType);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeRuntimeArray, ..resultId.AsSpirvSpan(), ..elementType.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeRuntimeArray</c></para>
    /// <para>Declare a new run-time array type.  Its length is not known at compile time.</para>
    /// <para>Element Type is the type of each element in the array.</para>
    /// <para> See OpArrayLength for getting the Length of an array of this type.</para>
    /// </summary>
    public static Instruction InsertOpTypeRuntimeArray(this SpirvBuffer buffer, int position, IdResult resultId, IdRef elementType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(elementType);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeRuntimeArray, ..resultId.AsSpirvSpan(), ..elementType.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeStruct(this SpirvBuffer buffer, IdResult resultId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeStruct, ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeStruct</c></para>
    /// <para>Declare a new structure type.</para>
    /// <para>Member N type is the type of member N of the structure. The first member is member 0, the next is member 1, …​ It is valid for the structure to have no members.</para>
    /// <para>If an operand is not yet defined, it must be defined by an OpTypePointer, where the type pointed to is an OpTypeStruct.</para>
    /// </summary>
    public static Instruction InsertOpTypeStruct(this SpirvBuffer buffer, int position, IdResult resultId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeStruct, ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeOpaque(this SpirvBuffer buffer, IdResult resultId, LiteralString thenameoftheopaquetype)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(thenameoftheopaquetype);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeOpaque, ..resultId.AsSpirvSpan(), ..thenameoftheopaquetype.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeOpaque</c></para>
    /// <para>Declare a structure type with no body specified.</para>
    /// </summary>
    public static Instruction InsertOpTypeOpaque(this SpirvBuffer buffer, int position, IdResult resultId, LiteralString thenameoftheopaquetype)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(thenameoftheopaquetype);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeOpaque, ..resultId.AsSpirvSpan(), ..thenameoftheopaquetype.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypePointer(this SpirvBuffer buffer, IdResult resultId, StorageClass storageclass, IdRef type)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(type);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypePointer, ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..type.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypePointer</c></para>
    /// <para>Declare a new pointer type.</para>
    /// <para>Storage Class is the Storage Class of the memory holding the object pointed to. If there was a forward reference to this type from an OpTypeForwardPointer, the Storage Class of that instruction must equal the Storage Class of this instruction.</para>
    /// <para>Type is the type of the object pointed to.</para>
    /// </summary>
    public static Instruction InsertOpTypePointer(this SpirvBuffer buffer, int position, IdResult resultId, StorageClass storageclass, IdRef type)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(type);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypePointer, ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..type.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeFunction(this SpirvBuffer buffer, IdResult resultId, IdRef returnType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(returnType) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeFunction, ..resultId.AsSpirvSpan(), ..returnType.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeFunction</c></para>
    /// <para>Declare a new function type.</para>
    /// <para>OpFunction uses this to declare the return type and parameter types of a function.</para>
    /// <para>Return Type is the type of the return value of functions of this type. It must be a concrete or abstract type, or a pointer to such a type. If the function has no return value, Return Type must be OpTypeVoid.</para>
    /// <para>Parameter N Type is the type <c>id</c> of the type of parameter N. It must not be OpTypeVoid</para>
    /// </summary>
    public static Instruction InsertOpTypeFunction(this SpirvBuffer buffer, int position, IdResult resultId, IdRef returnType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(returnType) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeFunction, ..resultId.AsSpirvSpan(), ..returnType.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeEvent(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeEvent, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeEvent</c></para>
    /// <para>Declare an OpenCL event type.</para>
    /// </summary>
    public static Instruction InsertOpTypeEvent(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeEvent, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeDeviceEvent(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeDeviceEvent, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeDeviceEvent</c></para>
    /// <para>Declare an OpenCL device-side event type.</para>
    /// </summary>
    public static Instruction InsertOpTypeDeviceEvent(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeDeviceEvent, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeReserveId(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeReserveId, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeReserveId</c></para>
    /// <para>Declare an OpenCL reservation id type.</para>
    /// </summary>
    public static Instruction InsertOpTypeReserveId(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeReserveId, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeQueue(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeQueue, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeQueue</c></para>
    /// <para>Declare an OpenCL queue type.</para>
    /// </summary>
    public static Instruction InsertOpTypeQueue(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeQueue, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypePipe(this SpirvBuffer buffer, IdResult resultId, AccessQualifier qualifier)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(qualifier);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypePipe, ..resultId.AsSpirvSpan(), ..qualifier.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypePipe</c></para>
    /// <para>Declare an OpenCL pipe type.</para>
    /// <para>Qualifier is the pipe access qualifier.</para>
    /// </summary>
    public static Instruction InsertOpTypePipe(this SpirvBuffer buffer, int position, IdResult resultId, AccessQualifier qualifier)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(qualifier);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypePipe, ..resultId.AsSpirvSpan(), ..qualifier.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeForwardPointer(this SpirvBuffer buffer, IdRef pointerType, StorageClass storageclass)
    {
        var wordLength = 1 + buffer.GetWordLength(pointerType) + buffer.GetWordLength(storageclass);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeForwardPointer, ..pointerType.AsSpirvSpan(), ..storageclass.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeForwardPointer</c></para>
    /// <para>Declare the storage class for a forward reference to a pointer.</para>
    /// <para>Pointer Type is a forward reference to the result of an OpTypePointer. That OpTypePointer instruction must declare Pointer Type to be a pointer to an OpTypeStruct. Any consumption of Pointer Type before its OpTypePointer declaration must be a type-declaration instruction.</para>
    /// <para>Storage Class is the Storage Class of the memory holding the object pointed to.</para>
    /// </summary>
    public static Instruction InsertOpTypeForwardPointer(this SpirvBuffer buffer, int position, IdRef pointerType, StorageClass storageclass)
    {
        var wordLength = 1 + buffer.GetWordLength(pointerType) + buffer.GetWordLength(storageclass);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeForwardPointer, ..pointerType.AsSpirvSpan(), ..storageclass.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantTrue(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantTrue, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantTrue</c></para>
    /// <para>Declare a true Boolean-type scalar constant.</para>
    /// <para>Result Type must be the scalar Boolean type.</para>
    /// </summary>
    public static Instruction InsertOpConstantTrue(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantTrue, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantFalse(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantFalse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantFalse</c></para>
    /// <para>Declare a false Boolean-type scalar constant.</para>
    /// <para>Result Type must be the scalar Boolean type.</para>
    /// </summary>
    public static Instruction InsertOpConstantFalse(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantFalse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstant</c></para>
    /// <para>Declare a new integer-type or floating-point-type scalar constant.</para>
    /// <para>Result Type must be a scalar integer type or floating-point type.</para>
    /// <para>Value is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.</para>
    /// </summary>
    public static Instruction AddOpConstant<TValue>(this SpirvBuffer buffer, IdResult resultId, IdResultType? resultType, TValue value)
        where TValue : struct, ILiteralNumber
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + value.WordCount;
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstant, ..resultType.AsSpirvSpan(), resultId, ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstant</c></para>
    /// <para>Declare a new integer-type or floating-point-type scalar constant.</para>
    /// <para>Result Type must be a scalar integer type or floating-point type.</para>
    /// <para>Value is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.</para>
    /// </summary>
    public static Instruction InsertOpConstant<TValue>(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType? resultType, TValue value)
        where TValue : struct, ILiteralNumber
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + value.WordCount;
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstant, ..resultType.AsSpirvSpan(), resultId, ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantComposite(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantComposite, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantComposite</c></para>
    /// <para>Declare a new composite constant.</para>
    /// <para>Result Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the Constituents. The ordering must be the same between the top-level types in Result Type and the Constituents.</para>
    /// <para>Constituents become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the Result Type. The Constituents must all be <c>id</c>s of non-specialization constant-instruction declarations or an OpUndef.</para>
    /// </summary>
    public static Instruction InsertOpConstantComposite(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantComposite, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantSampler(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, SamplerAddressingMode sampleraddressingmode, LiteralInteger param, SamplerFilterMode samplerfiltermode)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampleraddressingmode) + buffer.GetWordLength(param) + buffer.GetWordLength(samplerfiltermode);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantSampler, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampleraddressingmode.AsSpirvSpan(), ..param.AsSpirvSpan(), ..samplerfiltermode.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantSampler</c></para>
    /// <para>Declare a new sampler constant.</para>
    /// <para>Result Type must be OpTypeSampler.</para>
    /// <para>Sampler Addressing Mode is the addressing mode; a literal from Sampler Addressing Mode.</para>
    /// <para>Param is a 32-bit integer and is one of:</para>
    /// <para>0: Non Normalized</para>
    /// <para>1: Normalized</para>
    /// <para>Sampler Filter Mode is the filter mode; a literal from Sampler Filter Mode.</para>
    /// </summary>
    public static Instruction InsertOpConstantSampler(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, SamplerAddressingMode sampleraddressingmode, LiteralInteger param, SamplerFilterMode samplerfiltermode)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampleraddressingmode) + buffer.GetWordLength(param) + buffer.GetWordLength(samplerfiltermode);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantSampler, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampleraddressingmode.AsSpirvSpan(), ..param.AsSpirvSpan(), ..samplerfiltermode.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantNull(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantNull, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantNull</c></para>
    /// <para>Declare a new null constant value.</para>
    /// <para>The null value is type dependent, defined as follows:</para>
    /// <para> -  Scalar Boolean: false</para>
    /// <para> -  Scalar integer: 0</para>
    /// <para> -  Scalar floating point: +0.0 (all bits 0)</para>
    /// <para> -  All other scalars: Abstract</para>
    /// <para> -  Composites: Members are set recursively to the null constant according to the null value of their constituent types.</para>
    /// <para>Result Type must be one of the following types:</para>
    /// <para> -  Scalar or vector Boolean type</para>
    /// <para> -  Scalar or vector integer type</para>
    /// <para> -  Scalar or vector floating-point type</para>
    /// <para> -  Pointer type</para>
    /// <para> -  Event type</para>
    /// <para> -  Device side event type</para>
    /// <para> -  Reservation id type</para>
    /// <para> -  Queue type</para>
    /// <para> -  Composite type</para>
    /// </summary>
    public static Instruction InsertOpConstantNull(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantNull, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSpecConstantTrue(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSpecConstantTrue, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSpecConstantTrue</c></para>
    /// <para>Declare a Boolean-type scalar specialization constant with a default value of true.</para>
    /// <para>This instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.</para>
    /// <para>Result Type must be the scalar Boolean type.</para>
    /// <para>See Specialization.</para>
    /// </summary>
    public static Instruction InsertOpSpecConstantTrue(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSpecConstantTrue, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSpecConstantFalse(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSpecConstantFalse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSpecConstantFalse</c></para>
    /// <para>Declare a Boolean-type scalar specialization constant with a default value of false.</para>
    /// <para>This instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.</para>
    /// <para>Result Type must be the scalar Boolean type.</para>
    /// <para>See Specialization.</para>
    /// </summary>
    public static Instruction InsertOpSpecConstantFalse(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSpecConstantFalse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSpecConstant<TValue>(this SpirvBuffer buffer, IdResult resultId, IdResultType? resultType, TValue value)
        where TValue : struct, ILiteralNumber
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + value.WordCount;
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSpecConstant, ..resultType.AsSpirvSpan(), resultId, ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSpecConstant</c></para>
    /// <para>Declare a new integer-type or floating-point-type scalar specialization constant.</para>
    /// <para>Result Type must be a scalar integer type or floating-point type.</para>
    /// <para>Value is the bit pattern for the default value of the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.</para>
    /// <para>This instruction can be specialized to become an OpConstant instruction.</para>
    /// <para>See Specialization.</para>
    /// </summary>
    public static Instruction InsertOpSpecConstant<TValue>(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType? resultType, TValue value)
        where TValue : struct, ILiteralNumber
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + value.WordCount;
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSpecConstant, ..resultType.AsSpirvSpan(), resultId, ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpSpecConstantComposite(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSpecConstantComposite, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSpecConstantComposite</c></para>
    /// <para>Declare a new composite specialization constant.</para>
    /// <para>Result Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the Constituents. The ordering must be the same between the top-level types in Result Type and the Constituents.</para>
    /// <para>Constituents become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the type of the result. The Constituents must be the <c>id</c> of other specialization constants, constant declarations, or an OpUndef.</para>
    /// <para>This instruction will be specialized to an OpConstantComposite instruction.</para>
    /// <para>See Specialization.</para>
    /// </summary>
    public static Instruction InsertOpSpecConstantComposite(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSpecConstantComposite, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpSpecConstantOp(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, Op opcode)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(opcode);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSpecConstantOp, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..opcode.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSpecConstantOp</c></para>
    /// <para>Declare a new specialization constant that results from doing an operation.</para>
    /// <para>Result Type must be the type required by the Result Type of Opcode.</para>
    /// <para> Opcode is an unsigned 32-bit integer. It must equal one of the following opcodes.</para>
    /// <para>OpSConvert, OpUConvert (missing before version 1.4), OpFConvert</para>
    /// <para>OpSNegate, OpNot, OpIAdd, OpISub</para>
    /// <para>OpIMul, OpUDiv, OpSDiv, OpUMod, OpSRem, OpSMod</para>
    /// <para>OpShiftRightLogical, OpShiftRightArithmetic, OpShiftLeftLogical</para>
    /// <para>OpBitwiseOr, OpBitwiseXor, OpBitwiseAnd</para>
    /// <para>OpVectorShuffle, OpCompositeExtract, OpCompositeInsert</para>
    /// <para>OpLogicalOr, OpLogicalAnd, OpLogicalNot,</para>
    /// <para>OpLogicalEqual, OpLogicalNotEqual</para>
    /// <para>OpSelect</para>
    /// <para>OpIEqual, OpINotEqual</para>
    /// <para>OpULessThan, OpSLessThan</para>
    /// <para>OpUGreaterThan, OpSGreaterThan</para>
    /// <para>OpULessThanEqual, OpSLessThanEqual</para>
    /// <para>OpUGreaterThanEqual, OpSGreaterThanEqual</para>
    /// <para>If the Shader capability was declared, OpQuantizeToF16 is also valid.</para>
    /// <para>If the Kernel capability was declared, the following opcodes are also valid:</para>
    /// <para>OpConvertFToS, OpConvertSToF</para>
    /// <para>OpConvertFToU, OpConvertUToF</para>
    /// <para>OpUConvert, OpConvertPtrToU, OpConvertUToPtr</para>
    /// <para>OpGenericCastToPtr, OpPtrCastToGeneric, OpBitcast</para>
    /// <para>OpFNegate, OpFAdd, OpFSub, OpFMul, OpFDiv, OpFRem, OpFMod</para>
    /// <para>OpAccessChain, OpInBoundsAccessChain</para>
    /// <para>OpPtrAccessChain, OpInBoundsPtrAccessChain</para>
    /// <para>Operands are the operands required by opcode, and satisfy the semantics of opcode. In addition, all Operands that are <c>id</c>s must be either:</para>
    /// <para> - the <c>id</c>s of other constant instructions, or</para>
    /// <para> - OpUndef, when allowed by opcode, or</para>
    /// <para> - for the AccessChain named opcodes, their Base is allowed to be a global (module scope) OpVariable instruction.</para>
    /// <para>See Specialization.</para>
    /// </summary>
    public static Instruction InsertOpSpecConstantOp(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, Op opcode)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(opcode);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSpecConstantOp, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..opcode.AsSpirvSpan()]);
    }

    public static Instruction AddOpFunction(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, FunctionControlMask functioncontrol, IdRef functionType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(functioncontrol) + buffer.GetWordLength(functionType);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFunction, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..functioncontrol.AsSpirvSpan(), ..functionType.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFunction</c></para>
    /// <para>Add a function.  This instruction must be immediately followed by one OpFunctionParameter instruction per each formal parameter of this function. This function’s body or declaration terminates with the next OpFunctionEnd instruction.</para>
    /// <para>Result Type must be the same as the Return Type declared in Function Type.</para>
    /// <para>Function Type is the result of an OpTypeFunction, which declares the types of the return value and parameters of the function.</para>
    /// </summary>
    public static Instruction InsertOpFunction(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, FunctionControlMask functioncontrol, IdRef functionType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(functioncontrol) + buffer.GetWordLength(functionType);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFunction, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..functioncontrol.AsSpirvSpan(), ..functionType.AsSpirvSpan()]);
    }

    public static Instruction AddOpFunctionParameter(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFunctionParameter, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFunctionParameter</c></para>
    /// <para>Declare a formal parameter of the current function.</para>
    /// <para>Result Type is the type of the parameter.</para>
    /// <para>This instruction must immediately follow an OpFunction or OpFunctionParameter instruction. The order of contiguous OpFunctionParameter instructions is the same order arguments are listed in an OpFunctionCall instruction to this function. It is also the same order in which Parameter Type operands are listed in the OpTypeFunction of the Function Type operand for this function’s OpFunction instruction.</para>
    /// </summary>
    public static Instruction InsertOpFunctionParameter(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFunctionParameter, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpFunctionEnd(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpFunctionEnd]);
    }

    /// <summary>
    /// <para><c>OpFunctionEnd</c></para>
    /// <para>Last instruction of a function.</para>
    /// </summary>
    public static Instruction InsertOpFunctionEnd(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpFunctionEnd]);
    }

    public static Instruction AddOpFunctionCall(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef function, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(function) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFunctionCall, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..function.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFunctionCall</c></para>
    /// <para>Call a function.</para>
    /// <para>Result Type is the type of the return value of the function. It must be the same as the Return Type operand of the Function Type operand of the Function operand.</para>
    /// <para>Function is an OpFunction instruction.  This could be a forward reference.</para>
    /// <para>Argument N is the object to copy to parameter N of Function.</para>
    /// <para>Note: A forward call is possible because there is no missing type information: Result Type must match the Return Type of the function, and the calling argument types must match the formal parameter types.</para>
    /// </summary>
    public static Instruction InsertOpFunctionCall(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef function, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(function) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFunctionCall, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..function.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpVariable(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, StorageClass storageclass, IdRef? initializer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(initializer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpVariable, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..initializer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpVariable</c></para>
    /// <para>Allocate an object in memory, resulting in a pointer to it, which can be used with OpLoad and OpStore.</para>
    /// <para> Result Type must be an OpTypePointer. Its Type operand is the type of object in memory.</para>
    /// <para>Storage Class is the Storage Class of the memory holding the object. It must not be Generic. It must be the same as the Storage Class operand of the Result Type. If Storage Class is Function, the memory is allocated on execution of the instruction for the current invocation for each dynamic instance of the function. The current invocation’s memory is deallocated when it executes any function termination instruction of the dynamic instance of the function it was allocated by.</para>
    /// <para>Initializer is optional.  If Initializer is present, it will be the initial value of the variable’s memory content. Initializer must be an <c>id</c> from a constant instruction or a global (module scope) OpVariable instruction. Initializer must have the same type as the type pointed to by Result Type.</para>
    /// </summary>
    public static Instruction InsertOpVariable(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, StorageClass storageclass, IdRef? initializer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(initializer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpVariable, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..initializer.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageTexelPointer(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, IdRef sample)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(sample);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageTexelPointer, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..sample.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageTexelPointer</c></para>
    /// <para>Form a pointer to a texel of an image. Use of such a pointer is limited to atomic operations.</para>
    /// <para>Result Type must be an OpTypePointer whose Storage Class operand is Image. Its Type operand must be a scalar numerical type or OpTypeVoid.</para>
    /// <para>Image must have a type of OpTypePointer with Type OpTypeImage. The Sampled Type of the type of Image must be the same as the Type pointed to by Result Type. The Dim operand of Type must not be SubpassData.</para>
    /// <para>Coordinate and Sample specify which texel and sample within the image to form a pointer to.</para>
    /// <para>Coordinate must be a scalar or vector of integer type.  It must have the number of components specified below, given the following Arrayed and Dim operands of the type of the OpTypeImage.</para>
    /// <para>If Arrayed is 0:</para>
    /// <para>1D: scalar</para>
    /// <para>2D: 2 components</para>
    /// <para>3D: 3 components</para>
    /// <para>Cube: 3 components</para>
    /// <para>Rect: 2 components</para>
    /// <para>Buffer: scalar</para>
    /// <para>If Arrayed is 1:</para>
    /// <para>1D: 2 components</para>
    /// <para>2D: 3 components</para>
    /// <para>Cube: 3 components; the face and layer combine into the 3rd component, layer_face, such that face is layer_face % 6 and layer is floor(layer_face / 6)</para>
    /// <para>Sample must be an integer type scalar. It specifies which sample to select at the given coordinate. Behavior is undefined unless it is a valid <c>id</c> for the value 0 when the OpTypeImage has MS of 0.</para>
    /// </summary>
    public static Instruction InsertOpImageTexelPointer(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, IdRef sample)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(sample);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageTexelPointer, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..sample.AsSpirvSpan()]);
    }

    public static Instruction AddOpLoad(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memoryaccess);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLoad, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoad</c></para>
    /// <para>Load through a pointer.</para>
    /// <para>Result Type is the type of the loaded object. It must be a type with fixed size; i.e., it must not be, nor include, any OpTypeRuntimeArray types.</para>
    /// <para>Pointer is the pointer to load through.  Its type must be an OpTypePointer whose Type operand is the same as Result Type.</para>
    /// <para>If present, any Memory Operands must begin with a memory operand literal. If not present, it is the same as specifying the memory operand None.</para>
    /// </summary>
    public static Instruction InsertOpLoad(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memoryaccess);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLoad, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    public static Instruction AddOpStore(this SpirvBuffer buffer, IdRef pointer, IdRef objectId, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(memoryaccess);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpStore, ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpStore</c></para>
    /// <para>Store through a pointer.</para>
    /// <para>Pointer is the pointer to store through.  Its type must be an OpTypePointer whose Type operand is the same as the type of Object.</para>
    /// <para>Object is the object to store.</para>
    /// <para>If present, any Memory Operands must begin with a memory operand literal. If not present, it is the same as specifying the memory operand None.</para>
    /// </summary>
    public static Instruction InsertOpStore(this SpirvBuffer buffer, int position, IdRef pointer, IdRef objectId, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(memoryaccess);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpStore, ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    public static Instruction AddOpCopyMemory(this SpirvBuffer buffer, IdRef target, IdRef source, MemoryAccessMask? memoryaccess, MemoryAccessMask? memoryaccess1)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(source) + buffer.GetWordLength(memoryaccess) + buffer.GetWordLength(memoryaccess1);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCopyMemory, ..target.AsSpirvSpan(), ..source.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan(), ..memoryaccess1.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCopyMemory</c></para>
    /// <para>Copy from the memory pointed to by Source to the memory pointed to by Target. Both operands must be non-void pointers and having the same <c>id</c> Type operand in their OpTypePointer type declaration.  Matching Storage Class is not required.  The amount of memory copied is the size of the type pointed to. The copied type must have a fixed size; i.e., it must not be, nor include, any OpTypeRuntimeArray types.</para>
    /// <para>If present, any Memory Operands must begin with a memory operand literal. If not present, it is the same as specifying the memory operand None. Before version 1.4, at most one memory operands mask can be provided. Starting with version 1.4 two masks can be provided, as described in Memory Operands. If no masks or only one mask is present, it applies to both Source and Target. If two masks are present, the first applies to Target and must not include MakePointerVisible, and the second applies to Source and must not include MakePointerAvailable.</para>
    /// </summary>
    public static Instruction InsertOpCopyMemory(this SpirvBuffer buffer, int position, IdRef target, IdRef source, MemoryAccessMask? memoryaccess, MemoryAccessMask? memoryaccess1)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(source) + buffer.GetWordLength(memoryaccess) + buffer.GetWordLength(memoryaccess1);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCopyMemory, ..target.AsSpirvSpan(), ..source.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan(), ..memoryaccess1.AsSpirvSpan()]);
    }

    public static Instruction AddOpCopyMemorySized(this SpirvBuffer buffer, IdRef target, IdRef source, IdRef size, MemoryAccessMask? memoryaccess, MemoryAccessMask? memoryaccess1)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(source) + buffer.GetWordLength(size) + buffer.GetWordLength(memoryaccess) + buffer.GetWordLength(memoryaccess1);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCopyMemorySized, ..target.AsSpirvSpan(), ..source.AsSpirvSpan(), ..size.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan(), ..memoryaccess1.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCopyMemorySized</c></para>
    /// <para>Copy from the memory pointed to by Source to the memory pointed to by Target. </para>
    /// <para>Size is the number of bytes to copy. It must have a scalar integer type. If it is a constant instruction, the constant value must not be 0. It is invalid for both the constant’s type to have Signedness of 1 and to have the sign bit set. Otherwise, as a run-time value, Size is treated as unsigned, and if its value is 0, no memory access is made.</para>
    /// <para>If present, any Memory Operands must begin with a memory operand literal. If not present, it is the same as specifying the memory operand None. Before version 1.4, at most one memory operands mask can be provided. Starting with version 1.4 two masks can be provided, as described in Memory Operands. If no masks or only one mask is present, it applies to both Source and Target. If two masks are present, the first applies to Target and must not include MakePointerVisible, and the second applies to Source and must not include MakePointerAvailable.</para>
    /// </summary>
    public static Instruction InsertOpCopyMemorySized(this SpirvBuffer buffer, int position, IdRef target, IdRef source, IdRef size, MemoryAccessMask? memoryaccess, MemoryAccessMask? memoryaccess1)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(source) + buffer.GetWordLength(size) + buffer.GetWordLength(memoryaccess) + buffer.GetWordLength(memoryaccess1);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCopyMemorySized, ..target.AsSpirvSpan(), ..source.AsSpirvSpan(), ..size.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan(), ..memoryaccess1.AsSpirvSpan()]);
    }

    public static Instruction AddOpAccessChain(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAccessChain, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAccessChain</c></para>
    /// <para>Create a pointer into a composite object. </para>
    /// <para> Result Type must be an OpTypePointer. Its Type operand must be the type reached by walking the Base’s type hierarchy down to the last provided index in Indexes, and its Storage Class operand must be the same as the Storage Class of Base.</para>
    /// <para>If Result Type is an array-element pointer that is decorated with ArrayStride, its Array Stride must match the Array Stride of the array’s type. If the array’s type is not decorated with ArrayStride, Result Type also must not be decorated with ArrayStride.</para>
    /// <para>Base must be a pointer, pointing to the base of a composite object.</para>
    /// <para>Indexes walk the type hierarchy to the desired depth, potentially down to scalar granularity. The first index in Indexes selects the top-level member/element/component/column of the base composite. All composite constituents use zero-based numbering, as described by their OpType…​ instruction. The second index applies similarly to that result, and so on. Once any non-composite type is reached, there must be no remaining (unused) indexes.</para>
    /// <para> Each index in Indexes</para>
    /// <para> - must have a scalar integer type</para>
    /// <para> - is treated as signed</para>
    /// <para> - if indexing into a structure, must be an OpConstant whose value is in bounds for selecting a member</para>
    /// <para> - if indexing into a vector, array, or matrix,   with the result type being a logical pointer type, causes undefined behavior if not in bounds.</para>
    /// </summary>
    public static Instruction InsertOpAccessChain(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAccessChain, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpInBoundsAccessChain(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpInBoundsAccessChain, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpInBoundsAccessChain</c></para>
    /// <para>Has the same semantics as OpAccessChain, with the addition that the resulting pointer is known to point within the base object.</para>
    /// </summary>
    public static Instruction InsertOpInBoundsAccessChain(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpInBoundsAccessChain, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpPtrAccessChain(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef element, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(element) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpPtrAccessChain, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..element.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpPtrAccessChain</c></para>
    /// <para>Has the same semantics as OpAccessChain, with the addition of the Element operand.</para>
    /// <para> Base is treated as the address of an element in an array, and a new element address is computed from Base and Element to become the OpAccessChain Base to walk the type hierarchy as per OpAccessChain. This computed Base has the same type as the originating Base.</para>
    /// <para>To compute the new element address, Element is treated as a signed count of elements E, relative to the original Base element B, and the address of element B + E is computed using enough precision to avoid overflow and underflow. For objects in storage classes requiring explicit layout, the element’s address or location is calculated using a stride, which will be the Base-type’s Array Stride if the Base type is decorated with ArrayStride. For all other objects, the implementation calculates the element’s address or location.</para>
    /// <para>With one exception, undefined behavior results when B + E is not an element in the same array (same innermost array, if array types are nested) as B. The exception being when B + E = L, where L is the length of the array: the address computation for element L is done with the same stride as any other B + E computation that stays within the array.</para>
    /// <para>If the storage class of Base requires an explicit layout then its type must be decorated with ArrayStride.</para>
    /// <para>Note: If Base is typed to be a pointer to an array and the desired operation is to select an element of that array, OpAccessChain should be directly used, as its first Index selects the array element.</para>
    /// </summary>
    public static Instruction InsertOpPtrAccessChain(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef element, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(element) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpPtrAccessChain, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..element.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpArrayLength(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef structure, LiteralInteger arraymember)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(structure) + buffer.GetWordLength(arraymember);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArrayLength, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..structure.AsSpirvSpan(), ..arraymember.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpArrayLength</c></para>
    /// <para>Length of a run-time array.</para>
    /// <para>Result Type must be an OpTypeInt with 32-bit Width and 0 Signedness.</para>
    /// <para>Structure must be a logical pointer to an OpTypeStruct whose last member is a run-time array.</para>
    /// <para>Array member is an unsigned 32-bit integer index of the last member of the structure that Structure points to. That member’s type must be from OpTypeRuntimeArray.</para>
    /// </summary>
    public static Instruction InsertOpArrayLength(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef structure, LiteralInteger arraymember)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(structure) + buffer.GetWordLength(arraymember);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArrayLength, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..structure.AsSpirvSpan(), ..arraymember.AsSpirvSpan()]);
    }

    public static Instruction AddOpGenericPtrMemSemantics(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGenericPtrMemSemantics, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGenericPtrMemSemantics</c></para>
    /// <para>Result is a valid Memory Semantics which includes mask bits set for the Storage Class for the specific (non-Generic) Storage Class of Pointer. </para>
    /// <para>Pointer must point to Generic Storage Class.</para>
    /// <para>Result Type must be an OpTypeInt with 32-bit Width and 0 Signedness.</para>
    /// </summary>
    public static Instruction InsertOpGenericPtrMemSemantics(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGenericPtrMemSemantics, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    public static Instruction AddOpInBoundsPtrAccessChain(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef element, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(element) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpInBoundsPtrAccessChain, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..element.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpInBoundsPtrAccessChain</c></para>
    /// <para>Has the same semantics as OpPtrAccessChain, with the addition that the resulting pointer is known to point within the base object.</para>
    /// </summary>
    public static Instruction InsertOpInBoundsPtrAccessChain(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef element, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(element) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpInBoundsPtrAccessChain, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..element.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpDecorate(this SpirvBuffer buffer, IdRef target, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDecorate, target, ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDecorate</c></para>
    /// <para>Add a Decoration to another <c>id</c>.</para>
    /// <para>Target is the <c>id</c> to decorate.  It can potentially be any <c>id</c> that is a forward reference. A set of decorations can be grouped together by having multiple decoration instructions targeting the same OpDecorationGroup instruction.</para>
    /// <para>This instruction is only valid if the Decoration operand is a decoration that takes no Extra Operands, or takes Extra Operands that are not <c>id</c> operands.</para>
    /// </summary>
    public static Instruction InsertOpDecorate(this SpirvBuffer buffer, int position, IdRef target, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDecorate, target, ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    public static Instruction AddOpMemberDecorate(this SpirvBuffer buffer, IdRef structureType, LiteralInteger member, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(structureType) + buffer.GetWordLength(member) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMemberDecorate, ..structureType.AsSpirvSpan(), ..member.AsSpirvSpan(), ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorate</c></para>
    /// <para>Add a Decoration to a member of a structure type.</para>
    /// <para>Structure type is the <c>id</c> of a type from OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. The first member is member 0, the next is member 1, …​</para>
    /// <para>Note: See OpDecorate for creating groups of decorations for consumption by OpGroupMemberDecorate</para>
    /// </summary>
    public static Instruction InsertOpMemberDecorate(this SpirvBuffer buffer, int position, IdRef structureType, LiteralInteger member, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(structureType) + buffer.GetWordLength(member) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMemberDecorate, ..structureType.AsSpirvSpan(), ..member.AsSpirvSpan(), ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    public static Instruction AddOpDecorationGroup(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDecorationGroup, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDecorationGroup</c></para>
    /// <para>Deprecated (directly use non-group decoration instructions instead).</para>
    /// <para>A collector for Decorations from OpDecorate and OpDecorateId instructions. All such decoration instructions targeting this OpDecorationGroup instruction must precede it. Subsequent OpGroupDecorate and OpGroupMemberDecorate instructions that consume this instruction’s Result <c>id</c> will apply these decorations to their targets.</para>
    /// </summary>
    public static Instruction InsertOpDecorationGroup(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDecorationGroup, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupDecorate(this SpirvBuffer buffer, IdRef decorationGroup, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(decorationGroup) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupDecorate, ..decorationGroup.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupDecorate</c></para>
    /// <para>Deprecated (directly use non-group decoration instructions instead).</para>
    /// <para>Add a group of Decorations to another <c>id</c>.</para>
    /// <para>Decoration Group is the <c>id</c> of an OpDecorationGroup instruction.</para>
    /// <para>Targets is a list of <c>id</c>s to decorate with the groups of decorations. The Targets list must not include the <c>id</c> of any OpDecorationGroup instruction.</para>
    /// </summary>
    public static Instruction InsertOpGroupDecorate(this SpirvBuffer buffer, int position, IdRef decorationGroup, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(decorationGroup) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupDecorate, ..decorationGroup.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupMemberDecorate(this SpirvBuffer buffer, IdRef decorationGroup, Span<PairIdRefLiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(decorationGroup) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupMemberDecorate, ..decorationGroup.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupMemberDecorate</c></para>
    /// <para>Deprecated (directly use non-group decoration instructions instead).</para>
    /// <para>Add a group of Decorations to members of structure types.</para>
    /// <para>Decoration Group is the <c>id</c> of an OpDecorationGroup instruction.</para>
    /// <para>Targets is a list of (<c>id</c>, Member) pairs to decorate with the groups of decorations. Each <c>id</c> in the pair must be a target structure type, and the associated Member is the number of the member to decorate in the type. The first member is member 0, the next is member 1, …​</para>
    /// </summary>
    public static Instruction InsertOpGroupMemberDecorate(this SpirvBuffer buffer, int position, IdRef decorationGroup, Span<PairIdRefLiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(decorationGroup) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupMemberDecorate, ..decorationGroup.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpVectorExtractDynamic(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector) + buffer.GetWordLength(index);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpVectorExtractDynamic, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpVectorExtractDynamic</c></para>
    /// <para>Extract a single, dynamically selected, component of a vector.</para>
    /// <para>Result Type must be a scalar type.</para>
    /// <para>Vector must have a type OpTypeVector whose Component Type is Result Type.</para>
    /// <para>Index must be a scalar integer. It is interpreted as a 0-based index of which component of Vector to extract.</para>
    /// <para>Behavior is undefined if Index’s value is less than zero or greater than or equal to the number of components in Vector.</para>
    /// </summary>
    public static Instruction InsertOpVectorExtractDynamic(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector) + buffer.GetWordLength(index);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpVectorExtractDynamic, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    public static Instruction AddOpVectorInsertDynamic(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector, IdRef component, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector) + buffer.GetWordLength(component) + buffer.GetWordLength(index);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpVectorInsertDynamic, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan(), ..component.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpVectorInsertDynamic</c></para>
    /// <para>Make a copy of a vector, with a single, variably selected, component modified.</para>
    /// <para>Result Type must be an OpTypeVector.</para>
    /// <para>Vector must have the same type as Result Type and is the vector that the non-written components are copied from.</para>
    /// <para>Component is the value supplied for the component selected by Index. It must have the same type as the type of components in Result Type.</para>
    /// <para>Index must be a scalar integer. It is interpreted as a 0-based index of which component to modify.</para>
    /// <para>Behavior is undefined if Index’s value is less than zero or greater than or equal to the number of components in Vector.</para>
    /// </summary>
    public static Instruction InsertOpVectorInsertDynamic(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector, IdRef component, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector) + buffer.GetWordLength(component) + buffer.GetWordLength(index);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpVectorInsertDynamic, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan(), ..component.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    public static Instruction AddOpVectorShuffle(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpVectorShuffle, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpVectorShuffle</c></para>
    /// <para>Select arbitrary components from two vectors to make a new vector.</para>
    /// <para>Result Type must be an OpTypeVector. The number of components in Result Type must be the same as the number of Component operands.</para>
    /// <para>Vector 1 and Vector 2 must both have vector types, with the same Component Type as Result Type. They do not have to have the same number of components as Result Type or with each other. They are logically concatenated, forming a single vector with Vector 1’s components appearing before Vector 2’s. The components of this logical vector are logically numbered with a single consecutive set of numbers from 0 to N - 1, where N is the total number of components.</para>
    /// <para>Components are these logical numbers (see above), selecting which of the logically numbered components form the result. Each component is an unsigned 32-bit integer.  They can select the components in any order and can repeat components. The first component of the result is selected by the first Component operand,  the second component of the result is selected by the second Component operand, etc. A Component literal may also be FFFFFFFF, which means the corresponding result component has no source and is undefined. All Component literals must either be FFFFFFFF or in [0, N - 1] (inclusive).</para>
    /// <para>Note: A vector “swizzle” can be done by using the vector for both Vector operands, or using an OpUndef for one of the Vector operands.</para>
    /// </summary>
    public static Instruction InsertOpVectorShuffle(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpVectorShuffle, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpCompositeConstruct(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCompositeConstruct, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCompositeConstruct</c></para>
    /// <para>Construct a new composite object from a set of constituent objects.</para>
    /// <para>Result Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the operands, with one exception. The exception is that for constructing a vector, the operands may also be vectors with the same component type as the Result Type component type. If constructing a vector, the total number of components in all the operands must equal the number of components in Result Type.</para>
    /// <para>Constituents become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result, with one exception. The exception is that for constructing a vector, a contiguous subset of the scalars consumed can be represented by a vector operand instead. The Constituents must appear in the order needed by the definition of the type of the result. If constructing a vector, there must be at least two Constituent operands.</para>
    /// </summary>
    public static Instruction InsertOpCompositeConstruct(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCompositeConstruct, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpCompositeExtract(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef composite, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(composite) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCompositeExtract, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..composite.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCompositeExtract</c></para>
    /// <para>Extract a part of a composite object. </para>
    /// <para>Result Type must be the type of object selected by the last provided index.  The instruction result is the extracted object.</para>
    /// <para>Composite is the composite to extract from.</para>
    /// <para>Indexes walk the type hierarchy, potentially down to component granularity, to select the part to extract. All indexes must be in bounds.  All composite constituents use zero-based numbering, as described by their OpType…​ instruction. Each index is an unsigned 32-bit integer.</para>
    /// </summary>
    public static Instruction InsertOpCompositeExtract(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef composite, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(composite) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCompositeExtract, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..composite.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpCompositeInsert(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef objectId, IdRef composite, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(objectId) + buffer.GetWordLength(composite) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCompositeInsert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..composite.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCompositeInsert</c></para>
    /// <para>Make a copy of a composite object, while modifying one part of it.</para>
    /// <para>Result Type must be the same type as Composite.</para>
    /// <para>Object is the object to use as the modified part.</para>
    /// <para>Composite is the composite to copy all but the modified part from.</para>
    /// <para>Indexes walk the type hierarchy of Composite to the desired depth, potentially down to component granularity, to select the part to modify. All indexes must be in bounds. All composite constituents use zero-based numbering, as described by their OpType…​ instruction. The type of the part selected to modify must match the type of Object. Each index is an unsigned 32-bit integer.</para>
    /// </summary>
    public static Instruction InsertOpCompositeInsert(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef objectId, IdRef composite, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(objectId) + buffer.GetWordLength(composite) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCompositeInsert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..composite.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpCopyObject(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCopyObject, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCopyObject</c></para>
    /// <para>Make a copy of Operand. There are no pointer dereferences involved.</para>
    /// <para>Result Type must equal Operand type.  Result Type can be any type except OpTypeVoid.</para>
    /// </summary>
    public static Instruction InsertOpCopyObject(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCopyObject, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpTranspose(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef matrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTranspose, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTranspose</c></para>
    /// <para>Transpose a matrix.</para>
    /// <para>Result Type must be an OpTypeMatrix.</para>
    /// <para>Matrix must be an object of type OpTypeMatrix. The number of columns and the column size of Matrix must be the reverse of those in Result Type. The types of the scalar components in Matrix and Result Type must be the same.</para>
    /// <para>Matrix must have of type of OpTypeMatrix.</para>
    /// </summary>
    public static Instruction InsertOpTranspose(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef matrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTranspose, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan()]);
    }

    public static Instruction AddOpSampledImage(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef sampler)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(sampler);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSampledImage, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..sampler.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSampledImage</c></para>
    /// <para>Create a sampled image, containing both a sampler and an image.</para>
    /// <para>Result Type must be OpTypeSampledImage.</para>
    /// <para>Image is an object whose type is an OpTypeImage, whose Sampled operand is 0 or 1, and whose Dim operand is not SubpassData. Additionally, starting with version 1.6, the Dim operand must not be Buffer.</para>
    /// <para>Sampler must be an object whose type is OpTypeSampler.</para>
    /// <para>If the client API does not ignore Depth, the Image Type operand of the Result Type must be the same as the type of Image. Otherwise, the type of Image and the Image Type operand of the Result Type must be two OpTypeImage with all operands matching each other except for Depth which can be different.</para>
    /// </summary>
    public static Instruction InsertOpSampledImage(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef sampler)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(sampler);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSampledImage, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..sampler.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleImplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleImplicitLod</c></para>
    /// <para>Sample an image with an implicit level of detail.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleImplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleExplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleExplicitLod</c></para>
    /// <para>Sample an image using an explicit level of detail.</para>
    /// <para> Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. Unless the Kernel capability is declared, it must be floating point. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleExplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleDrefImplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleDrefImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleDrefImplicitLod</c></para>
    /// <para>Sample an image doing depth-comparison with an implicit level of detail.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleDrefImplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleDrefImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleDrefExplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleDrefExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleDrefExplicitLod</c></para>
    /// <para>Sample an image doing depth-comparison using an explicit level of detail.</para>
    /// <para> Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleDrefExplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleDrefExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleProjImplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleProjImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleProjImplicitLod</c></para>
    /// <para>Sample an image with with a project coordinate and an implicit level of detail.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.</para>
    /// <para>Coordinate  must be a vector of floating-point type.  It contains (u[, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleProjImplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleProjImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleProjExplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleProjExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleProjExplicitLod</c></para>
    /// <para>Sample an image with a project coordinate using an explicit level of detail.</para>
    /// <para> Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.</para>
    /// <para>Coordinate  must be a vector of floating-point type.  It contains (u[, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleProjExplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleProjExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleProjDrefImplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleProjDrefImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleProjDrefImplicitLod</c></para>
    /// <para>Sample an image with a project coordinate, doing depth-comparison, with an implicit level of detail.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.</para>
    /// <para>Coordinate  must be a vector of floating-point type.  It contains (u[, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref /q is the depth-comparison reference value. Dref must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleProjDrefImplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleProjDrefImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleProjDrefExplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleProjDrefExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleProjDrefExplicitLod</c></para>
    /// <para>Sample an image with a project coordinate, doing depth-comparison, using an explicit level of detail.</para>
    /// <para> Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.</para>
    /// <para>Coordinate  must be a vector of floating-point type.  It contains (u[, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref /q is the depth-comparison reference value. Dref must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleProjDrefExplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleProjDrefExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageFetch(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageFetch, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageFetch</c></para>
    /// <para>Fetch a single texel from an image whose Sampled operand is 1.</para>
    /// <para> Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</para>
    /// <para>Image must be an object whose type is OpTypeImage. Its Dim operand must not be Cube, and its Sampled operand must be 1.</para>
    /// <para>Coordinate  must be a scalar or vector of integer type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageFetch(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageFetch, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageGather(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef component, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(component) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageGather, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..component.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageGather</c></para>
    /// <para>Gathers the requested component from four texels.</para>
    /// <para> Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image.</para>
    /// <para>Component is the component number gathered from all four texels. It must be a 32-bit integer type scalar.  Behavior is undefined if its value is not 0, 1, 2 or 3.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageGather(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef component, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(component) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageGather, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..component.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageDrefGather(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageDrefGather, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageDrefGather</c></para>
    /// <para>Gathers the requested depth-comparison from four texels.</para>
    /// <para> Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageDrefGather(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageDrefGather, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageRead(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageRead, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageRead</c></para>
    /// <para>Read a texel from an image without a sampler.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type or integer type.  It must be a scalar or vector with component type the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).</para>
    /// <para>Image must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2. If the Arrayed operand is 1, then additional capabilities may be required;  e.g., ImageCubeArray, or ImageMSArray.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type or integer type.  It contains non-normalized texel coordinates (u[, v] …​ [, array layer]) as needed by the definition of Image. See the client API specification for handling of coordinates outside the image.</para>
    /// <para> If the Image Dim operand is SubpassData, Coordinate is relative to the current fragment location. See the client API specification for more detail on how these coordinates are applied. </para>
    /// <para> If the Image Dim operand is not SubpassData, the Image Format must not be Unknown, unless the StorageImageReadWithoutFormat Capability was declared.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageRead(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageRead, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageWrite(this SpirvBuffer buffer, IdRef image, IdRef coordinate, IdRef texel, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(texel) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageWrite, ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..texel.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageWrite</c></para>
    /// <para>Write a texel to an image without a sampler.</para>
    /// <para>Image must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2. If the Arrayed operand is 1, then additional capabilities may be required;  e.g., ImageCubeArray, or ImageMSArray. Its Dim operand must not be SubpassData.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type or integer type.  It contains non-normalized texel coordinates (u[, v] …​ [, array layer]) as needed by the definition of Image. See the client API specification for handling of coordinates outside the image.</para>
    /// <para>Texel is the data to write. It must be a scalar or vector with component type the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).</para>
    /// <para> The Image Format must not be Unknown, unless the StorageImageWriteWithoutFormat Capability was declared.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageWrite(this SpirvBuffer buffer, int position, IdRef image, IdRef coordinate, IdRef texel, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(texel) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageWrite, ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..texel.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImage(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImage, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImage</c></para>
    /// <para>Extract the image from a sampled image.</para>
    /// <para>Result Type must be OpTypeImage.</para>
    /// <para>Sampled Image must have type OpTypeSampledImage whose Image Type is the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpImage(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImage, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageQueryFormat(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageQueryFormat, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageQueryFormat</c></para>
    /// <para>Query the image format of an image created with an Unknown Image Format.</para>
    /// <para>Result Type must be a scalar integer type. The resulting value is an enumerant from Image Channel Data Type.</para>
    /// <para>Image must be an object whose type is OpTypeImage.</para>
    /// </summary>
    public static Instruction InsertOpImageQueryFormat(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageQueryFormat, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageQueryOrder(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageQueryOrder, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageQueryOrder</c></para>
    /// <para>Query the channel order of an image created with an Unknown Image Format.</para>
    /// <para>Result Type must be a scalar integer type. The resulting value is an enumerant from Image Channel Order.</para>
    /// <para>Image must be an object whose type is OpTypeImage.</para>
    /// </summary>
    public static Instruction InsertOpImageQueryOrder(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageQueryOrder, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageQuerySizeLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef levelofDetail)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(levelofDetail);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageQuerySizeLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..levelofDetail.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageQuerySizeLod</c></para>
    /// <para>Query the dimensions of Image for mipmap level for Level of Detail.</para>
    /// <para>Result Type must be an integer type scalar or vector.  The number of components must be</para>
    /// <para>1 for the 1D dimensionality,</para>
    /// <para>2 for the 2D and Cube dimensionalities,</para>
    /// <para>3 for the 3D dimensionality,</para>
    /// <para>plus 1 more if the image type is arrayed. This vector is filled in with (width [, height] [, depth] [, elements]) where elements is the number of layers in an image array, or the number of cubes in a cube-map array.</para>
    /// <para>Image must be an object whose type is OpTypeImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube, and its MS must be 0. See OpImageQuerySize for querying image types without level of detail. See the client API specification for additional image type restrictions.</para>
    /// <para>Level of Detail is used to compute which mipmap level to query, as specified by the client API.</para>
    /// </summary>
    public static Instruction InsertOpImageQuerySizeLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef levelofDetail)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(levelofDetail);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageQuerySizeLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..levelofDetail.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageQuerySize(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageQuerySize, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageQuerySize</c></para>
    /// <para>Query the dimensions of Image, with no level of detail.</para>
    /// <para>Result Type must be an integer type scalar or vector.  The number of components must be:</para>
    /// <para>1 for the 1D and Buffer dimensionalities,</para>
    /// <para>2 for the 2D, Cube, and Rect dimensionalities,</para>
    /// <para>3 for the 3D dimensionality,</para>
    /// <para>plus 1 more if the image type is arrayed. This vector is filled in with (width [, height] [, elements]) where elements is the number of layers in an image array or the number of cubes in a cube-map array.</para>
    /// <para>Image must be an object whose type is OpTypeImage. Its Dim operand must be one of those listed under Result Type, above. Additionally, if its Dim is 1D, 2D, 3D, or Cube, it must also have either an MS of 1 or a Sampled of 0 or 2. There is no implicit level-of-detail consumed by this instruction. See OpImageQuerySizeLod for querying images having level of detail. See the client API specification for additional image type restrictions.</para>
    /// </summary>
    public static Instruction InsertOpImageQuerySize(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageQuerySize, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageQueryLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageQueryLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageQueryLod</c></para>
    /// <para>Query the mipmap level and the level of detail for a hypothetical sampling of Image at Coordinate using an implicit level of detail.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type must be a two-component floating-point type vector.</para>
    /// <para>The first component of the result contains the mipmap array layer.</para>
    /// <para>The second component of the result contains the implicit level of detail relative to the base level.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage Dim operand must be one of 1D, 2D, 3D, or Cube, and its MS must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ ) as needed by the definition of Sampled Image, not including any array layer index.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.</para>
    /// </summary>
    public static Instruction InsertOpImageQueryLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageQueryLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageQueryLevels(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageQueryLevels, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageQueryLevels</c></para>
    /// <para>Query the number of mipmap levels accessible through Image.</para>
    /// <para>Result Type must be a scalar integer type. The result is the number of mipmap levels,as specified by the client API.</para>
    /// <para>Image must be an object whose type is OpTypeImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube, and its MS must be 0. See the client API specification for additional image type restrictions.</para>
    /// </summary>
    public static Instruction InsertOpImageQueryLevels(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageQueryLevels, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageQuerySamples(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageQuerySamples, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageQuerySamples</c></para>
    /// <para>Query the number of samples available per texel fetch in a multisample image.</para>
    /// <para>Result Type must be a scalar integer type. The result is the number of samples.</para>
    /// <para>Image must be an object whose type is OpTypeImage. Its Dim operand must be one of 2D and MS of 1.</para>
    /// </summary>
    public static Instruction InsertOpImageQuerySamples(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageQuerySamples, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertFToU(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef floatValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(floatValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertFToU, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..floatValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertFToU</c></para>
    /// <para>Convert value numerically from floating point to unsigned integer, with round toward 0.0.</para>
    /// <para> Result Type must be a scalar or vector of integer type, whose Signedness operand is 0.  Behavior is undefined if Result Type is not wide enough to hold the converted value.</para>
    /// <para>Float Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpConvertFToU(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef floatValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(floatValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertFToU, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..floatValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertFToS(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef floatValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(floatValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertFToS, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..floatValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertFToS</c></para>
    /// <para>Convert value numerically from floating point to signed integer, with round toward 0.0.</para>
    /// <para> Result Type must be a scalar or vector of integer type.  Behavior is undefined if Result Type is not wide enough to hold the converted value.</para>
    /// <para>Float Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpConvertFToS(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef floatValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(floatValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertFToS, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..floatValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertSToF(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef signedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(signedValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertSToF, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..signedValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertSToF</c></para>
    /// <para>Convert value numerically from signed integer to floating point.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para>Signed Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpConvertSToF(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef signedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(signedValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertSToF, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..signedValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertUToF(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef unsignedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(unsignedValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertUToF, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..unsignedValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertUToF</c></para>
    /// <para>Convert value numerically from unsigned integer to floating point.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para>Unsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpConvertUToF(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef unsignedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(unsignedValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertUToF, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..unsignedValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpUConvert(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef unsignedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(unsignedValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUConvert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..unsignedValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUConvert</c></para>
    /// <para>Convert unsigned width. This is either a truncate or a zero extend.</para>
    /// <para> Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. </para>
    /// <para>Unsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must not equal the component width in Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpUConvert(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef unsignedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(unsignedValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUConvert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..unsignedValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpSConvert(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef signedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(signedValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSConvert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..signedValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSConvert</c></para>
    /// <para>Convert signed width.  This is either a truncate or a sign extend.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para>Signed Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must not equal the component width in Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSConvert(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef signedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(signedValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSConvert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..signedValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpFConvert(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef floatValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(floatValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFConvert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..floatValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFConvert</c></para>
    /// <para>Convert value numerically from one floating-point width to another width.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para>Float Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.  The component type must not equal the component type in Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFConvert(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef floatValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(floatValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFConvert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..floatValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpQuantizeToF16(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpQuantizeToF16, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpQuantizeToF16</c></para>
    /// <para>Quantize a floating-point value to what is expressible by a 16-bit floating-point value.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. The component width must be 32 bits and must not have a Floating Point Encoding operand.</para>
    /// <para>Value is the value to quantize. The type of Value must be the same as Result Type. </para>
    /// <para> If Value is an infinity, the result is the same infinity. If Value is a NaN, the result is a NaN, but not necessarily the same NaN. If Value is positive with a magnitude too large to represent as a 16-bit floating-point value, the result is positive infinity. If Value is negative with a magnitude too large to represent as a 16-bit floating-point value, the result is negative infinity. If the magnitude of Value is too small to represent as a normalized 16-bit floating-point value, the result must be either +0 or -0.</para>
    /// <para>The RelaxedPrecision Decoration has no effect on this instruction.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpQuantizeToF16(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpQuantizeToF16, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertPtrToU(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertPtrToU, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertPtrToU</c></para>
    /// <para>Bit pattern-preserving conversion of a pointer to an unsigned scalar integer of possibly different bit width.</para>
    /// <para> Result Type must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>Pointer must be a physical pointer type. If the bit width of Pointer is smaller than that of Result Type, the conversion zero extends Pointer. If the bit width of Pointer is larger than that of Result Type, the conversion truncates Pointer. For same bit width Pointer and Result Type, this is the same as OpBitcast.</para>
    /// </summary>
    public static Instruction InsertOpConvertPtrToU(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertPtrToU, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    public static Instruction AddOpSatConvertSToU(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef signedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(signedValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSatConvertSToU, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..signedValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSatConvertSToU</c></para>
    /// <para>Convert a signed integer to unsigned integer. Converted values outside the representable range of Result Type are clamped to the nearest representable value of Result Type.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para>Signed Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSatConvertSToU(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef signedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(signedValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSatConvertSToU, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..signedValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpSatConvertUToS(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef unsignedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(unsignedValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSatConvertUToS, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..unsignedValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSatConvertUToS</c></para>
    /// <para>Convert an unsigned integer to signed integer.  Converted values outside the representable range of Result Type are clamped to the nearest representable value of Result Type.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para>Unsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSatConvertUToS(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef unsignedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(unsignedValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSatConvertUToS, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..unsignedValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertUToPtr(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef integerValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(integerValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertUToPtr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..integerValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertUToPtr</c></para>
    /// <para>Bit pattern-preserving conversion of an unsigned scalar integer to a pointer. </para>
    /// <para> Result Type must be a physical pointer type. </para>
    /// <para>Integer Value  must be a scalar of integer type, whose Signedness operand is 0.  If the bit width of Integer Value is smaller than that of Result Type, the conversion zero extends Integer Value. If the bit width of Integer Value is larger than that of Result Type, the conversion truncates Integer Value. For same-width Integer Value and Result Type, this is the same as OpBitcast.</para>
    /// <para>Behavior is undefined if the storage class of Result Type does not match the one used by the operation that produced the value of Integer Value.</para>
    /// </summary>
    public static Instruction InsertOpConvertUToPtr(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef integerValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(integerValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertUToPtr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..integerValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpPtrCastToGeneric(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpPtrCastToGeneric, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpPtrCastToGeneric</c></para>
    /// <para>Convert a pointer’s Storage Class to Generic.</para>
    /// <para> Result Type must be an OpTypePointer. Its Storage Class must be Generic.</para>
    /// <para>Pointer must point to the Workgroup, CrossWorkgroup, or Function Storage Class.</para>
    /// <para>Result Type and Pointer must point to the same type.</para>
    /// </summary>
    public static Instruction InsertOpPtrCastToGeneric(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpPtrCastToGeneric, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    public static Instruction AddOpGenericCastToPtr(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGenericCastToPtr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGenericCastToPtr</c></para>
    /// <para>Convert a pointer’s Storage Class to a non-Generic class.</para>
    /// <para> Result Type must be an OpTypePointer. Its Storage Class must be Workgroup, CrossWorkgroup, or Function.</para>
    /// <para>Pointer must point to the Generic Storage Class.</para>
    /// <para>Result Type and Pointer must point to the same type.</para>
    /// </summary>
    public static Instruction InsertOpGenericCastToPtr(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGenericCastToPtr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    public static Instruction AddOpGenericCastToPtrExplicit(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, StorageClass storage)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(storage);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGenericCastToPtrExplicit, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..storage.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGenericCastToPtrExplicit</c></para>
    /// <para>Attempts to explicitly convert Pointer to Storage storage-class pointer value. </para>
    /// <para> Result Type must be an OpTypePointer. Its Storage Class must be Storage.</para>
    /// <para>Pointer must have a type of OpTypePointer whose Type is the same as the Type of Result Type.Pointer must point to the Generic Storage Class. If the cast fails, the instruction result is an OpConstantNull pointer in the Storage Storage Class.</para>
    /// <para>Storage must be one of the following literal values from Storage Class: Workgroup, CrossWorkgroup, or Function.</para>
    /// </summary>
    public static Instruction InsertOpGenericCastToPtrExplicit(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, StorageClass storage)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(storage);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGenericCastToPtrExplicit, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..storage.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitcast(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitcast, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitcast</c></para>
    /// <para>Bit pattern-preserving type conversion.</para>
    /// <para>Result Type must be an OpTypePointer, or a scalar or vector of numerical-type.</para>
    /// <para>Operand must have a type of OpTypePointer, or a scalar or vector of numerical-type. It must be a different type than Result Type.</para>
    /// <para> Before version 1.5: If either Result Type or Operand is a pointer,  the other must be a pointer or an integer scalar.</para>
    /// <para> Starting with version 1.5: If either Result Type or Operand is a pointer,  the other must be a pointer, an integer scalar, or an integer vector.</para>
    /// <para>If both Result Type and the type of Operand are pointers, they both must point into same storage class.</para>
    /// <para>Behavior is undefined if the storage class of Result Type does not match the one used by the operation that produced the value of Operand.</para>
    /// <para>If Result Type has the same number of components as Operand, they must also have the same component width, and results are computed per component.</para>
    /// <para>If Result Type has a different number of components than Operand, the total number of bits in Result Type must equal the total number of bits in Operand. Let L be the type, either Result Type or Operand’s type, that has the larger number of components. Let S be the other type, with the smaller number of components. The number of components in L must be an integer multiple of the number of components in S. The first component (that is, the only or lowest-numbered component) of S maps to the first components of L, and so on,  up to the last component of S mapping to the last components of L. Within this mapping, any single component of S (mapping to multiple components of L) maps its lower-ordered bits to the lower-numbered components of L.</para>
    /// </summary>
    public static Instruction InsertOpBitcast(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitcast, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpSNegate(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSNegate, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSNegate</c></para>
    /// <para>Signed-integer subtract of Operand from zero.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> Operand’s type  must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must equal the component width in Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSNegate(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSNegate, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpFNegate(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFNegate, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFNegate</c></para>
    /// <para>Inverts the sign bit of Operand. (Note, however, that OpFNegate is still considered a floating-point instruction, and so is subject to the general floating-point rules regarding, for example, subnormals and NaN propagation).</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para> The type of Operand must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFNegate(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFNegate, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpIAdd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIAdd</c></para>
    /// <para>Integer addition of Operand 1 and Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. </para>
    /// <para>The resulting value equals the low-order N bits of the correct result R, where N is the component width and R is computed with enough precision to avoid overflow and underflow.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpIAdd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFAdd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFAdd</c></para>
    /// <para>Floating-point addition of Operand 1 and Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para> The types of Operand 1 and Operand 2 both must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFAdd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpISub(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpISub, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpISub</c></para>
    /// <para>Integer subtraction of Operand 2 from Operand 1.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. </para>
    /// <para>The resulting value equals the low-order N bits of the correct result R, where N is the component width and R is computed with enough precision to avoid overflow and underflow.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpISub(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpISub, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFSub(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFSub, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFSub</c></para>
    /// <para>Floating-point subtraction of Operand 2 from Operand 1.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para> The types of Operand 1 and Operand 2 both must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFSub(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFSub, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpIMul(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIMul, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIMul</c></para>
    /// <para>Integer multiplication of Operand 1 and Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. </para>
    /// <para>The resulting value equals the low-order N bits of the correct result R, where N is the component width and R is computed with enough precision to avoid overflow and underflow.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpIMul(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIMul, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFMul(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFMul, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFMul</c></para>
    /// <para>Floating-point multiplication of Operand 1 and Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para> The types of Operand 1 and Operand 2 both must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFMul(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFMul, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUDiv(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUDiv, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUDiv</c></para>
    /// <para>Unsigned-integer division of Operand 1 divided by Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. </para>
    /// <para> The types of Operand 1 and Operand 2 both must be the same as Result Type. </para>
    /// <para> Results are computed per component.  Behavior is undefined if Operand 2 is 0.</para>
    /// </summary>
    public static Instruction InsertOpUDiv(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUDiv, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDiv(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDiv, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSDiv</c></para>
    /// <para>Signed-integer division of Operand 1 divided by Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. </para>
    /// <para> Results are computed per component.  Behavior is undefined if Operand 2 is 0. Behavior is undefined if Operand 2 is -1 and Operand 1 is the minimum representable value for the operands' type, causing signed overflow.</para>
    /// </summary>
    public static Instruction InsertOpSDiv(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDiv, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFDiv(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFDiv, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFDiv</c></para>
    /// <para>Floating-point division of Operand 1 divided by Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para> The types of Operand 1 and Operand 2 both must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFDiv(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFDiv, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUMod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUMod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUMod</c></para>
    /// <para>Unsigned modulo operation of Operand 1 modulo Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. </para>
    /// <para> The types of Operand 1 and Operand 2 both must be the same as Result Type. </para>
    /// <para> Results are computed per component.  Behavior is undefined if Operand 2 is 0.</para>
    /// </summary>
    public static Instruction InsertOpUMod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUMod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpSRem(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSRem, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSRem</c></para>
    /// <para>Signed remainder operation for the remainder whose sign matches the sign of Operand 1.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. </para>
    /// <para> Results are computed per component.  Behavior is undefined if Operand 2 is 0. Behavior is undefined if Operand 2 is -1 and Operand 1 is the minimum representable value for the operands' type, causing signed overflow. Otherwise, the result is the remainder r of Operand 1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the sign of Operand 1.</para>
    /// </summary>
    public static Instruction InsertOpSRem(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSRem, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpSMod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSMod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSMod</c></para>
    /// <para>Signed remainder operation for the remainder whose sign matches the sign of Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. </para>
    /// <para> Results are computed per component.  Behavior is undefined if Operand 2 is 0. Behavior is undefined if Operand 2 is -1 and Operand 1 is the minimum representable value for the operands' type, causing signed overflow. Otherwise, the result is the remainder r of Operand 1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the sign of Operand 2.</para>
    /// </summary>
    public static Instruction InsertOpSMod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSMod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFRem(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFRem, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFRem</c></para>
    /// <para>The floating-point remainder whose sign matches the sign of Operand 1.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para> The types of Operand 1 and Operand 2 both must be the same as Result Type. </para>
    /// <para> Results are computed per component.  The resulting value is undefined if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand 1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the sign of Operand 1.</para>
    /// </summary>
    public static Instruction InsertOpFRem(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFRem, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFMod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFMod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFMod</c></para>
    /// <para>The floating-point remainder whose sign matches the sign of Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type. </para>
    /// <para> The types of Operand 1 and Operand 2 both must be the same as Result Type. </para>
    /// <para> Results are computed per component.  The resulting value is undefined if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand 1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the sign of Operand 2.</para>
    /// </summary>
    public static Instruction InsertOpFMod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFMod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpVectorTimesScalar(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector, IdRef scalar)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector) + buffer.GetWordLength(scalar);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpVectorTimesScalar, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan(), ..scalar.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpVectorTimesScalar</c></para>
    /// <para>Scale a floating-point vector.</para>
    /// <para> Result Type must be a vector of floating-point type. </para>
    /// <para> The type of Vector must be the same as Result Type. Each component of Vector is multiplied by Scalar.</para>
    /// <para>Scalar must have the same type as the Component Type in Result Type.</para>
    /// </summary>
    public static Instruction InsertOpVectorTimesScalar(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector, IdRef scalar)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector) + buffer.GetWordLength(scalar);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpVectorTimesScalar, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan(), ..scalar.AsSpirvSpan()]);
    }

    public static Instruction AddOpMatrixTimesScalar(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef matrix, IdRef scalar)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix) + buffer.GetWordLength(scalar);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMatrixTimesScalar, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan(), ..scalar.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMatrixTimesScalar</c></para>
    /// <para>Scale a floating-point matrix.</para>
    /// <para> Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. </para>
    /// <para> The type of Matrix must be the same as Result Type. Each component in each column in Matrix is multiplied by Scalar.</para>
    /// <para>Scalar must have the same type as the Component Type in Result Type.</para>
    /// </summary>
    public static Instruction InsertOpMatrixTimesScalar(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef matrix, IdRef scalar)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix) + buffer.GetWordLength(scalar);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMatrixTimesScalar, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan(), ..scalar.AsSpirvSpan()]);
    }

    public static Instruction AddOpVectorTimesMatrix(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector, IdRef matrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector) + buffer.GetWordLength(matrix);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpVectorTimesMatrix, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan(), ..matrix.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpVectorTimesMatrix</c></para>
    /// <para>Linear-algebraic Vector X Matrix.</para>
    /// <para> Result Type must be a vector of floating-point type. </para>
    /// <para>Vector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of components in each column in Matrix.</para>
    /// <para>Matrix must be a matrix with the same Component Type as the Component Type in Result Type. Its number of columns must equal the number of components in Result Type.</para>
    /// </summary>
    public static Instruction InsertOpVectorTimesMatrix(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector, IdRef matrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector) + buffer.GetWordLength(matrix);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpVectorTimesMatrix, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan(), ..matrix.AsSpirvSpan()]);
    }

    public static Instruction AddOpMatrixTimesVector(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef matrix, IdRef vector)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix) + buffer.GetWordLength(vector);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMatrixTimesVector, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan(), ..vector.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMatrixTimesVector</c></para>
    /// <para>Linear-algebraic Matrix X Vector.</para>
    /// <para> Result Type must be a vector of floating-point type. </para>
    /// <para>Matrix must be an OpTypeMatrix whose Column Type is Result Type.</para>
    /// <para>Vector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Matrix.</para>
    /// </summary>
    public static Instruction InsertOpMatrixTimesVector(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef matrix, IdRef vector)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix) + buffer.GetWordLength(vector);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMatrixTimesVector, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan(), ..vector.AsSpirvSpan()]);
    }

    public static Instruction AddOpMatrixTimesMatrix(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef leftMatrix, IdRef rightMatrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(leftMatrix) + buffer.GetWordLength(rightMatrix);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMatrixTimesMatrix, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..leftMatrix.AsSpirvSpan(), ..rightMatrix.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMatrixTimesMatrix</c></para>
    /// <para>Linear-algebraic multiply of LeftMatrix X RightMatrix.</para>
    /// <para> Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. </para>
    /// <para>LeftMatrix must be a matrix whose Column Type is the same as the Column Type in Result Type.</para>
    /// <para>RightMatrix must be a matrix with the same Component Type as the Component Type in Result Type. Its number of columns must equal the number of columns in Result Type. Its columns must have the same number of components as the number of columns in LeftMatrix.</para>
    /// </summary>
    public static Instruction InsertOpMatrixTimesMatrix(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef leftMatrix, IdRef rightMatrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(leftMatrix) + buffer.GetWordLength(rightMatrix);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMatrixTimesMatrix, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..leftMatrix.AsSpirvSpan(), ..rightMatrix.AsSpirvSpan()]);
    }

    public static Instruction AddOpOuterProduct(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpOuterProduct, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpOuterProduct</c></para>
    /// <para>Linear-algebraic outer product of Vector 1 and Vector 2.</para>
    /// <para> Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. </para>
    /// <para>Vector 1 must have the same type as the Column Type in Result Type.</para>
    /// <para>Vector 2 must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Result Type.</para>
    /// </summary>
    public static Instruction InsertOpOuterProduct(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpOuterProduct, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan()]);
    }

    public static Instruction AddOpDot(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDot</c></para>
    /// <para>Dot product of Vector 1 and Vector 2.</para>
    /// <para> Result Type must be a floating-point type scalar. </para>
    /// <para>Vector 1 and Vector 2 must be vectors of the same type, and their component type must be Result Type.</para>
    /// </summary>
    public static Instruction InsertOpDot(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan()]);
    }

    public static Instruction AddOpIAddCarry(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIAddCarry, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIAddCarry</c></para>
    /// <para>Result is the unsigned integer addition of Operand 1 and Operand 2, including its carry.</para>
    /// <para>Result Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. </para>
    /// <para>Operand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.</para>
    /// <para> Results are computed per component. </para>
    /// <para>Member 0 of the result gets the low-order bits (full component width) of the addition.</para>
    /// <para>Member 1 of the result gets the high-order (carry) bit of the result of the addition. That is, it gets the value 1 if the addition overflowed the component width, and 0 otherwise.</para>
    /// </summary>
    public static Instruction InsertOpIAddCarry(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIAddCarry, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpISubBorrow(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpISubBorrow, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpISubBorrow</c></para>
    /// <para>Result is the unsigned integer subtraction of Operand 2 from Operand 1, and what it needed to borrow.</para>
    /// <para>Result Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. </para>
    /// <para>Operand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.</para>
    /// <para> Results are computed per component. </para>
    /// <para>Member 0 of the result gets the low-order bits (full component width) of the subtraction. That is, if Operand 1 is larger than Operand 2, member 0 gets the full value of the subtraction;  if Operand 2 is larger than Operand 1, member 0 gets 2w + Operand 1 - Operand 2, where w is the component width.</para>
    /// <para>Member 1 of the result gets 0 if Operand 1 ≥ Operand 2, and gets 1 otherwise.</para>
    /// </summary>
    public static Instruction InsertOpISubBorrow(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpISubBorrow, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUMulExtended(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUMulExtended, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUMulExtended</c></para>
    /// <para>Result is the full value of the unsigned integer multiplication of Operand 1 and Operand 2.</para>
    /// <para>Result Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. </para>
    /// <para>Operand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.</para>
    /// <para> Results are computed per component. </para>
    /// <para>Member 0 of the result gets the low-order bits of the multiplication.</para>
    /// <para>Member 1 of the result gets the high-order bits of the multiplication.</para>
    /// </summary>
    public static Instruction InsertOpUMulExtended(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUMulExtended, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpSMulExtended(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSMulExtended, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSMulExtended</c></para>
    /// <para>Result is the full value of the signed integer multiplication of Operand 1 and Operand 2.</para>
    /// <para>Result Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type. </para>
    /// <para>Operand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as signed integers.</para>
    /// <para> Results are computed per component. </para>
    /// <para>Member 0 of the result gets the low-order bits of the multiplication.</para>
    /// <para>Member 1 of the result gets the high-order bits of the multiplication.</para>
    /// </summary>
    public static Instruction InsertOpSMulExtended(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSMulExtended, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpAny(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAny, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAny</c></para>
    /// <para>Result is true if any component of Vector is true, otherwise result is false.</para>
    /// <para> Result Type must be a Boolean type scalar. </para>
    /// <para>Vector must be a vector of Boolean type.</para>
    /// </summary>
    public static Instruction InsertOpAny(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAny, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan()]);
    }

    public static Instruction AddOpAll(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAll, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAll</c></para>
    /// <para>Result is true if all components of Vector are true, otherwise result is false.</para>
    /// <para> Result Type must be a Boolean type scalar. </para>
    /// <para>Vector must be a vector of Boolean type.</para>
    /// </summary>
    public static Instruction InsertOpAll(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAll, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector.AsSpirvSpan()]);
    }

    public static Instruction AddOpIsNan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIsNan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIsNan</c></para>
    /// <para>Result is true if x is a NaN for the floating-point encoding used by the type of x, otherwise result is false.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para>x must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpIsNan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIsNan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpIsInf(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIsInf, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIsInf</c></para>
    /// <para>Result is true if x is an Inf for the floating-point encoding used by the type of x, otherwise result is false</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para>x must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpIsInf(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIsInf, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpIsFinite(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIsFinite, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIsFinite</c></para>
    /// <para>Result is true if x is a finite number for the floating-point encoding used by the type of x, otherwise result is false.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para>x must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpIsFinite(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIsFinite, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpIsNormal(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIsNormal, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIsNormal</c></para>
    /// <para>Result is true if x is a normal number for the floating-point encoding used by the type of x, otherwise result is false.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para>x must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpIsNormal(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIsNormal, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpSignBitSet(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSignBitSet, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSignBitSet</c></para>
    /// <para>Result is true if x has its sign bit set, otherwise result is false.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para>x must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSignBitSet(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSignBitSet, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpLessOrGreater(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef x, IdRef y)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x) + buffer.GetWordLength(y);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLessOrGreater, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan(), ..y.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLessOrGreater</c></para>
    /// <para>Deprecated (use OpFOrdNotEqual).</para>
    /// <para>Has the same semantics as OpFOrdNotEqual.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para>x must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.</para>
    /// <para>y must have the same type as x.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpLessOrGreater(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef x, IdRef y)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x) + buffer.GetWordLength(y);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLessOrGreater, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan(), ..y.AsSpirvSpan()]);
    }

    public static Instruction AddOpOrdered(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef x, IdRef y)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x) + buffer.GetWordLength(y);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpOrdered, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan(), ..y.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpOrdered</c></para>
    /// <para>Result is true if both x == x and y == y are true, where OpFOrdEqual is used as comparison, otherwise result is false.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para>x must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.</para>
    /// <para>y must have the same type as x.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpOrdered(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef x, IdRef y)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x) + buffer.GetWordLength(y);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpOrdered, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan(), ..y.AsSpirvSpan()]);
    }

    public static Instruction AddOpUnordered(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef x, IdRef y)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x) + buffer.GetWordLength(y);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUnordered, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan(), ..y.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUnordered</c></para>
    /// <para>Result is true if either x or y is an NaN for the floating-point encoding used by the type of x and y, otherwise result is false.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para>x must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.</para>
    /// <para>y must have the same type as x.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpUnordered(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef x, IdRef y)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(x) + buffer.GetWordLength(y);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUnordered, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..x.AsSpirvSpan(), ..y.AsSpirvSpan()]);
    }

    public static Instruction AddOpLogicalEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLogicalEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLogicalEqual</c></para>
    /// <para>Result is true if Operand 1 and Operand 2 have the same value. Result is false if Operand 1 and Operand 2 have different values.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 must be the same as Result Type. </para>
    /// <para> The type of Operand 2 must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpLogicalEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLogicalEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpLogicalNotEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLogicalNotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLogicalNotEqual</c></para>
    /// <para>Result is true if Operand 1 and Operand 2 have different values. Result is false if Operand 1 and Operand 2 have the same value.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 must be the same as Result Type. </para>
    /// <para> The type of Operand 2 must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpLogicalNotEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLogicalNotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpLogicalOr(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLogicalOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLogicalOr</c></para>
    /// <para>Result is true if either Operand 1 or Operand 2 is true. Result is false if both Operand 1 and Operand 2 are false.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 must be the same as Result Type. </para>
    /// <para> The type of Operand 2 must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpLogicalOr(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLogicalOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpLogicalAnd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLogicalAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLogicalAnd</c></para>
    /// <para>Result is true if both Operand 1 and Operand 2 are true. Result is false if either Operand 1 or Operand 2 are false.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 must be the same as Result Type. </para>
    /// <para> The type of Operand 2 must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpLogicalAnd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLogicalAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpLogicalNot(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLogicalNot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLogicalNot</c></para>
    /// <para>Result is true if Operand is false.  Result is false if Operand is true.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand must be the same as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpLogicalNot(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLogicalNot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpSelect(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef condition, IdRef object1, IdRef object2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(condition) + buffer.GetWordLength(object1) + buffer.GetWordLength(object2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSelect, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..condition.AsSpirvSpan(), ..object1.AsSpirvSpan(), ..object2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSelect</c></para>
    /// <para>Select between two objects. Before version 1.4, results are only computed per component.</para>
    /// <para>Before version 1.4, Result Type must be a pointer, scalar, or vector. Starting with version 1.4, Result Type can additionally be a composite type other than a vector.</para>
    /// <para> The types of Object 1 and Object 2 must be the same as Result Type. </para>
    /// <para>Condition must be a scalar or vector of Boolean type. </para>
    /// <para>If Condition is a scalar and true, the result is Object 1. If Condition is a scalar and false, the result is Object 2.</para>
    /// <para>If Condition is a vector, Result Type must be a vector with the same number of components as Condition and the result is a mix of Object 1 and Object 2: If a component of Condition is true, the corresponding component in the result is taken from Object 1, otherwise it is taken from Object 2.</para>
    /// </summary>
    public static Instruction InsertOpSelect(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef condition, IdRef object1, IdRef object2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(condition) + buffer.GetWordLength(object1) + buffer.GetWordLength(object2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSelect, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..condition.AsSpirvSpan(), ..object1.AsSpirvSpan(), ..object2.AsSpirvSpan()]);
    }

    public static Instruction AddOpIEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIEqual</c></para>
    /// <para>Integer comparison for equality.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpIEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpINotEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpINotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpINotEqual</c></para>
    /// <para>Integer comparison for inequality.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpINotEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpINotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUGreaterThan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUGreaterThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUGreaterThan</c></para>
    /// <para>Unsigned-integer comparison if Operand 1 is greater than  Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpUGreaterThan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUGreaterThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpSGreaterThan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSGreaterThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSGreaterThan</c></para>
    /// <para>Signed-integer comparison if Operand 1 is greater than  Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSGreaterThan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSGreaterThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUGreaterThanEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUGreaterThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUGreaterThanEqual</c></para>
    /// <para>Unsigned-integer comparison if Operand 1 is greater than or equal to Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpUGreaterThanEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUGreaterThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpSGreaterThanEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSGreaterThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSGreaterThanEqual</c></para>
    /// <para>Signed-integer comparison if Operand 1 is greater than or equal to Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSGreaterThanEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSGreaterThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpULessThan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpULessThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpULessThan</c></para>
    /// <para>Unsigned-integer comparison if Operand 1 is less than Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpULessThan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpULessThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpSLessThan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSLessThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSLessThan</c></para>
    /// <para>Signed-integer comparison if Operand 1 is less than Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSLessThan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSLessThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpULessThanEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpULessThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpULessThanEqual</c></para>
    /// <para>Unsigned-integer comparison if Operand 1 is less than or equal to Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpULessThanEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpULessThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpSLessThanEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSLessThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSLessThanEqual</c></para>
    /// <para>Signed-integer comparison if Operand 1 is less than or equal to Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpSLessThanEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSLessThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFOrdEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFOrdEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFOrdEqual</c></para>
    /// <para>Floating-point comparison for being ordered and equal.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFOrdEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFOrdEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFUnordEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFUnordEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFUnordEqual</c></para>
    /// <para>Floating-point comparison for being unordered or equal.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFUnordEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFUnordEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFOrdNotEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFOrdNotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFOrdNotEqual</c></para>
    /// <para>Floating-point comparison for being ordered and not equal.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFOrdNotEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFOrdNotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFUnordNotEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFUnordNotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFUnordNotEqual</c></para>
    /// <para>Floating-point comparison for being unordered or not equal.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFUnordNotEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFUnordNotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFOrdLessThan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFOrdLessThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFOrdLessThan</c></para>
    /// <para>Floating-point comparison if operands are ordered and Operand 1 is less than Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFOrdLessThan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFOrdLessThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFUnordLessThan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFUnordLessThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFUnordLessThan</c></para>
    /// <para>Floating-point comparison if operands are unordered or Operand 1 is less than Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFUnordLessThan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFUnordLessThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFOrdGreaterThan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFOrdGreaterThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFOrdGreaterThan</c></para>
    /// <para>Floating-point comparison if operands are ordered and Operand 1 is greater than  Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFOrdGreaterThan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFOrdGreaterThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFUnordGreaterThan(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFUnordGreaterThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFUnordGreaterThan</c></para>
    /// <para>Floating-point comparison if operands are unordered or Operand 1 is greater than  Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFUnordGreaterThan(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFUnordGreaterThan, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFOrdLessThanEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFOrdLessThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFOrdLessThanEqual</c></para>
    /// <para>Floating-point comparison if operands are ordered and Operand 1 is less than or equal to Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFOrdLessThanEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFOrdLessThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFUnordLessThanEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFUnordLessThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFUnordLessThanEqual</c></para>
    /// <para>Floating-point comparison if operands are unordered or Operand 1 is less than or equal to Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFUnordLessThanEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFUnordLessThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFOrdGreaterThanEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFOrdGreaterThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFOrdGreaterThanEqual</c></para>
    /// <para>Floating-point comparison if operands are ordered and Operand 1 is greater than or equal to Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFOrdGreaterThanEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFOrdGreaterThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpFUnordGreaterThanEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFUnordGreaterThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFUnordGreaterThanEqual</c></para>
    /// <para>Floating-point comparison if operands are unordered or Operand 1 is greater than or equal to Operand 2.</para>
    /// <para> Result Type must be a scalar or vector of Boolean type. </para>
    /// <para> The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpFUnordGreaterThanEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFUnordGreaterThanEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpShiftRightLogical(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef shift)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(shift);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpShiftRightLogical, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..shift.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpShiftRightLogical</c></para>
    /// <para>Shift the bits in Base right by the number of bits specified in Shift.  The most-significant bits are zero filled. </para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. </para>
    /// <para>Shift is consumed as an unsigned integer. The resulting value is undefined if Shift is greater than or equal to the bit width of the components of Base.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpShiftRightLogical(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef shift)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(shift);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpShiftRightLogical, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..shift.AsSpirvSpan()]);
    }

    public static Instruction AddOpShiftRightArithmetic(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef shift)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(shift);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpShiftRightArithmetic, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..shift.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpShiftRightArithmetic</c></para>
    /// <para>Shift the bits in Base right by the number of bits specified in Shift. The most-significant bits are filled with the sign bit from Base. </para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. </para>
    /// <para>Shift is treated as unsigned. The resulting value is undefined if Shift is greater than or equal to the bit width of the components of Base. </para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpShiftRightArithmetic(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef shift)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(shift);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpShiftRightArithmetic, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..shift.AsSpirvSpan()]);
    }

    public static Instruction AddOpShiftLeftLogical(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef shift)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(shift);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpShiftLeftLogical, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..shift.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpShiftLeftLogical</c></para>
    /// <para>Shift the bits in Base left by the number of bits specified in Shift. The least-significant bits are zero filled. </para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. </para>
    /// <para>Shift is treated as unsigned. The resulting value is undefined if Shift is greater than or equal to the bit width of the components of Base. </para>
    /// <para>The number of components and bit width of Result Type must match those Base type. All types must be integer types.</para>
    /// <para> Results are computed per component.</para>
    /// </summary>
    public static Instruction InsertOpShiftLeftLogical(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef shift)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(shift);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpShiftLeftLogical, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..shift.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitwiseOr(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitwiseOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitwiseOr</c></para>
    /// <para>Result is 1 if either Operand 1 or Operand 2 is 1. Result is 0 if both Operand 1 and Operand 2 are 0.</para>
    /// <para> Results are computed per component, and within each component, per bit. </para>
    /// <para> Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpBitwiseOr(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitwiseOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitwiseXor(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitwiseXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitwiseXor</c></para>
    /// <para>Result is 1 if exactly one of Operand 1 or Operand 2 is 1. Result is 0 if Operand 1 and Operand 2 have the same value.</para>
    /// <para> Results are computed per component, and within each component, per bit. </para>
    /// <para> Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpBitwiseXor(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitwiseXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitwiseAnd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitwiseAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitwiseAnd</c></para>
    /// <para>Result is 1 if both Operand 1 and Operand 2 are 1. Result is 0 if either Operand 1 or Operand 2 are 0.</para>
    /// <para> Results are computed per component, and within each component, per bit. </para>
    /// <para> Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpBitwiseAnd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitwiseAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpNot(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpNot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpNot</c></para>
    /// <para>Complement the bits of Operand.</para>
    /// <para> Results are computed per component, and within each component, per bit. </para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> Operand’s type  must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must equal the component width in Result Type.</para>
    /// </summary>
    public static Instruction InsertOpNot(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpNot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitFieldInsert(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef insert, IdRef offset, IdRef count)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(insert) + buffer.GetWordLength(offset) + buffer.GetWordLength(count);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitFieldInsert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..insert.AsSpirvSpan(), ..offset.AsSpirvSpan(), ..count.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitFieldInsert</c></para>
    /// <para>Make a copy of an object, with a modified bit field that comes from another object.</para>
    /// <para> Results are computed per component. </para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Base and Insert must be the same as Result Type. </para>
    /// <para>Any result bits numbered outside [Offset, Offset + Count -  1] (inclusive) come from the corresponding bits in Base.</para>
    /// <para>Any result bits numbered in [Offset, Offset + Count -  1] come, in order, from the bits numbered [0, Count - 1] of Insert.</para>
    /// <para>Count  must be an integer type scalar. Count is the number of bits taken from Insert. It is consumed as an unsigned value. Count can be 0, in which case the result is Base.</para>
    /// <para>Offset  must be an integer type scalar. Offset is the lowest-order bit of the bit field.  It is consumed as an unsigned value.</para>
    /// <para>The resulting value is undefined if Count or Offset or their sum is greater than the number of bits in the result.</para>
    /// </summary>
    public static Instruction InsertOpBitFieldInsert(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef insert, IdRef offset, IdRef count)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(insert) + buffer.GetWordLength(offset) + buffer.GetWordLength(count);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitFieldInsert, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..insert.AsSpirvSpan(), ..offset.AsSpirvSpan(), ..count.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitFieldSExtract(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef offset, IdRef count)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(offset) + buffer.GetWordLength(count);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitFieldSExtract, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..offset.AsSpirvSpan(), ..count.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitFieldSExtract</c></para>
    /// <para>Extract a bit field from an object, with sign extension.</para>
    /// <para> Results are computed per component. </para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Base must be the same as Result Type. </para>
    /// <para>If Count is greater than 0: The bits of Base numbered in [Offset, Offset + Count -  1] (inclusive) become the bits numbered [0, Count - 1] of the result. The remaining bits of the result will all be the same as bit Offset + Count -  1 of Base.</para>
    /// <para>Count  must be an integer type scalar. Count is the number of bits extracted from Base. It is consumed as an unsigned value. Count can be 0, in which case the result is 0.</para>
    /// <para>Offset  must be an integer type scalar. Offset is the lowest-order bit of the bit field to extract from Base. It is consumed as an unsigned value.</para>
    /// <para>The resulting value is undefined if Count or Offset or their sum is greater than the number of bits in the result.</para>
    /// </summary>
    public static Instruction InsertOpBitFieldSExtract(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef offset, IdRef count)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(offset) + buffer.GetWordLength(count);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitFieldSExtract, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..offset.AsSpirvSpan(), ..count.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitFieldUExtract(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef offset, IdRef count)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(offset) + buffer.GetWordLength(count);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitFieldUExtract, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..offset.AsSpirvSpan(), ..count.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitFieldUExtract</c></para>
    /// <para>Extract a bit field from an object, without sign extension.</para>
    /// <para>The semantics are the same as with OpBitFieldSExtract with the exception that there is no sign extension. The remaining bits of the result will all be 0.</para>
    /// </summary>
    public static Instruction InsertOpBitFieldUExtract(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef offset, IdRef count)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(offset) + buffer.GetWordLength(count);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitFieldUExtract, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..offset.AsSpirvSpan(), ..count.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitReverse(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitReverse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitReverse</c></para>
    /// <para>Reverse the bits in an object.</para>
    /// <para> Results are computed per component. </para>
    /// <para> Result Type must be a scalar or vector of integer type. </para>
    /// <para> The type of Base must be the same as Result Type. </para>
    /// <para>The bit-number n of the result is taken from bit-number Width - 1 - n of Base, where Width is the OpTypeInt operand of the Result Type.</para>
    /// </summary>
    public static Instruction InsertOpBitReverse(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitReverse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan()]);
    }

    public static Instruction AddOpBitCount(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBitCount, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBitCount</c></para>
    /// <para>Count the number of set bits in an object.</para>
    /// <para> Results are computed per component. </para>
    /// <para> Result Type must be a scalar or vector of integer type.  The components must be wide enough to hold the unsigned Width of Base as an unsigned value. That is, no sign bit is needed or counted when checking for a wide enough result width.</para>
    /// <para>Base must be a scalar or vector of integer type.  It must have the same number of components as Result Type.</para>
    /// <para>The result is the unsigned value that is the number of bits in Base that are 1.</para>
    /// </summary>
    public static Instruction InsertOpBitCount(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBitCount, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan()]);
    }

    public static Instruction AddOpDPdx(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDPdx, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDPdx</c></para>
    /// <para>Same result as either OpDPdxFine or OpDPdxCoarse on P. Selection of which one is based on external factors.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpDPdx(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDPdx, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpDPdy(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDPdy, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDPdy</c></para>
    /// <para>Same result as either OpDPdyFine or OpDPdyCoarse on P. Selection of which one is based on external factors.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpDPdy(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDPdy, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpFwidth(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFwidth, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFwidth</c></para>
    /// <para>Result is the same as computing the sum of the absolute values of OpDPdx and OpDPdy on P.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpFwidth(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFwidth, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpDPdxFine(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDPdxFine, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDPdxFine</c></para>
    /// <para>Result is the partial derivative of P with respect to the window x coordinate.Uses local differencing based on the value of P for the current fragment and its immediate neighbor(s).</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpDPdxFine(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDPdxFine, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpDPdyFine(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDPdyFine, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDPdyFine</c></para>
    /// <para>Result is the partial derivative of P with respect to the window y coordinate.Uses local differencing based on the value of P for the current fragment and its immediate neighbor(s).</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpDPdyFine(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDPdyFine, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpFwidthFine(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFwidthFine, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFwidthFine</c></para>
    /// <para>Result is the same as computing the sum of the absolute values of OpDPdxFine and OpDPdyFine on P.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpFwidthFine(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFwidthFine, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpDPdxCoarse(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDPdxCoarse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDPdxCoarse</c></para>
    /// <para>Result is the partial derivative of P with respect to the window x coordinate. Uses local differencing based on the value of P for the current fragment’s neighbors, and possibly, but not necessarily, includes the value of P for the current fragment. That is, over a given area, the implementation can compute x derivatives in fewer unique locations than would be allowed for OpDPdxFine.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpDPdxCoarse(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDPdxCoarse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpDPdyCoarse(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDPdyCoarse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDPdyCoarse</c></para>
    /// <para>Result is the partial derivative of P with respect to the window y coordinate. Uses local differencing based on the value of P for the current fragment’s neighbors, and possibly, but not necessarily, includes the value of P for the current fragment. That is, over a given area, the implementation can compute y derivatives in fewer unique locations than would be allowed for OpDPdyFine.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpDPdyCoarse(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDPdyCoarse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpFwidthCoarse(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFwidthCoarse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFwidthCoarse</c></para>
    /// <para>Result is the same as computing the sum of the absolute values of OpDPdxCoarse and OpDPdyCoarse on P.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para> Result Type must be a scalar or vector of floating-point type using the IEEE 754 encoding.  The component width must be 32 bits.</para>
    /// <para> The type of P must be the same as Result Type. P is the value to take the derivative of.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpFwidthCoarse(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef p)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(p);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFwidthCoarse, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..p.AsSpirvSpan()]);
    }

    public static Instruction AddOpEmitVertex(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpEmitVertex]);
    }

    /// <summary>
    /// <para><c>OpEmitVertex</c></para>
    /// <para>Emits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.</para>
    /// <para>This instruction must only be used when only one stream is present.</para>
    /// </summary>
    public static Instruction InsertOpEmitVertex(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpEmitVertex]);
    }

    public static Instruction AddOpEndPrimitive(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpEndPrimitive]);
    }

    /// <summary>
    /// <para><c>OpEndPrimitive</c></para>
    /// <para>Finish the current primitive and start a new one.  No vertex is emitted.</para>
    /// <para>This instruction must only be used when only one stream is present.</para>
    /// </summary>
    public static Instruction InsertOpEndPrimitive(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpEndPrimitive]);
    }

    public static Instruction AddOpEmitStreamVertex(this SpirvBuffer buffer, IdRef stream)
    {
        var wordLength = 1 + buffer.GetWordLength(stream);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpEmitStreamVertex, ..stream.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpEmitStreamVertex</c></para>
    /// <para>Emits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.</para>
    /// <para>Stream must be an <c>id</c> of a constant instruction with a scalar integer type. That constant is the output-primitive stream number.</para>
    /// <para>This instruction must only be used when multiple streams are present.</para>
    /// </summary>
    public static Instruction InsertOpEmitStreamVertex(this SpirvBuffer buffer, int position, IdRef stream)
    {
        var wordLength = 1 + buffer.GetWordLength(stream);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpEmitStreamVertex, ..stream.AsSpirvSpan()]);
    }

    public static Instruction AddOpEndStreamPrimitive(this SpirvBuffer buffer, IdRef stream)
    {
        var wordLength = 1 + buffer.GetWordLength(stream);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpEndStreamPrimitive, ..stream.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpEndStreamPrimitive</c></para>
    /// <para>Finish the current primitive and start a new one.  No vertex is emitted.</para>
    /// <para>Stream must be an <c>id</c> of a constant instruction with a scalar integer type. That constant is the output-primitive stream number.</para>
    /// <para>This instruction must only be used when multiple streams are present.</para>
    /// </summary>
    public static Instruction InsertOpEndStreamPrimitive(this SpirvBuffer buffer, int position, IdRef stream)
    {
        var wordLength = 1 + buffer.GetWordLength(stream);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpEndStreamPrimitive, ..stream.AsSpirvSpan()]);
    }

    public static Instruction AddOpControlBarrier(this SpirvBuffer buffer, IdScope execution, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpControlBarrier, ..execution.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpControlBarrier</c></para>
    /// <para>Wait for all invocations in the scope restricted tangle to reach the current point of execution before executing further instructions.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>An invocation will not execute dynamic instances that are program-ordered after a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed X'.</para>
    /// <para>When Execution is Workgroup or larger, behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>If Semantics is not None, this instruction also serves as an OpMemoryBarrier instruction, and also performs and adheres to the description and semantics of an OpMemoryBarrier instruction with the same Memory and Semantics operands. This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If Semantics is None, Memory is ignored.</para>
    /// <para>Before version 1.3, it is only valid to use this instruction with TessellationControl, GLCompute, or Kernel execution models. There is no such restriction starting with version 1.3.</para>
    /// <para>If used with the TessellationControl execution model, it also implicitly synchronizes the Output Storage Class:  Writes to Output variables performed by any invocation executed prior to a OpControlBarrier are visible to any other invocation proceeding beyond that OpControlBarrier.</para>
    /// </summary>
    public static Instruction InsertOpControlBarrier(this SpirvBuffer buffer, int position, IdScope execution, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpControlBarrier, ..execution.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpMemoryBarrier(this SpirvBuffer buffer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMemoryBarrier, ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemoryBarrier</c></para>
    /// <para>Control the order that memory accesses are observed.</para>
    /// <para>Ensures that memory accesses issued before this instruction are observed before memory accesses issued after this instruction. This control is ensured only for memory accesses issued by this invocation and observed by another invocation executing within Memory scope. If the Vulkan memory model is declared, this ordering only applies to memory accesses that use the NonPrivatePointer memory operand or NonPrivateTexel image operand.</para>
    /// <para>Semantics declares what kind of memory is being controlled and what kind of control to apply.</para>
    /// <para>To execute both a memory barrier and a control barrier, see OpControlBarrier.</para>
    /// </summary>
    public static Instruction InsertOpMemoryBarrier(this SpirvBuffer buffer, int position, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMemoryBarrier, ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicLoad(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicLoad, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicLoad</c></para>
    /// <para>Atomically load through Pointer using the given Semantics. All subparts of the value that is loaded are read atomically with respect to all other atomic accesses to it within Memory.</para>
    /// <para> Result Type must be a scalar of integer type or floating-point type. </para>
    /// <para>Pointer is the pointer to the memory to read. The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicLoad(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicLoad, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicStore(this SpirvBuffer buffer, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicStore, ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicStore</c></para>
    /// <para>Atomically store through Pointer using the given Semantics. All subparts of Value are written atomically with respect to all other atomic accesses to it within Memory.</para>
    /// <para>Pointer is the pointer to the memory to write. The type it points to  must be a scalar of integer type or floating-point type. </para>
    /// <para>Value is the value to write. The type of Value and the type pointed to by Pointer must be the same type.</para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicStore(this SpirvBuffer buffer, int position, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicStore, ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicExchange(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicExchange, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicExchange</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value from copying Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be a scalar of integer type or floating-point type. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicExchange(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicExchange, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicCompareExchange(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics equal, IdMemorySemantics unequal, IdRef value, IdRef comparator)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(equal) + buffer.GetWordLength(unequal) + buffer.GetWordLength(value) + buffer.GetWordLength(comparator);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicCompareExchange, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..equal.AsSpirvSpan(), ..unequal.AsSpirvSpan(), ..value.AsSpirvSpan(), ..comparator.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicCompareExchange</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value from Value only if Original Value equals Comparator, and</para>
    /// <para>3) store the New Value back through Pointer only if Original Value equaled Comparator.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para>Use Equal for the memory semantics of this instruction when Value and Original Value compare equal.</para>
    /// <para>Use Unequal for the memory semantics of this instruction when Value and Original Value compare unequal. Unequal must not be set to Release or Acquire and Release. In addition, Unequal cannot be set to a stronger memory-order then Equal.</para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.  This type must also match the type of Comparator.</para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicCompareExchange(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics equal, IdMemorySemantics unequal, IdRef value, IdRef comparator)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(equal) + buffer.GetWordLength(unequal) + buffer.GetWordLength(value) + buffer.GetWordLength(comparator);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicCompareExchange, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..equal.AsSpirvSpan(), ..unequal.AsSpirvSpan(), ..value.AsSpirvSpan(), ..comparator.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicCompareExchangeWeak(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics equal, IdMemorySemantics unequal, IdRef value, IdRef comparator)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(equal) + buffer.GetWordLength(unequal) + buffer.GetWordLength(value) + buffer.GetWordLength(comparator);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicCompareExchangeWeak, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..equal.AsSpirvSpan(), ..unequal.AsSpirvSpan(), ..value.AsSpirvSpan(), ..comparator.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicCompareExchangeWeak</c></para>
    /// <para>Deprecated (use OpAtomicCompareExchange).</para>
    /// <para>Has the same semantics as OpAtomicCompareExchange.</para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicCompareExchangeWeak(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics equal, IdMemorySemantics unequal, IdRef value, IdRef comparator)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(equal) + buffer.GetWordLength(unequal) + buffer.GetWordLength(value) + buffer.GetWordLength(comparator);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicCompareExchangeWeak, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..equal.AsSpirvSpan(), ..unequal.AsSpirvSpan(), ..value.AsSpirvSpan(), ..comparator.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicIIncrement(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicIIncrement, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicIIncrement</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value through integer addition of 1 to Original Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicIIncrement(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicIIncrement, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicIDecrement(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicIDecrement, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicIDecrement</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value through integer subtraction of 1 from Original Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicIDecrement(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicIDecrement, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicIAdd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicIAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicIAdd</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by integer addition of Original Value and Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicIAdd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicIAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicISub(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicISub, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicISub</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by integer subtraction of Value from Original Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicISub(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicISub, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicSMin(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicSMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicSMin</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by finding the smallest signed integer of Original Value and Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicSMin(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicSMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicUMin(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicUMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicUMin</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by finding the smallest unsigned integer of Original Value and Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicUMin(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicUMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicSMax(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicSMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicSMax</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by finding the largest signed integer of Original Value and Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicSMax(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicSMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicUMax(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicUMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicUMax</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by finding the largest unsigned integer of Original Value and Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicUMax(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicUMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicAnd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicAnd</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by the bitwise AND of Original Value and Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicAnd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicOr(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicOr</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by the bitwise OR of Original Value and Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicOr(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicXor(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicXor</c></para>
    /// <para>Perform the following steps atomically with respect to any other atomic accesses within Memory to the same location: </para>
    /// <para>1) load through Pointer to get an Original Value,</para>
    /// <para>2) get a New Value by the bitwise exclusive OR of Original Value and Value, and</para>
    /// <para>3) store the New Value back through Pointer.</para>
    /// <para>The instruction’s result is the Original Value.</para>
    /// <para> Result Type must be an integer type scalar. </para>
    /// <para> The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type. </para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicXor(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpPhi(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, Span<PairIdRefIdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpPhi, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpPhi</c></para>
    /// <para>The SSA phi function.</para>
    /// <para>The result is selected based on control flow: If control reached the current block from Parent i, Result Id gets the value that Variable i had at the end of Parent i.</para>
    /// <para>Result Type can be any type except OpTypeVoid.</para>
    /// <para>Operands are a sequence of pairs: (Variable 1, Parent 1 block), (Variable 2, Parent 2 block), …​ Each Parent i block is the label of an immediate predecessor in the CFG of the current block. There must be exactly one Parent i for each parent block of the current block in the CFG. If Parent i is reachable in the CFG and Variable i is defined in a block, that defining block must dominate Parent i. All Variables must have a type matching Result Type.</para>
    /// <para>Within a block, this instruction must appear before all non-OpPhi instructions (except for OpLine and OpNoLine, which can be mixed with OpPhi).</para>
    /// </summary>
    public static Instruction InsertOpPhi(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, Span<PairIdRefIdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpPhi, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpLoopMerge(this SpirvBuffer buffer, IdRef mergeBlock, IdRef continueTarget, LoopControlMask loopcontrol)
    {
        var wordLength = 1 + buffer.GetWordLength(mergeBlock) + buffer.GetWordLength(continueTarget) + buffer.GetWordLength(loopcontrol);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLoopMerge, ..mergeBlock.AsSpirvSpan(), ..continueTarget.AsSpirvSpan(), ..loopcontrol.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopMerge</c></para>
    /// <para>Declare a structured loop.</para>
    /// <para>This instruction must immediately precede either an OpBranch or OpBranchConditional instruction. That is, it must be the second-to-last instruction in its block.</para>
    /// <para>Merge Block is the label of the merge block for this structured loop.</para>
    /// <para>Continue Target is the label of a block targeted for processing a loop "continue".</para>
    /// <para>Loop Control Parameters appear in Loop Control-table order for any Loop Control setting that requires such a parameter.</para>
    /// <para>See Structured Control Flow for more detail.</para>
    /// </summary>
    public static Instruction InsertOpLoopMerge(this SpirvBuffer buffer, int position, IdRef mergeBlock, IdRef continueTarget, LoopControlMask loopcontrol)
    {
        var wordLength = 1 + buffer.GetWordLength(mergeBlock) + buffer.GetWordLength(continueTarget) + buffer.GetWordLength(loopcontrol);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLoopMerge, ..mergeBlock.AsSpirvSpan(), ..continueTarget.AsSpirvSpan(), ..loopcontrol.AsSpirvSpan()]);
    }

    public static Instruction AddOpSelectionMerge(this SpirvBuffer buffer, IdRef mergeBlock, SelectionControlMask selectioncontrol)
    {
        var wordLength = 1 + buffer.GetWordLength(mergeBlock) + buffer.GetWordLength(selectioncontrol);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSelectionMerge, ..mergeBlock.AsSpirvSpan(), ..selectioncontrol.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSelectionMerge</c></para>
    /// <para>Declare a structured selection.</para>
    /// <para>This instruction must immediately precede either an OpBranchConditional or OpSwitch instruction. That is, it must be the second-to-last instruction in its block.</para>
    /// <para>Merge Block is the label of the merge block for this structured selection.</para>
    /// <para>See Structured Control Flow for more detail.</para>
    /// </summary>
    public static Instruction InsertOpSelectionMerge(this SpirvBuffer buffer, int position, IdRef mergeBlock, SelectionControlMask selectioncontrol)
    {
        var wordLength = 1 + buffer.GetWordLength(mergeBlock) + buffer.GetWordLength(selectioncontrol);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSelectionMerge, ..mergeBlock.AsSpirvSpan(), ..selectioncontrol.AsSpirvSpan()]);
    }

    public static Instruction AddOpLabel(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLabel, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLabel</c></para>
    /// <para>The label instruction of a block.</para>
    /// <para>References to a block are through the Result <c>id</c> of its label.</para>
    /// </summary>
    public static Instruction InsertOpLabel(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLabel, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpBranch(this SpirvBuffer buffer, IdRef targetLabel)
    {
        var wordLength = 1 + buffer.GetWordLength(targetLabel);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBranch, ..targetLabel.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBranch</c></para>
    /// <para>Unconditional branch to Target Label.</para>
    /// <para>Target Label must be the Result <c>id</c> of an OpLabel instruction in the current function.</para>
    /// <para>This instruction must be the last instruction in a block.</para>
    /// </summary>
    public static Instruction InsertOpBranch(this SpirvBuffer buffer, int position, IdRef targetLabel)
    {
        var wordLength = 1 + buffer.GetWordLength(targetLabel);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBranch, ..targetLabel.AsSpirvSpan()]);
    }

    public static Instruction AddOpBranchConditional(this SpirvBuffer buffer, IdRef condition, IdRef trueLabel, IdRef falseLabel, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(condition) + buffer.GetWordLength(trueLabel) + buffer.GetWordLength(falseLabel) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBranchConditional, ..condition.AsSpirvSpan(), ..trueLabel.AsSpirvSpan(), ..falseLabel.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBranchConditional</c></para>
    /// <para>If Condition is true, branch to True Label, otherwise branch to False Label.</para>
    /// <para>Condition must be a Boolean type scalar.</para>
    /// <para>True Label must be an OpLabel in the current function.</para>
    /// <para>False Label must be an OpLabel in the current function.</para>
    /// <para>Starting with version 1.6, True Label and False Label must not be the same <c>id</c>.</para>
    /// <para>Branch weights are unsigned 32-bit integer literals. There must be either no Branch Weights or exactly two branch weights. If present, the first is the weight for branching to True Label, and the second is the weight for branching to False Label. The implied probability that a branch is taken is its weight divided by the sum of the two Branch weights. At least one weight must be non-zero. A weight of zero does not imply a branch is dead or permit its removal; branch weights are only hints. The sum of the two weights must not overflow a 32-bit unsigned integer.</para>
    /// <para>This instruction must be the last instruction in a block.</para>
    /// </summary>
    public static Instruction InsertOpBranchConditional(this SpirvBuffer buffer, int position, IdRef condition, IdRef trueLabel, IdRef falseLabel, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(condition) + buffer.GetWordLength(trueLabel) + buffer.GetWordLength(falseLabel) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBranchConditional, ..condition.AsSpirvSpan(), ..trueLabel.AsSpirvSpan(), ..falseLabel.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpSwitch(this SpirvBuffer buffer, IdRef selector, IdRef defaultId, Span<PairLiteralIntegerIdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(selector) + buffer.GetWordLength(defaultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSwitch, ..selector.AsSpirvSpan(), ..defaultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSwitch</c></para>
    /// <para>Multi-way branch to one of the operand label <c>id</c>.</para>
    /// <para>Selector must have a type of OpTypeInt. Selector is compared for equality to the Target literals.</para>
    /// <para>Default must be the <c>id</c> of a label.  If Selector does not equal any of the Target literals, control flow branches to the Default label <c>id</c>.</para>
    /// <para>Target must be alternating scalar integer literals and the <c>id</c> of a label.  If Selector equals a literal, control flow branches to the following label <c>id</c>. It is invalid for any two literal to be equal to each other. If Selector does not equal any literal, control flow branches to the Default label <c>id</c>. Each literal is interpreted with the type of Selector: The bit width of Selector’s type is the width of each literal’s type. If this width is not a multiple of 32-bits and the OpTypeInt Signedness is set to 1, the literal values are interpreted as being sign extended.</para>
    /// <para>This instruction must be the last instruction in a block.</para>
    /// </summary>
    public static Instruction InsertOpSwitch(this SpirvBuffer buffer, int position, IdRef selector, IdRef defaultId, Span<PairLiteralIntegerIdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(selector) + buffer.GetWordLength(defaultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSwitch, ..selector.AsSpirvSpan(), ..defaultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpKill(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpKill]);
    }

    /// <summary>
    /// <para><c>OpKill</c></para>
    /// <para>Deprecated (use OpTerminateInvocation or OpDemoteToHelperInvocation).</para>
    /// <para>Fragment-shader discard.</para>
    /// <para>Ceases all further processing in any invocation that executes it: Only instructions these invocations executed before OpKill have observable side effects. If this instruction is executed in non-uniform control flow, all subsequent control flow is non-uniform (for invocations that continue to execute).</para>
    /// <para>This instruction must be the last instruction in a block.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpKill(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpKill]);
    }

    public static Instruction AddOpReturn(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpReturn]);
    }

    /// <summary>
    /// <para><c>OpReturn</c></para>
    /// <para>Return with no value from a function with void return type.</para>
    /// <para>This instruction must be the last instruction in a block.</para>
    /// </summary>
    public static Instruction InsertOpReturn(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpReturn]);
    }

    public static Instruction AddOpReturnValue(this SpirvBuffer buffer, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReturnValue, ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReturnValue</c></para>
    /// <para>Return a value from a function.</para>
    /// <para>Value is the value returned, by copy, and must match the Return Type operand of the OpTypeFunction type of the OpFunction body this return instruction is in.  Value must not have type OpTypeVoid.</para>
    /// <para>This instruction must be the last instruction in a block.</para>
    /// </summary>
    public static Instruction InsertOpReturnValue(this SpirvBuffer buffer, int position, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReturnValue, ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpUnreachable(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpUnreachable]);
    }

    /// <summary>
    /// <para><c>OpUnreachable</c></para>
    /// <para>Behavior is undefined if this instruction is executed.</para>
    /// <para>This instruction must be the last instruction in a block.</para>
    /// </summary>
    public static Instruction InsertOpUnreachable(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpUnreachable]);
    }

    public static Instruction AddOpLifetimeStart(this SpirvBuffer buffer, IdRef pointer, LiteralInteger size)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(size);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLifetimeStart, ..pointer.AsSpirvSpan(), ..size.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLifetimeStart</c></para>
    /// <para>Declare that an object was not defined before this instruction.</para>
    /// <para>Pointer is a pointer to the object whose lifetime is starting. Its type must be an OpTypePointer with Storage Class Function.</para>
    /// <para> Size is an unsigned 32-bit integer.  Size must be 0 if Pointer is a pointer to a non-void type or the Addresses capability is not declared. If Size is non-zero, it is the number of bytes of memory whose lifetime is starting.</para>
    /// </summary>
    public static Instruction InsertOpLifetimeStart(this SpirvBuffer buffer, int position, IdRef pointer, LiteralInteger size)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(size);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLifetimeStart, ..pointer.AsSpirvSpan(), ..size.AsSpirvSpan()]);
    }

    public static Instruction AddOpLifetimeStop(this SpirvBuffer buffer, IdRef pointer, LiteralInteger size)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(size);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLifetimeStop, ..pointer.AsSpirvSpan(), ..size.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLifetimeStop</c></para>
    /// <para>Declare that an object is dead after this instruction.</para>
    /// <para>Pointer is a pointer to the object whose lifetime is ending. Its type must be an OpTypePointer with Storage Class Function.</para>
    /// <para> Size is an unsigned 32-bit integer.  Size must be 0 if Pointer is a pointer to a non-void type or the Addresses capability is not declared. If Size is non-zero, it is the number of bytes of memory whose lifetime is ending.</para>
    /// </summary>
    public static Instruction InsertOpLifetimeStop(this SpirvBuffer buffer, int position, IdRef pointer, LiteralInteger size)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(size);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLifetimeStop, ..pointer.AsSpirvSpan(), ..size.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupAsyncCopy(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef destination, IdRef source, IdRef numElements, IdRef stride, IdRef eventId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(destination) + buffer.GetWordLength(source) + buffer.GetWordLength(numElements) + buffer.GetWordLength(stride) + buffer.GetWordLength(eventId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupAsyncCopy, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..destination.AsSpirvSpan(), ..source.AsSpirvSpan(), ..numElements.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..eventId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupAsyncCopy</c></para>
    /// <para>Perform an asynchronous group copy of Num Elements elements from Source to Destination. The asynchronous copy is performed by all invocations in the scope restricted tangle.</para>
    /// <para>This instruction results in an event object that can be used by OpGroupWaitEvents to wait for the async copy to finish.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type must be an OpTypeEvent object.</para>
    /// <para>Destination must be a pointer to a scalar or vector of floating-point type or integer type. </para>
    /// <para>Destination pointer Storage Class must be Workgroup or CrossWorkgroup.</para>
    /// <para> The type of Source must be the same as Destination. </para>
    /// <para>If Destination pointer Storage Class is Workgroup, the Source pointer Storage Class must be CrossWorkgroup. In this case Stride defines the stride in elements when reading from Source pointer.</para>
    /// <para>If Destination pointer Storage Class is CrossWorkgroup, the Source pointer Storage Class must be Workgroup. In this case Stride defines the stride in elements when writing each element to Destination pointer.</para>
    /// <para>Stride and NumElements must be a 32-bit integer type scalar if the addressing model is Physical32 and 64 bit integer type scalar if the Addressing Model is Physical64.</para>
    /// <para>Event must have a type of OpTypeEvent.</para>
    /// <para>Event can be used to associate the copy with a previous copy allowing an event to be shared by multiple copies. Otherwise Event should be an OpConstantNull.</para>
    /// <para>If Event is not OpConstantNull, the result is the event object supplied by the Event operand.</para>
    /// </summary>
    public static Instruction InsertOpGroupAsyncCopy(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef destination, IdRef source, IdRef numElements, IdRef stride, IdRef eventId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(destination) + buffer.GetWordLength(source) + buffer.GetWordLength(numElements) + buffer.GetWordLength(stride) + buffer.GetWordLength(eventId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupAsyncCopy, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..destination.AsSpirvSpan(), ..source.AsSpirvSpan(), ..numElements.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..eventId.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupWaitEvents(this SpirvBuffer buffer, IdScope execution, IdRef numEvents, IdRef eventsList)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(numEvents) + buffer.GetWordLength(eventsList);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupWaitEvents, ..execution.AsSpirvSpan(), ..numEvents.AsSpirvSpan(), ..eventsList.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupWaitEvents</c></para>
    /// <para>Wait for events generated by OpGroupAsyncCopy operations to complete. Events List points to Num Events event objects, which is released after the wait is performed.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Num Events must be a 32-bit integer type scalar.</para>
    /// <para>Events List must be a pointer to OpTypeEvent.</para>
    /// </summary>
    public static Instruction InsertOpGroupWaitEvents(this SpirvBuffer buffer, int position, IdScope execution, IdRef numEvents, IdRef eventsList)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(numEvents) + buffer.GetWordLength(eventsList);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupWaitEvents, ..execution.AsSpirvSpan(), ..numEvents.AsSpirvSpan(), ..eventsList.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupAll(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupAll, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupAll</c></para>
    /// <para>Evaluates a predicate for all invocations in the scope restricted tangle,resulting in true if predicate evaluates to true for all invocations in the scope restricted tangle, otherwise the result is false.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Predicate must be a Boolean type.</para>
    /// </summary>
    public static Instruction InsertOpGroupAll(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupAll, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupAny(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupAny, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupAny</c></para>
    /// <para>Evaluates a predicate for all invocations in the scope restricted tangle,resulting in true if predicate evaluates to true for any invocation in the scope restricted tangle, otherwise the result is false.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Predicate must be a Boolean type.</para>
    /// </summary>
    public static Instruction InsertOpGroupAny(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupAny, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupBroadcast(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef localId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(localId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupBroadcast, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..localId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupBroadcast</c></para>
    /// <para>Broadcast the Value of the invocation identified by the local id LocalId to the result of all invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>LocalId must be an integer datatype. It must be a scalar, a vector with 2 components, or a vector with 3 components. Behavior is undefined unless LocalId is the same for all invocations in the group, or if it is greater than or equal to the size of the group in any dimension.</para>
    /// </summary>
    public static Instruction InsertOpGroupBroadcast(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef localId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(localId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupBroadcast, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..localId.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupIAdd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupIAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupIAdd</c></para>
    /// <para>An integer add group operation specified for all values of X specified by invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>The identity I for Operation is 0. </para>
    /// <para> The type of X must be the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpGroupIAdd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupIAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupFAdd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupFAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupFAdd</c></para>
    /// <para>A floating-point add group operation specified for all values of X specified by invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type. </para>
    /// <para>The identity I for Operation is 0. </para>
    /// <para> The type of X must be the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpGroupFAdd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupFAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupFMin(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupFMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupFMin</c></para>
    /// <para>A floating-point minimum group operation specified for all values of X specified by invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type. </para>
    /// <para>The identity I for Operation is +INF. </para>
    /// <para> The type of X must be the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpGroupFMin(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupFMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupUMin(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupUMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupUMin</c></para>
    /// <para>An unsigned integer minimum group operation specified for all values of X specified by invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>The identity I for Operation is UINT_MAX when X is 32 bits wide and ULONG_MAX when X is 64 bits wide. </para>
    /// <para> The type of X must be the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpGroupUMin(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupUMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupSMin(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupSMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupSMin</c></para>
    /// <para>A signed integer minimum group operation specified for all values of X specified by invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>The identity I for Operation is INT_MAX when X is 32 bits wide and LONG_MAX when X is 64 bits wide. </para>
    /// <para> The type of X must be the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpGroupSMin(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupSMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupFMax(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupFMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupFMax</c></para>
    /// <para>A floating-point maximum group operation specified for all values of X specified by invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type. </para>
    /// <para>The identity I for Operation is -INF. </para>
    /// <para> The type of X must be the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpGroupFMax(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupFMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupUMax(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupUMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupUMax</c></para>
    /// <para>An unsigned integer maximum group operation specified for all values of X specified by invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>The identity I for Operation is 0. </para>
    /// <para> The type of X must be the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpGroupUMax(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupUMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupSMax(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupSMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupSMax</c></para>
    /// <para>A signed integer maximum group operation specified for all values of X specified by invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>The identity I for Operation is INT_MIN when X is 32 bits wide and LONG_MIN when X is 64 bits wide. </para>
    /// <para> The type of X must be the same as Result Type.</para>
    /// </summary>
    public static Instruction InsertOpGroupSMax(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupSMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpReadPipe(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef pointer, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(pointer) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReadPipe, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReadPipe</c></para>
    /// <para>Read a packet from the pipe object specified by Pipe into Pointer. Result is 0 if the operation is successful and a negative value if the pipe is empty.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Pipe must have a type of OpTypePipe with ReadOnly access qualifier.</para>
    /// <para>Pointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpReadPipe(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef pointer, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(pointer) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReadPipe, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpWritePipe(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef pointer, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(pointer) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpWritePipe, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpWritePipe</c></para>
    /// <para>Write a packet from Pointer to the pipe object specified by Pipe. Result is 0 if the operation is successful and a negative value if the pipe is full.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Pipe must have a type of OpTypePipe with WriteOnly access qualifier.</para>
    /// <para>Pointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpWritePipe(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef pointer, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(pointer) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpWritePipe, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpReservedReadPipe(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef reserveId, IdRef index, IdRef pointer, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(index) + buffer.GetWordLength(pointer) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReservedReadPipe, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..index.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReservedReadPipe</c></para>
    /// <para>Read a packet from the reserved area specified by Reserve Id and Index of the pipe object specified by Pipe into Pointer. The reserved pipe entries are referred to by indices that go from 0 …​ Num Packets - 1. Result is 0 if the operation is successful and a negative value otherwise.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Pipe must have a type of OpTypePipe with ReadOnly access qualifier.</para>
    /// <para>Reserve Id must have a type of OpTypeReserveId.</para>
    /// <para>Index must be a 32-bit integer type scalar, which is treated as an unsigned value.</para>
    /// <para>Pointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpReservedReadPipe(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef reserveId, IdRef index, IdRef pointer, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(index) + buffer.GetWordLength(pointer) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReservedReadPipe, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..index.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpReservedWritePipe(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef reserveId, IdRef index, IdRef pointer, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(index) + buffer.GetWordLength(pointer) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReservedWritePipe, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..index.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReservedWritePipe</c></para>
    /// <para>Write a packet from Pointer into the reserved area specified by Reserve Id and Index of the pipe object specified by Pipe. The reserved pipe entries are referred to by indices that go from 0 …​ Num Packets - 1. Result is 0 if the operation is successful and a negative value otherwise.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Pipe must have a type of OpTypePipe with WriteOnly access qualifier.</para>
    /// <para>Reserve Id must have a type of OpTypeReserveId.</para>
    /// <para>Index must be a 32-bit integer type scalar, which is treated as an unsigned value.</para>
    /// <para>Pointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpReservedWritePipe(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef reserveId, IdRef index, IdRef pointer, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(index) + buffer.GetWordLength(pointer) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReservedWritePipe, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..index.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpReserveReadPipePackets(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef numPackets, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(numPackets) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReserveReadPipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..numPackets.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReserveReadPipePackets</c></para>
    /// <para>Reserve Num Packets entries for reading from the pipe object specified by Pipe. Result is a valid reservation ID if the reservation is successful.</para>
    /// <para>Result Type must be an OpTypeReserveId.</para>
    /// <para>Pipe must have a type of OpTypePipe with ReadOnly access qualifier.</para>
    /// <para>Num Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpReserveReadPipePackets(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef numPackets, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(numPackets) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReserveReadPipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..numPackets.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpReserveWritePipePackets(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef numPackets, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(numPackets) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReserveWritePipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..numPackets.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReserveWritePipePackets</c></para>
    /// <para>Reserve num_packets entries for writing to the pipe object specified by Pipe. Result is a valid reservation ID if the reservation is successful.</para>
    /// <para>Pipe must have a type of OpTypePipe with WriteOnly access qualifier.</para>
    /// <para>Num Packets must be a 32-bit OpTypeInt which is treated as an unsigned value.</para>
    /// <para>Result Type must be an OpTypeReserveId.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpReserveWritePipePackets(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef numPackets, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(numPackets) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReserveWritePipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..numPackets.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpCommitReadPipe(this SpirvBuffer buffer, IdRef pipe, IdRef reserveId, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCommitReadPipe, ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCommitReadPipe</c></para>
    /// <para>Indicates that all reads to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe are completed.</para>
    /// <para>Pipe must have a type of OpTypePipe with ReadOnly access qualifier.</para>
    /// <para>Reserve Id must have a type of OpTypeReserveId.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpCommitReadPipe(this SpirvBuffer buffer, int position, IdRef pipe, IdRef reserveId, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCommitReadPipe, ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpCommitWritePipe(this SpirvBuffer buffer, IdRef pipe, IdRef reserveId, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCommitWritePipe, ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCommitWritePipe</c></para>
    /// <para>Indicates that all writes to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe are completed.</para>
    /// <para>Pipe must have a type of OpTypePipe with WriteOnly access qualifier.</para>
    /// <para>Reserve Id must have a type of OpTypeReserveId.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpCommitWritePipe(this SpirvBuffer buffer, int position, IdRef pipe, IdRef reserveId, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCommitWritePipe, ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpIsValidReserveId(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef reserveId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(reserveId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIsValidReserveId, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..reserveId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIsValidReserveId</c></para>
    /// <para>Result is true if Reserve Id is a valid reservation id and false otherwise.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Reserve Id must have a type of OpTypeReserveId.</para>
    /// </summary>
    public static Instruction InsertOpIsValidReserveId(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef reserveId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(reserveId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIsValidReserveId, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..reserveId.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetNumPipePackets(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetNumPipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetNumPipePackets</c></para>
    /// <para>Result is the number of available entries in the pipe object specified by Pipe. The number of available entries in a pipe is a dynamic value.  The result is considered immediately stale.</para>
    /// <para>Result Type must be a 32-bit integer type scalar, which should be treated as an unsigned value.</para>
    /// <para>Pipe must have a type of OpTypePipe with ReadOnly or WriteOnly access qualifier.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpGetNumPipePackets(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetNumPipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetMaxPipePackets(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetMaxPipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetMaxPipePackets</c></para>
    /// <para>Result is the maximum number of packets specified by the creation of Pipe.</para>
    /// <para>Result Type must be a 32-bit integer type scalar, which should be treated as an unsigned value.</para>
    /// <para>Pipe must have a type of OpTypePipe with ReadOnly or WriteOnly access qualifier.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpGetMaxPipePackets(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipe, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipe) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetMaxPipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupReserveReadPipePackets(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef pipe, IdRef numPackets, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(pipe) + buffer.GetWordLength(numPackets) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupReserveReadPipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..numPackets.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupReserveReadPipePackets</c></para>
    /// <para>Reserve Num Packets entries for the scope restricted tangle for reading from the pipe object specified by Pipe. Result is a valid reservation id if the reservation is successful.</para>
    /// <para>The reserved pipe entries are referred to by indices that go from 0 …​ Num Packets - 1.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type must be an OpTypeReserveId.</para>
    /// <para>Pipe must have a type of OpTypePipe with ReadOnly access qualifier.</para>
    /// <para>Num Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpGroupReserveReadPipePackets(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef pipe, IdRef numPackets, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(pipe) + buffer.GetWordLength(numPackets) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupReserveReadPipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..numPackets.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupReserveWritePipePackets(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef pipe, IdRef numPackets, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(pipe) + buffer.GetWordLength(numPackets) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupReserveWritePipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..numPackets.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupReserveWritePipePackets</c></para>
    /// <para>Reserve Num Packets entries for the scope restricted tangle for writing to the pipe object specified by Pipe. Result is a valid reservation id if the reservation is successful.</para>
    /// <para>The reserved pipe entries are referred to by indices that go from 0 …​ Num Packets - 1.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type must be an OpTypeReserveId.</para>
    /// <para>Pipe must have a type of OpTypePipe with WriteOnly access qualifier.</para>
    /// <para>Num Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpGroupReserveWritePipePackets(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef pipe, IdRef numPackets, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(pipe) + buffer.GetWordLength(numPackets) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupReserveWritePipePackets, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..numPackets.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupCommitReadPipe(this SpirvBuffer buffer, IdScope execution, IdRef pipe, IdRef reserveId, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupCommitReadPipe, ..execution.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupCommitReadPipe</c></para>
    /// <para>Indicates that all reads to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe were completed by the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Pipe must have a type of OpTypePipe with ReadOnly access qualifier.</para>
    /// <para>Reserve Id must have a type of OpTypeReserveId.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpGroupCommitReadPipe(this SpirvBuffer buffer, int position, IdScope execution, IdRef pipe, IdRef reserveId, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupCommitReadPipe, ..execution.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupCommitWritePipe(this SpirvBuffer buffer, IdScope execution, IdRef pipe, IdRef reserveId, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupCommitWritePipe, ..execution.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupCommitWritePipe</c></para>
    /// <para>Indicates that all writes to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe were completed by the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Pipe must have a type of OpTypePipe with WriteOnly access qualifier.</para>
    /// <para>Reserve Id must have a type of OpTypeReserveId.</para>
    /// <para>Packet Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.</para>
    /// <para>Packet Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// </summary>
    public static Instruction InsertOpGroupCommitWritePipe(this SpirvBuffer buffer, int position, IdScope execution, IdRef pipe, IdRef reserveId, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(pipe) + buffer.GetWordLength(reserveId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupCommitWritePipe, ..execution.AsSpirvSpan(), ..pipe.AsSpirvSpan(), ..reserveId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpEnqueueMarker(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef queue, IdRef numEvents, IdRef waitEvents, IdRef retEvent)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(queue) + buffer.GetWordLength(numEvents) + buffer.GetWordLength(waitEvents) + buffer.GetWordLength(retEvent);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpEnqueueMarker, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..queue.AsSpirvSpan(), ..numEvents.AsSpirvSpan(), ..waitEvents.AsSpirvSpan(), ..retEvent.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpEnqueueMarker</c></para>
    /// <para>Enqueue a marker command to the queue object specified by Queue. The marker command waits for a list of events to complete, or if the list is empty it waits for all previously enqueued commands in Queue to complete before the marker completes.</para>
    /// <para>Result Type must be a 32-bit integer type scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.</para>
    /// <para>Queue must be of the type OpTypeQueue.</para>
    /// <para>Num Events specifies the number of event objects in the wait list pointed to by Wait Events and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Wait Events specifies the list of wait event objects and must be a pointer to OpTypeDeviceEvent.</para>
    /// <para>Ret Event is a pointer to a device event which gets implicitly retained by this instruction.  It must have a type of OpTypePointer to OpTypeDeviceEvent. If Ret Event is set to null this instruction becomes a no-op.</para>
    /// </summary>
    public static Instruction InsertOpEnqueueMarker(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef queue, IdRef numEvents, IdRef waitEvents, IdRef retEvent)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(queue) + buffer.GetWordLength(numEvents) + buffer.GetWordLength(waitEvents) + buffer.GetWordLength(retEvent);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpEnqueueMarker, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..queue.AsSpirvSpan(), ..numEvents.AsSpirvSpan(), ..waitEvents.AsSpirvSpan(), ..retEvent.AsSpirvSpan()]);
    }

    public static Instruction AddOpEnqueueKernel(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef queue, IdRef flags, IdRef nDRange, IdRef numEvents, IdRef waitEvents, IdRef retEvent, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(queue) + buffer.GetWordLength(flags) + buffer.GetWordLength(nDRange) + buffer.GetWordLength(numEvents) + buffer.GetWordLength(waitEvents) + buffer.GetWordLength(retEvent) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpEnqueueKernel, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..queue.AsSpirvSpan(), ..flags.AsSpirvSpan(), ..nDRange.AsSpirvSpan(), ..numEvents.AsSpirvSpan(), ..waitEvents.AsSpirvSpan(), ..retEvent.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpEnqueueKernel</c></para>
    /// <para>Enqueue the function specified by Invoke and the NDRange specified by ND Range for execution to the queue object specified by Queue. </para>
    /// <para>Result Type must be a 32-bit integer type scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.</para>
    /// <para>Queue must be of the type OpTypeQueue.</para>
    /// <para>Flags must be an integer type scalar.  The content of Flags is interpreted as Kernel Enqueue Flags mask.</para>
    /// <para>The type of ND Range must be an OpTypeStruct whose members are as described by the Result Type of OpBuildNDRange.</para>
    /// <para>Num Events specifies the number of event objects in the wait list pointed to by Wait Events and must be 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Wait Events specifies the list of wait event objects and must be a pointer to OpTypeDeviceEvent.</para>
    /// <para>Ret Event must be a pointer to OpTypeDeviceEvent which gets implicitly retained by this instruction. </para>
    /// <para>Invoke must be an OpFunction whose OpTypeFunction operand has:</para>
    /// <para>- Result Type must be OpTypeVoid.</para>
    /// <para>- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.</para>
    /// <para>- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.</para>
    /// <para>Param is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.</para>
    /// <para>Param Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Param Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Each Local Size operand corresponds (in order) to one OpTypePointer to Workgroup Storage Class parameter to the Invoke function, and specifies the number of bytes of Workgroup storage used to back the pointer during the execution of the Invoke function.</para>
    /// </summary>
    public static Instruction InsertOpEnqueueKernel(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef queue, IdRef flags, IdRef nDRange, IdRef numEvents, IdRef waitEvents, IdRef retEvent, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(queue) + buffer.GetWordLength(flags) + buffer.GetWordLength(nDRange) + buffer.GetWordLength(numEvents) + buffer.GetWordLength(waitEvents) + buffer.GetWordLength(retEvent) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpEnqueueKernel, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..queue.AsSpirvSpan(), ..flags.AsSpirvSpan(), ..nDRange.AsSpirvSpan(), ..numEvents.AsSpirvSpan(), ..waitEvents.AsSpirvSpan(), ..retEvent.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetKernelNDrangeSubGroupCount(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef nDRange, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(nDRange) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetKernelNDrangeSubGroupCount, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..nDRange.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetKernelNDrangeSubGroupCount</c></para>
    /// <para>Result is the number of subgroups in each workgroup of the dispatch (except for the last in cases where the global size does not divide cleanly into workgroups) given the combination of the passed NDRange descriptor specified by ND Range and the function specified by Invoke.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>The type of ND Range must be an OpTypeStruct whose members are as described by the Result Type of OpBuildNDRange.</para>
    /// <para>Invoke must be an OpFunction whose OpTypeFunction operand has:</para>
    /// <para>- Result Type must be OpTypeVoid.</para>
    /// <para>- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.</para>
    /// <para>- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.</para>
    /// <para>Param is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.</para>
    /// <para>Param Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Param Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// </summary>
    public static Instruction InsertOpGetKernelNDrangeSubGroupCount(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef nDRange, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(nDRange) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetKernelNDrangeSubGroupCount, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..nDRange.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetKernelNDrangeMaxSubGroupSize(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef nDRange, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(nDRange) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetKernelNDrangeMaxSubGroupSize, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..nDRange.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetKernelNDrangeMaxSubGroupSize</c></para>
    /// <para>Result is the maximum subgroup size for the function specified by Invoke and the NDRange specified by ND Range. </para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>The type of ND Range must be an OpTypeStruct whose members are as described by the Result Type of OpBuildNDRange.</para>
    /// <para>Invoke must be an OpFunction whose OpTypeFunction operand has:</para>
    /// <para>- Result Type must be OpTypeVoid.</para>
    /// <para>- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.</para>
    /// <para>- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.</para>
    /// <para>Param is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.</para>
    /// <para>Param Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Param Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// </summary>
    public static Instruction InsertOpGetKernelNDrangeMaxSubGroupSize(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef nDRange, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(nDRange) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetKernelNDrangeMaxSubGroupSize, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..nDRange.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetKernelWorkGroupSize(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetKernelWorkGroupSize, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetKernelWorkGroupSize</c></para>
    /// <para>Result is the maximum workgroup size that can be used to execute the function specified by Invoke on the device.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Invoke must be an OpFunction whose OpTypeFunction operand has:</para>
    /// <para>- Result Type must be OpTypeVoid.</para>
    /// <para>- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.</para>
    /// <para>- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.</para>
    /// <para>Param is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.</para>
    /// <para>Param Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Param Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// </summary>
    public static Instruction InsertOpGetKernelWorkGroupSize(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetKernelWorkGroupSize, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetKernelPreferredWorkGroupSizeMultiple(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetKernelPreferredWorkGroupSizeMultiple, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetKernelPreferredWorkGroupSizeMultiple</c></para>
    /// <para>Result is the preferred multiple of workgroup size for the function specified by Invoke. This is a performance hint. Specifying a workgroup size that is not a multiple of this result as the value of the local work size does not fail to enqueue Invoke for execution unless the workgroup size specified is larger than the device maximum.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Invoke must be an OpFunction whose OpTypeFunction operand has:</para>
    /// <para>- Result Type must be OpTypeVoid.</para>
    /// <para>- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.</para>
    /// <para>- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.</para>
    /// <para>Param is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.</para>
    /// <para>Param Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Param Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// </summary>
    public static Instruction InsertOpGetKernelPreferredWorkGroupSizeMultiple(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetKernelPreferredWorkGroupSizeMultiple, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    public static Instruction AddOpRetainEvent(this SpirvBuffer buffer, IdRef eventId)
    {
        var wordLength = 1 + buffer.GetWordLength(eventId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRetainEvent, ..eventId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRetainEvent</c></para>
    /// <para>Increments the reference count of the event object specified by Event.</para>
    /// <para>Behavior is undefined if Event is not a valid event.</para>
    /// </summary>
    public static Instruction InsertOpRetainEvent(this SpirvBuffer buffer, int position, IdRef eventId)
    {
        var wordLength = 1 + buffer.GetWordLength(eventId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRetainEvent, ..eventId.AsSpirvSpan()]);
    }

    public static Instruction AddOpReleaseEvent(this SpirvBuffer buffer, IdRef eventId)
    {
        var wordLength = 1 + buffer.GetWordLength(eventId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReleaseEvent, ..eventId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReleaseEvent</c></para>
    /// <para>Decrements the reference count of the event object specified by Event. The event object is deleted once the event reference count is zero, the specific command identified by this event has completed (or terminated) and there are no commands in any device command queue that require a wait for this event to complete.</para>
    /// <para>Behavior is undefined if Event is not a valid event.</para>
    /// </summary>
    public static Instruction InsertOpReleaseEvent(this SpirvBuffer buffer, int position, IdRef eventId)
    {
        var wordLength = 1 + buffer.GetWordLength(eventId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReleaseEvent, ..eventId.AsSpirvSpan()]);
    }

    public static Instruction AddOpCreateUserEvent(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCreateUserEvent, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCreateUserEvent</c></para>
    /// <para>Create a user event. The execution status of the created event is set to a value of 2 (CL_SUBMITTED).</para>
    /// <para>Result Type must be OpTypeDeviceEvent.</para>
    /// </summary>
    public static Instruction InsertOpCreateUserEvent(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCreateUserEvent, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpIsValidEvent(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef eventId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(eventId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIsValidEvent, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..eventId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIsValidEvent</c></para>
    /// <para>Result is true if the event specified by Event is a valid event, otherwise false.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Event must have a type of OpTypeDeviceEvent</para>
    /// </summary>
    public static Instruction InsertOpIsValidEvent(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef eventId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(eventId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIsValidEvent, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..eventId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSetUserEventStatus(this SpirvBuffer buffer, IdRef eventId, IdRef status)
    {
        var wordLength = 1 + buffer.GetWordLength(eventId) + buffer.GetWordLength(status);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSetUserEventStatus, ..eventId.AsSpirvSpan(), ..status.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSetUserEventStatus</c></para>
    /// <para>Sets the execution status of a user event specified by Event.Status can be either 0 (CL_COMPLETE) to indicate that this kernel and all its child kernels finished execution successfully, or a negative integer value indicating an error.</para>
    /// <para>Event must have a type of OpTypeDeviceEvent that was produced by OpCreateUserEvent.</para>
    /// <para>Status must have a type of 32-bit OpTypeInt treated as a signed integer.</para>
    /// </summary>
    public static Instruction InsertOpSetUserEventStatus(this SpirvBuffer buffer, int position, IdRef eventId, IdRef status)
    {
        var wordLength = 1 + buffer.GetWordLength(eventId) + buffer.GetWordLength(status);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSetUserEventStatus, ..eventId.AsSpirvSpan(), ..status.AsSpirvSpan()]);
    }

    public static Instruction AddOpCaptureEventProfilingInfo(this SpirvBuffer buffer, IdRef eventId, IdRef profilingInfo, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(eventId) + buffer.GetWordLength(profilingInfo) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCaptureEventProfilingInfo, ..eventId.AsSpirvSpan(), ..profilingInfo.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCaptureEventProfilingInfo</c></para>
    /// <para>Captures the profiling information specified by Profiling Info for the command associated with the event specified by Event in the memory pointed to by Value.The profiling information is available in the memory pointed to by Value after the command identified by Event has completed.</para>
    /// <para>Event must have a type of OpTypeDeviceEvent that was produced by OpEnqueueKernel or OpEnqueueMarker. </para>
    /// <para>Profiling Info must be an integer type scalar.  The content of Profiling Info is interpreted as Kernel Profiling Info mask.</para>
    /// <para>Value must be a pointer to a scalar 8-bit integer type in the CrossWorkgroup Storage Class.</para>
    /// <para>If Profiling Info is CmdExecTime, Value behavior is defined only if it points to 128-bit memory range.</para>
    /// <para> The first 64 bits contain the elapsed time CL_PROFILING_COMMAND_END - CL_PROFILING_COMMAND_START for the command identified by Event in nanoseconds.</para>
    /// <para> The second 64 bits contain the elapsed time CL_PROFILING_COMMAND_COMPLETE - CL_PROFILING_COMMAND_START for the command identified by Event in nanoseconds.</para>
    /// <para>Note: What is captured is undefined if this instruction is called multiple times for the same event.</para>
    /// </summary>
    public static Instruction InsertOpCaptureEventProfilingInfo(this SpirvBuffer buffer, int position, IdRef eventId, IdRef profilingInfo, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(eventId) + buffer.GetWordLength(profilingInfo) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCaptureEventProfilingInfo, ..eventId.AsSpirvSpan(), ..profilingInfo.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetDefaultQueue(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetDefaultQueue, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetDefaultQueue</c></para>
    /// <para>The result is the default device queue, or if a default device queue has not been created, a null queue object.</para>
    /// <para>Result Type must be an OpTypeQueue.</para>
    /// </summary>
    public static Instruction InsertOpGetDefaultQueue(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetDefaultQueue, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpBuildNDRange(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef globalWorkSize, IdRef localWorkSize, IdRef globalWorkOffset)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(globalWorkSize) + buffer.GetWordLength(localWorkSize) + buffer.GetWordLength(globalWorkOffset);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpBuildNDRange, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..globalWorkSize.AsSpirvSpan(), ..localWorkSize.AsSpirvSpan(), ..globalWorkOffset.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpBuildNDRange</c></para>
    /// <para>Given the global work size specified by GlobalWorkSize, local work size specified by LocalWorkSize and global work offset specified by GlobalWorkOffset, builds the result as a 1D, 2D, or 3D ND-range descriptor structure.</para>
    /// <para>Result Type must be an OpTypeStruct with the following ordered list of members, starting from the first to last:</para>
    /// <para>   1) A 32-bit integer type scalar that specifies the number of dimensions in the global size and the workgroup size. </para>
    /// <para>   2) An OpTypeArray with 3 elements, where each element is a 32-bit integer type scalar if the addressing model is Physical32 or a 64-bit integer type scalar if the addressing model is Physical64. This is an array of per-dimension unsigned values that specifies the global offset used to calculate the global ID for an invocation.</para>
    /// <para>   3) An OpTypeArray with 3 elements, where each element is a 32-bit integer type scalar if the addressing model is Physical32 or a 64-bit integer type scalar if the addressing model is Physical64. This is an array of per-dimension unsigned values that specifies the number of global invocations that execute the kernel function.</para>
    /// <para>   4) An OpTypeArray with 3 elements, where each element is a 32-bit integer type scalar if the addressing model is Physical32 or a 64-bit integer type scalar if the addressing model is Physical64. This is an array of per-dimension unsigned values that specifies the number of invocations in a workgroup.</para>
    /// <para>GlobalWorkSize must be a scalar or an array with 2 or 3 components. Where the type of each element in the array is 32-bit integer type scalar if the addressing model is Physical32 or 64-bit integer type scalar if the addressing model is Physical64.</para>
    /// <para>The type of LocalWorkSize must be the same as GlobalWorkSize.</para>
    /// <para>The type of GlobalWorkOffset must be the same as GlobalWorkSize.</para>
    /// </summary>
    public static Instruction InsertOpBuildNDRange(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef globalWorkSize, IdRef localWorkSize, IdRef globalWorkOffset)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(globalWorkSize) + buffer.GetWordLength(localWorkSize) + buffer.GetWordLength(globalWorkOffset);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpBuildNDRange, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..globalWorkSize.AsSpirvSpan(), ..localWorkSize.AsSpirvSpan(), ..globalWorkOffset.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseSampleImplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseSampleImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseSampleImplicitLod</c></para>
    /// <para>Sample a sparse image with an implicit level of detail.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseSampleImplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseSampleImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseSampleExplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseSampleExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseSampleExplicitLod</c></para>
    /// <para>Sample a sparse image using an explicit level of detail.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. Unless the Kernel capability is declared, it must be floating point. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseSampleExplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseSampleExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseSampleDrefImplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseSampleDrefImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseSampleDrefImplicitLod</c></para>
    /// <para>Sample a sparse image doing depth-comparison with an implicit level of detail.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its derivative group have executed all dynamic instances that are program-ordered before X'.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseSampleDrefImplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseSampleDrefImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseSampleDrefExplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseSampleDrefExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseSampleDrefExplicitLod</c></para>
    /// <para>Sample a sparse image doing depth-comparison using an explicit level of detail.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseSampleDrefExplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseSampleDrefExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseSampleProjImplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseSampleProjImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseSampleDrefExplicitLod</c></para>
    /// <para>Sample a sparse image doing depth-comparison using an explicit level of detail.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseSampleProjImplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseSampleProjImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseSampleProjExplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseSampleProjExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseSampleDrefExplicitLod</c></para>
    /// <para>Sample a sparse image doing depth-comparison using an explicit level of detail.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseSampleProjExplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseSampleProjExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseSampleProjDrefImplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseSampleProjDrefImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseSampleDrefExplicitLod</c></para>
    /// <para>Sample a sparse image doing depth-comparison using an explicit level of detail.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseSampleProjDrefImplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseSampleProjDrefImplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseSampleProjDrefExplicitLod(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseSampleProjDrefExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseSampleDrefExplicitLod</c></para>
    /// <para>Sample a sparse image doing depth-comparison using an explicit level of detail.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must not have a Dim of Buffer. The MS operand of the underlying OpTypeImage must be 0.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseSampleProjDrefExplicitLod(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseSampleProjDrefExplicitLod, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseFetch(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseFetch, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseFetch</c></para>
    /// <para>Fetch a single texel from a sampled sparse image whose Sampled operand is 1.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</para>
    /// <para>Image must be an object whose type is OpTypeImage. Its Dim operand must not be Cube.</para>
    /// <para>Coordinate  must be a scalar or vector of integer type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseFetch(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseFetch, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseGather(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef component, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(component) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseGather, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..component.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseGather</c></para>
    /// <para>Gathers the requested component from four texels of a sparse image.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image.</para>
    /// <para>Component is the component number gathered from all four texels. It must be a 32-bit integer type scalar.  Behavior is undefined if its value is not 0, 1, 2 or 3.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseGather(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef component, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(component) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseGather, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..component.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseDrefGather(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseDrefGather, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseDrefGather</c></para>
    /// <para>Gathers the requested depth-comparison from four texels of a sparse image.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.</para>
    /// <para>Sampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] …​ [, array layer]) as needed by the definition of Sampled Image.</para>
    /// <para>Dref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar. </para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseDrefGather(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef dref, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(dref) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseDrefGather, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..dref.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseTexelsResident(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef residentCode)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(residentCode);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseTexelsResident, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..residentCode.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseTexelsResident</c></para>
    /// <para>Translates a Resident Code into a Boolean. Result is false if any of the texels were in uncommitted texture memory, and true otherwise.</para>
    /// <para> Result Type must be a Boolean type scalar. </para>
    /// <para>Resident Code is a value from an OpImageSparse…​ instruction that results in a resident code.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseTexelsResident(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef residentCode)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(residentCode);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseTexelsResident, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..residentCode.AsSpirvSpan()]);
    }

    public static Instruction AddOpNoLine(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpNoLine]);
    }

    /// <summary>
    /// <para><c>OpNoLine</c></para>
    /// <para>Discontinue any source-level location information that might be active from a previous OpLine instruction. This has no semantic impact and can safely be removed from a module.</para>
    /// <para>This instruction must only appear after the annotation instructions (see the Logical Layout section). It must not be the last instruction in a block, or the second-to-last instruction if the block has a merge instruction. There is not a requirement that there is a preceding OpLine instruction.</para>
    /// </summary>
    public static Instruction InsertOpNoLine(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpNoLine]);
    }

    public static Instruction AddOpAtomicFlagTestAndSet(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicFlagTestAndSet, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicFlagTestAndSet</c></para>
    /// <para>Atomically sets the flag value pointed to by Pointer to the set state.</para>
    /// <para>Pointer must be a pointer to a 32-bit integer type representing an atomic flag.</para>
    /// <para>The instruction’s result is true if the flag was in the set state or false if the flag was in the clear state immediately before the operation.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>The resulting values are undefined if an atomic flag is modified by an instruction other than OpAtomicFlagTestAndSet or OpAtomicFlagClear.</para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicFlagTestAndSet(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicFlagTestAndSet, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicFlagClear(this SpirvBuffer buffer, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicFlagClear, ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicFlagClear</c></para>
    /// <para>Atomically sets the flag value pointed to by Pointer to the clear state.</para>
    /// <para>Pointer must be a pointer to a 32-bit integer type representing an atomic flag.</para>
    /// <para>Memory Semantics must not be Acquire or AcquireRelease</para>
    /// <para>The resulting values are undefined if an atomic flag is modified by an instruction other than OpAtomicFlagTestAndSet or OpAtomicFlagClear.</para>
    /// <para>Memory is a memory Scope.</para>
    /// </summary>
    public static Instruction InsertOpAtomicFlagClear(this SpirvBuffer buffer, int position, IdRef pointer, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicFlagClear, ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSparseRead(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSparseRead, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSparseRead</c></para>
    /// <para>Read a texel from a sparse image without a sampler.</para>
    /// <para>Result Type must be an OpTypeStruct with two members. The first member’s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar or vector of floating-point type or integer type.  It must be a scalar or vector with component type the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).</para>
    /// <para>Image must be an object whose type is OpTypeImage with a Sampled operand of 2.</para>
    /// <para>Coordinate  must be a scalar or vector of floating-point type or integer type.  It contains non-normalized texel coordinates (u[, v] …​ [, array layer]) as needed by the definition of Image. See the client API specification for handling of coordinates outside the image.</para>
    /// <para>The Image Dim operand must not be SubpassData. The Image Format must not be Unknown unless the StorageImageReadWithoutFormat Capability was declared.</para>
    /// <para>Image Operands encodes what operands follow, as per Image Operands.</para>
    /// </summary>
    public static Instruction InsertOpImageSparseRead(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSparseRead, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpSizeOf(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSizeOf, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSizeOf</c></para>
    /// <para>Computes the run-time size of the type pointed to by Pointer</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Pointer must point to a concrete type.</para>
    /// </summary>
    public static Instruction InsertOpSizeOf(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSizeOf, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypePipeStorage(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypePipeStorage, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypePipeStorage</c></para>
    /// <para>Declare the OpenCL pipe-storage type.</para>
    /// </summary>
    public static Instruction InsertOpTypePipeStorage(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypePipeStorage, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantPipeStorage(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, LiteralInteger packetSize, LiteralInteger packetAlignment, LiteralInteger capacity)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment) + buffer.GetWordLength(capacity);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantPipeStorage, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan(), ..capacity.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantPipeStorage</c></para>
    /// <para>Creates a pipe-storage object.</para>
    /// <para>Result Type must be OpTypePipeStorage.</para>
    /// <para> Packet Size is an unsigned 32-bit integer.  It represents the size in bytes of each packet in the pipe.</para>
    /// <para> Packet Alignment is an unsigned 32-bit integer.  It represents the alignment in bytes of each packet in the pipe.</para>
    /// <para>Behavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.</para>
    /// <para> Capacity is an unsigned 32-bit integer.  It is the minimum number of Packet Size blocks the resulting OpTypePipeStorage can hold.</para>
    /// </summary>
    public static Instruction InsertOpConstantPipeStorage(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, LiteralInteger packetSize, LiteralInteger packetAlignment, LiteralInteger capacity)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment) + buffer.GetWordLength(capacity);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantPipeStorage, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan(), ..capacity.AsSpirvSpan()]);
    }

    public static Instruction AddOpCreatePipeFromPipeStorage(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pipeStorage)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipeStorage);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCreatePipeFromPipeStorage, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipeStorage.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCreatePipeFromPipeStorage</c></para>
    /// <para>Creates a pipe object from a pipe-storage object.</para>
    /// <para>Result Type must be OpTypePipe.</para>
    /// <para>Pipe Storage must be a pipe-storage object created from OpConstantPipeStorage.</para>
    /// <para>Qualifier is the pipe access qualifier.</para>
    /// </summary>
    public static Instruction InsertOpCreatePipeFromPipeStorage(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pipeStorage)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pipeStorage);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCreatePipeFromPipeStorage, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pipeStorage.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetKernelLocalSizeForSubgroupCount(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef subgroupCount, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(subgroupCount) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetKernelLocalSizeForSubgroupCount, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..subgroupCount.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetKernelLocalSizeForSubgroupCount</c></para>
    /// <para>Result is the 1D local size to enqueue Invoke with Subgroup Count subgroups per workgroup.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Subgroup Count must be a 32-bit integer type scalar.</para>
    /// <para>Invoke must be an OpFunction whose OpTypeFunction operand has:</para>
    /// <para>- Result Type must be OpTypeVoid.</para>
    /// <para>- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.</para>
    /// <para>- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.</para>
    /// <para>Param is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.</para>
    /// <para>Param Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Param Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// </summary>
    public static Instruction InsertOpGetKernelLocalSizeForSubgroupCount(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef subgroupCount, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(subgroupCount) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetKernelLocalSizeForSubgroupCount, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..subgroupCount.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    public static Instruction AddOpGetKernelMaxNumSubgroups(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGetKernelMaxNumSubgroups, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGetKernelMaxNumSubgroups</c></para>
    /// <para>Result is the maximum number of subgroups that can be used to execute Invoke on the device.</para>
    /// <para>Result Type must be a 32-bit integer type scalar.</para>
    /// <para>Invoke must be an OpFunction whose OpTypeFunction operand has:</para>
    /// <para>- Result Type must be OpTypeVoid.</para>
    /// <para>- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.</para>
    /// <para>- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.</para>
    /// <para>Param is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.</para>
    /// <para>Param Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// <para>Param Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.</para>
    /// </summary>
    public static Instruction InsertOpGetKernelMaxNumSubgroups(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef invoke, IdRef param, IdRef paramSize, IdRef paramAlign)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(invoke) + buffer.GetWordLength(param) + buffer.GetWordLength(paramSize) + buffer.GetWordLength(paramAlign);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGetKernelMaxNumSubgroups, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..invoke.AsSpirvSpan(), ..param.AsSpirvSpan(), ..paramSize.AsSpirvSpan(), ..paramAlign.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeNamedBarrier(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeNamedBarrier, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeNamedBarrier</c></para>
    /// <para>Declare the named-barrier type.</para>
    /// </summary>
    public static Instruction InsertOpTypeNamedBarrier(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeNamedBarrier, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpNamedBarrierInitialize(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef subgroupCount)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(subgroupCount);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpNamedBarrierInitialize, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..subgroupCount.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpNamedBarrierInitialize</c></para>
    /// <para>Declare a new named-barrier object.</para>
    /// <para>Result Type must be the type OpTypeNamedBarrier.</para>
    /// <para>Subgroup Count must be a 32-bit integer type scalar representing the number of subgroups that must reach the current point of execution.</para>
    /// </summary>
    public static Instruction InsertOpNamedBarrierInitialize(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef subgroupCount)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(subgroupCount);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpNamedBarrierInitialize, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..subgroupCount.AsSpirvSpan()]);
    }

    public static Instruction AddOpMemoryNamedBarrier(this SpirvBuffer buffer, IdRef namedBarrier, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(namedBarrier) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMemoryNamedBarrier, ..namedBarrier.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemoryNamedBarrier</c></para>
    /// <para>Wait for other invocations of this module to reach the current point of execution.</para>
    /// <para>Named Barrier must be the type OpTypeNamedBarrier.</para>
    /// <para>If Semantics is not None, this instruction also serves as an OpMemoryBarrier instruction, and also performs and adheres to the description and semantics of an OpMemoryBarrier instruction with the same Memory and Semantics operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If Semantics None, Memory is ignored.</para>
    /// </summary>
    public static Instruction InsertOpMemoryNamedBarrier(this SpirvBuffer buffer, int position, IdRef namedBarrier, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(namedBarrier) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMemoryNamedBarrier, ..namedBarrier.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpModuleProcessed(this SpirvBuffer buffer, LiteralString process)
    {
        var wordLength = 1 + buffer.GetWordLength(process);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpModuleProcessed, ..process.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpModuleProcessed</c></para>
    /// <para>Document a process that was applied to a module. This has no semantic impact and can safely be removed from a module.</para>
    /// <para>Process is a string describing a process and/or tool (processor) that did the processing. Its form is dependent on the processor.</para>
    /// </summary>
    public static Instruction InsertOpModuleProcessed(this SpirvBuffer buffer, int position, LiteralString process)
    {
        var wordLength = 1 + buffer.GetWordLength(process);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpModuleProcessed, ..process.AsSpirvSpan()]);
    }

    public static Instruction AddOpExecutionModeId(this SpirvBuffer buffer, IdRef entryPoint, ExecutionMode mode)
    {
        var wordLength = 1 + buffer.GetWordLength(entryPoint) + buffer.GetWordLength(mode);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExecutionModeId, ..entryPoint.AsSpirvSpan(), ..mode.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExecutionModeId</c></para>
    /// <para>Declare an execution mode for an entry point, using <c>id</c>s as Extra Operands.</para>
    /// <para>Entry Point must be the Entry Point <c>id</c> operand of an OpEntryPoint instruction.</para>
    /// <para>Mode is the execution mode. See Execution Mode.</para>
    /// <para>This instruction is only valid if the Mode operand is an execution mode that takes Extra Operands that are <c>id</c> operands.</para>
    /// </summary>
    public static Instruction InsertOpExecutionModeId(this SpirvBuffer buffer, int position, IdRef entryPoint, ExecutionMode mode)
    {
        var wordLength = 1 + buffer.GetWordLength(entryPoint) + buffer.GetWordLength(mode);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExecutionModeId, ..entryPoint.AsSpirvSpan(), ..mode.AsSpirvSpan()]);
    }

    public static Instruction AddOpDecorateId(this SpirvBuffer buffer, IdRef target, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDecorate, target, ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDecorateId</c></para>
    /// <para>Add a Decoration to another <c>id</c>, using <c>id</c>s as Extra Operands.</para>
    /// <para>Target is the <c>id</c> to decorate.  It can potentially be any <c>id</c> that is a forward reference. A set of decorations can be grouped together by having multiple decoration instructions targeting the same OpDecorationGroup instruction.</para>
    /// <para>This instruction is only valid if the Decoration operand is a decoration that takes Extra Operands that are <c>id</c> operands. All such <c>id</c> Extra Operands must be constant instructions or OpVariable instructions.</para>
    /// </summary>
    public static Instruction InsertOpDecorateId(this SpirvBuffer buffer, int position, IdRef target, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDecorate, target, ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformElect(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformElect, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformElect</c></para>
    /// <para>Result is true only in the tangled invocation with the lowest id within the Execution scope, otherwise result is false.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformElect(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformElect, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformAll(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformAll, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformAll</c></para>
    /// <para>Evaluates a predicate for all tangled invocations within the Execution scope, resulting in true if predicate evaluates to true for all tangled invocations within the Execution scope, otherwise the result is false.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>Predicate must be a Boolean type.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformAll(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformAll, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformAny(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformAny, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformAny</c></para>
    /// <para>Evaluates a predicate for all tangled invocations within the Execution scope, resulting in true if predicate evaluates to true for any tangled invocations within the Execution scope, otherwise the result is false.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>Predicate must be a Boolean type.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformAny(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformAny, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformAllEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformAllEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformAllEqual</c></para>
    /// <para>Evaluates a value for all tangled invocations within the Execution scope. The result is true if Value is equal for all tangled invocations within the Execution scope. Otherwise, the result is false.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>Value  must be a scalar or vector of floating-point type, integer type, or Boolean type. The compare operation is based on this type, and if it is a floating-point type, an ordered-and-equal compare is used.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformAllEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformAllEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBroadcast(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef id)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(id);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBroadcast, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..id.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBroadcast</c></para>
    /// <para>Result is the Value of the invocation identified by the id Id to all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>Id  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>Before version 1.5, Id must come from a constant instruction. Starting with version 1.5, this restriction is lifted. However, behavior is undefined when Id is not dynamically uniform.</para>
    /// <para>The resulting value is undefined if Id is not part of the scope restricted tangle, or is greater than or equal to the size of the scope. </para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBroadcast(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef id)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(id);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBroadcast, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..id.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBroadcastFirst(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBroadcastFirst, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBroadcastFirst</c></para>
    /// <para>Result is the Value of the invocation from the tangled invocations with the lowest id within the Execution scope to all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBroadcastFirst(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBroadcastFirst, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBallot(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBallot</c></para>
    /// <para>Result is a bitfield value combining the Predicate value from all tangled invocations within the Execution scope that execute the same dynamic instance of this instruction. The bit is set to 1 if the corresponding invocation is part of the tangled invocations within the Execution scope and the Predicate for that invocation evaluated to true; otherwise, it is set to 0.</para>
    /// <para>Result Type  must be a vector of four components of integer type scalar, whose Width operand is 32 and whose Signedness operand is 0. </para>
    /// <para>Result is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the scope) is the higher bit number of the last bitmask needed to represent all bits of the invocations in the scope restricted tangle.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para>Predicate must be a Boolean type.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBallot(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformInverseBallot(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformInverseBallot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformInverseBallot</c></para>
    /// <para>Evaluates a value for all tangled invocations within the Execution scope, resulting in true if the bit in Value for the corresponding invocation is set to 1, otherwise the result is false.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>Value  must be a vector of four components of integer type scalar, whose Width operand is 32 and whose Signedness operand is 0. </para>
    /// <para>Behavior is undefined unless Value is the same for all invocations that execute the same dynamic instance of this instruction.</para>
    /// <para>Value is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the scope) is the higher bit number of the last bitmask needed to represent all bits of the invocations in the scope restricted tangle.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformInverseBallot(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformInverseBallot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBallotBitExtract(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(index);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallotBitExtract, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBallotBitExtract</c></para>
    /// <para>Evaluates a value for all tangled invocations within the Execution scope, resulting in true if the bit in Value that corresponds to Index is set to one, otherwise the result is false.</para>
    /// <para>Result Type must be a Boolean type.</para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>Value  must be a vector of four components of integer type scalar, whose Width operand is 32 and whose Signedness operand is 0. </para>
    /// <para>Value is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the scope) is the higher bit number of the last bitmask needed to represent all bits of the invocations in the scope restricted tangle.</para>
    /// <para>Index  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>The resulting value is undefined if Index is greater than or equal to the size of the scope. </para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBallotBitExtract(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(index);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallotBitExtract, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBallotBitCount(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallotBitCount, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBallotBitCount</c></para>
    /// <para>Result is the number of bits that are set to 1 in Value, considering only the bits in Value required to represent all bits of the scope restricted tangle.</para>
    /// <para>Result Type  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 0. </para>
    /// <para>Value  must be a vector of four components of integer type scalar, whose Width operand is 32 and whose Signedness operand is 0. </para>
    /// <para>Value is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the scope) is the higher bit number of the last bitmask needed to represent all bits of the invocations in the scope restricted tangle.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBallotBitCount(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallotBitCount, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBallotFindLSB(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallotFindLSB, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBallotFindLSB</c></para>
    /// <para>Find the least significant bit set to 1 in Value, considering only the bits in Value required to represent all bits of the scope restricted tangle. If none of the considered bits is set to 1, the resulting value is undefined.</para>
    /// <para>Result Type  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>Value  must be a vector of four components of integer type scalar, whose Width operand is 32 and whose Signedness operand is 0. </para>
    /// <para>Value is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the scope) is the higher bit number of the last bitmask needed to represent all bits of the invocations in the scope restricted tangle.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBallotFindLSB(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallotFindLSB, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBallotFindMSB(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallotFindMSB, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBallotFindMSB</c></para>
    /// <para>Find the most significant bit set to 1 in Value, considering only the bits in Value required to represent all bits of the scope restricted tangle. If none of the considered bits is set to 1, the resulting value is undefined.</para>
    /// <para>Result Type  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>Value  must be a vector of four components of integer type scalar, whose Width operand is 32 and whose Signedness operand is 0. </para>
    /// <para>Value is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the scope) is the higher bit number of the last bitmask needed to represent all bits of the invocations in the scope restricted tangle.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBallotFindMSB(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBallotFindMSB, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformShuffle(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef id)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(id);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformShuffle, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..id.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformShuffle</c></para>
    /// <para>Result is the Value of the invocation identified by the id Id.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command.</para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>Id  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>The resulting value is undefined if Id is not part of the scope restricted tangle, or is greater than or equal to the size of the scope. </para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformShuffle(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef id)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(id);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformShuffle, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..id.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformShuffleXor(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef mask)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(mask);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformShuffleXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..mask.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformShuffleXor</c></para>
    /// <para>Result is the Value of the invocation identified by the current invocation’s id within the scope xor’ed with Mask.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>Mask  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>The resulting value is undefined if current invocation’s id within the scope xor’ed with Mask is not part of the scope restricted tangle, or is greater than or equal to the size of the scope. </para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformShuffleXor(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef mask)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(mask);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformShuffleXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..mask.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformShuffleUp(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef delta)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(delta);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformShuffleUp, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..delta.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformShuffleUp</c></para>
    /// <para>Result is the Value of the invocation identified by the current invocation’s id within the scope - Delta.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>Delta  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>Delta is treated as unsigned. The resulting value is undefined if Delta is greater than the current invocation’s id within the scope or if the identified invocation is not in scope restricted tangle.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformShuffleUp(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef delta)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(delta);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformShuffleUp, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..delta.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformShuffleDown(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef delta)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(delta);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformShuffleDown, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..delta.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformShuffleDown</c></para>
    /// <para>Result is the Value of the invocation identified by the current invocation’s id within the scope + Delta.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>Delta  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>Delta is treated as unsigned. The resulting value is undefined if Delta is greater than or equal to the size of the scope, or if the identified invocation is not in scope restricted tangle></para>
    /// <para>An invocation will not execute a <<DynamicInstance , dynamic  instance  of  this  instruction ( X ' ) until  all  invocations  in  its  scope  restricted  tangle  have  executed  all  dynamic  instances  that  are  program-ordered  before  X ' .</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformShuffleDown(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef delta)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(delta);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformShuffleDown, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..delta.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformIAdd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformIAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformIAdd</c></para>
    /// <para>An integer add group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformIAdd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformIAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformFAdd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformFAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformFAdd</c></para>
    /// <para>A floating point add group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type.  The method used to perform the group operation on the contributed Value(s) from the tangled invocations is implementation defined.</para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformFAdd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformFAdd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformIMul(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformIMul, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformIMul</c></para>
    /// <para>An integer multiply group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 1. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformIMul(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformIMul, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformFMul(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformFMul, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformFMul</c></para>
    /// <para>A floating point multiply group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 1. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type.  The method used to perform the group operation on the contributed Value(s) from the tangled invocations is implementation defined.</para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformFMul(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformFMul, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformSMin(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformSMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformSMin</c></para>
    /// <para>A signed integer minimum group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is INT_MAX. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformSMin(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformSMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformUMin(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformUMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformUMin</c></para>
    /// <para>An unsigned integer minimum group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type, whose Signedness operand is 0. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is UINT_MAX. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformUMin(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformUMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformFMin(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformFMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformFMin</c></para>
    /// <para>A floating point minimum group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is +INF. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type.  The method used to perform the group operation on the contributed Value(s) from the tangled invocations is implementation defined. From the set of Value(s) provided by the tangled invocations within a subgroup, if for any two Values one of them is a NaN, the other is chosen. If all Value(s) that are used by the current invocation are NaN, then the result is an undefined value.</para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformFMin(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformFMin, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformSMax(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformSMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformSMax</c></para>
    /// <para>A signed integer maximum group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is INT_MIN. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformSMax(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformSMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformUMax(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformUMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformUMax</c></para>
    /// <para>An unsigned integer maximum group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type, whose Signedness operand is 0. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformUMax(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformUMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformFMax(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformFMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformFMax</c></para>
    /// <para>A floating point maximum group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is -INF. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type.  The method used to perform the group operation on the contributed Value(s) from the tangled invocations is implementation defined. From the set of Value(s) provided by the tangled invocations within a subgroup, if for any two Values one of them is a NaN, the other is chosen. If all Value(s) that are used by the current invocation are NaN, then the result is an undefined value.</para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformFMax(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformFMax, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBitwiseAnd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBitwiseAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBitwiseAnd</c></para>
    /// <para>A bitwise and group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is ~0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBitwiseAnd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBitwiseAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBitwiseOr(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBitwiseOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBitwiseOr</c></para>
    /// <para>A bitwise or group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBitwiseOr(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBitwiseOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformBitwiseXor(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBitwiseXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformBitwiseXor</c></para>
    /// <para>A bitwise xor group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of integer type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformBitwiseXor(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformBitwiseXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformLogicalAnd(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformLogicalAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformLogicalAnd</c></para>
    /// <para>A logical and group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is ~0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformLogicalAnd(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformLogicalAnd, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformLogicalOr(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformLogicalOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformLogicalOr</c></para>
    /// <para>A logical or group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformLogicalOr(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformLogicalOr, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformLogicalXor(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformLogicalXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformLogicalXor</c></para>
    /// <para>A logical xor group operation of all Value operands contributed by all tangled invocations within the Execution scope.</para>
    /// <para>Result Type  must be a scalar or vector of Boolean type. </para>
    /// <para>Execution is the scope defining the scope restricted tangle affected by this command. It must be Subgroup.</para>
    /// <para>The identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present. </para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the size of the  scope, executing this instruction results in undefined behavior.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its scope restricted tangle have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformLogicalXor(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef value, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(value) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformLogicalXor, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..value.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformQuadBroadcast(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(index);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformQuadBroadcast, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformQuadBroadcast</c></para>
    /// <para>Result is the Value of the invocation within the quad with a quad index equal to Index.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para>Execution is a Scope, but has no effect on the behavior of this instruction. It must be Subgroup.</para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>Index  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para>Before version 1.5, Index must come from a constant instruction. Starting with version 1.5, Index must be dynamically uniform.</para>
    /// <para>If the value of Index is greater than or equal to 4, or refers to an invocation not part of the tangled invocations within the quad, the resulting value is undefined.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its quad have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformQuadBroadcast(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(index);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformQuadBroadcast, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformQuadSwap(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(direction);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformQuadSwap, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformQuadSwap</c></para>
    /// <para>Swap the Value of the invocation within the quad with another invocation in the quad using Direction.</para>
    /// <para>Result Type  must be a scalar or vector of floating-point type, integer type, or Boolean type. </para>
    /// <para>Execution is a Scope, but has no effect on the behavior of this instruction. It must be Subgroup.</para>
    /// <para> The type of Value must be the same as Result Type. </para>
    /// <para>Direction is the kind of swap to perform.</para>
    /// <para>Direction  must be a scalar of integer type, whose Signedness operand is 0. </para>
    /// <para> Direction must come from a constant instruction.</para>
    /// <para>The value returned in Result is the value provided to Value by another invocation in the same quad scope instance. The invocation providing this value is determined according to Direction.</para>
    /// <para>A Direction of 0 indicates a horizontal swap;</para>
    /// <para>- Invocations with quad indices of 0 and 1 swap values</para>
    /// <para>- Invocations with quad indices of 2 and 3 swap values</para>
    /// <para>A Direction of 1 indicates a vertical swap;</para>
    /// <para>- Invocations with quad indices of 0 and 2 swap values</para>
    /// <para>- Invocations with quad indices of 1 and 3 swap values</para>
    /// <para>A Direction of 2 indicates a diagonal swap;</para>
    /// <para>- Invocations with quad indices of 0 and 3 swap values</para>
    /// <para>- Invocations with quad indices of 1 and 2 swap values</para>
    /// <para>Direction must be one of the above values.</para>
    /// <para>If a tangled invocation within the quad reads Value from an invocation not part of the tangled invocation within the same quad, the resulting value is undefined.</para>
    /// <para>An invocation will not execute a dynamic instance of this instruction (X') until all invocations in its quad have executed all dynamic instances that are program-ordered before X'.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformQuadSwap(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(direction);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformQuadSwap, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    public static Instruction AddOpCopyLogical(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCopyLogical, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCopyLogical</c></para>
    /// <para>Make a logical copy of Operand. There are no pointer dereferences involved.</para>
    /// <para>Result Type must not equal the type of Operand (see OpCopyObject), but Result Type must logically match the Operand type.</para>
    /// <para> Logically match is recursively defined by these three rules:</para>
    /// <para>1. They must be either both be OpTypeArray or both be OpTypeStruct</para>
    /// <para>2. If they are OpTypeArray:</para>
    /// <para>   - they must have the same Length operand, and</para>
    /// <para>   - their Element Type operands must be either the same or must logically match.</para>
    /// <para>3. If they are OpTypeStruct:</para>
    /// <para>   - they must have the same number of Member type, and</para>
    /// <para>   - Member N type for the same N in the two types must be either the same or must logically match.</para>
    /// </summary>
    public static Instruction InsertOpCopyLogical(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCopyLogical, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpPtrEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpPtrEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpPtrEqual</c></para>
    /// <para>Result is true if Operand 1 and Operand 2 have the same value. Result is false if Operand 1 and Operand 2 have different values.</para>
    /// <para> Result Type must be a Boolean type scalar. </para>
    /// <para> The types of Operand 1 and Operand 2 must be OpTypePointer of the same type.</para>
    /// </summary>
    public static Instruction InsertOpPtrEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpPtrEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpPtrNotEqual(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpPtrNotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpPtrNotEqual</c></para>
    /// <para>Result is true if Operand 1 and Operand 2 have different values. Result is false if Operand 1 and Operand 2 have the same value.</para>
    /// <para> Result Type must be a Boolean type scalar. </para>
    /// <para> The types of Operand 1 and Operand 2 must be OpTypePointer of the same type.</para>
    /// </summary>
    public static Instruction InsertOpPtrNotEqual(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpPtrNotEqual, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpPtrDiff(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpPtrDiff, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpPtrDiff</c></para>
    /// <para>Element-number subtraction: The number of elements to add to Operand 2 to get to Operand 1.</para>
    /// <para> Result Type must be an integer type scalar. It is computed as a signed value, as negative differences are allowed, independently of the signed bit in the type. The result equals the low-order N bits of the correct result R, where R is computed with enough precision to avoid overflow and underflow and Result Type has a bitwidth of N bits.</para>
    /// <para>The units of Result Type are a count of elements. I.e., the same value you would use as the Element operand to OpPtrAccessChain.</para>
    /// <para>The types of Operand 1 and Operand 2 must be OpTypePointer of exactly the same type, and point to a type that can be aggregated into an array. For an array of length L, Operand 1 and Operand 2 can point to any element in the range [0, L], where element L is outside the array but has a representative address computed with the same stride as elements in the array. Additionally, Operand 1 must be a valid Base operand of OpPtrAccessChain. Behavior is undefined if Operand 1 and Operand 2 are not pointers to element numbers in [0, L] in the same array.</para>
    /// </summary>
    public static Instruction InsertOpPtrDiff(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpPtrDiff, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpColorAttachmentReadEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef attachment, IdRef? sample)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(attachment) + buffer.GetWordLength(sample);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpColorAttachmentReadEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..attachment.AsSpirvSpan(), ..sample.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpColorAttachmentReadEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpColorAttachmentReadEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef attachment, IdRef? sample)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(attachment) + buffer.GetWordLength(sample);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpColorAttachmentReadEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..attachment.AsSpirvSpan(), ..sample.AsSpirvSpan()]);
    }

    public static Instruction AddOpDepthAttachmentReadEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef? sample)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sample);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDepthAttachmentReadEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sample.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDepthAttachmentReadEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpDepthAttachmentReadEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef? sample)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sample);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDepthAttachmentReadEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sample.AsSpirvSpan()]);
    }

    public static Instruction AddOpStencilAttachmentReadEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef? sample)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sample);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpStencilAttachmentReadEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sample.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpStencilAttachmentReadEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpStencilAttachmentReadEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef? sample)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sample);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpStencilAttachmentReadEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sample.AsSpirvSpan()]);
    }

    public static Instruction AddOpTerminateInvocation(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpTerminateInvocation]);
    }

    /// <summary>
    /// <para><c>OpTerminateInvocation</c></para>
    /// <para>Fragment-shader terminate.</para>
    /// <para>Ceases all further processing in any invocation that executes it: Only instructions these invocations executed before OpTerminateInvocation will have observable side effects. If this instruction is executed in non-uniform control flow, all subsequent control flow is non-uniform (for invocations that continue to execute).</para>
    /// <para>This instruction must be the last instruction in a block.</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpTerminateInvocation(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpTerminateInvocation]);
    }

    public static Instruction AddOpTypeUntypedPointerKHR(this SpirvBuffer buffer, IdResult resultId, StorageClass storageclass)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeUntypedPointerKHR, ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeUntypedPointerKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeUntypedPointerKHR(this SpirvBuffer buffer, int position, IdResult resultId, StorageClass storageclass)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeUntypedPointerKHR, ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan()]);
    }

    public static Instruction AddOpUntypedVariableKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, StorageClass storageclass, IdRef? dataType, IdRef? initializer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(dataType) + buffer.GetWordLength(initializer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUntypedVariableKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..dataType.AsSpirvSpan(), ..initializer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUntypedVariableKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUntypedVariableKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, StorageClass storageclass, IdRef? dataType, IdRef? initializer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(storageclass) + buffer.GetWordLength(dataType) + buffer.GetWordLength(initializer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUntypedVariableKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..storageclass.AsSpirvSpan(), ..dataType.AsSpirvSpan(), ..initializer.AsSpirvSpan()]);
    }

    public static Instruction AddOpUntypedAccessChainKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseType, IdRef baseId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseType) + buffer.GetWordLength(baseId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUntypedAccessChainKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseType.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUntypedAccessChainKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUntypedAccessChainKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseType, IdRef baseId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseType) + buffer.GetWordLength(baseId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUntypedAccessChainKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseType.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpUntypedInBoundsAccessChainKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseType, IdRef baseId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseType) + buffer.GetWordLength(baseId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUntypedInBoundsAccessChainKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseType.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUntypedInBoundsAccessChainKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUntypedInBoundsAccessChainKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseType, IdRef baseId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseType) + buffer.GetWordLength(baseId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUntypedInBoundsAccessChainKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseType.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupBallotKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupBallotKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupBallotKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupBallotKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupBallotKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupFirstInvocationKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupFirstInvocationKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupFirstInvocationKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupFirstInvocationKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupFirstInvocationKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpUntypedPtrAccessChainKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseType, IdRef baseId, IdRef element, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseType) + buffer.GetWordLength(baseId) + buffer.GetWordLength(element) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUntypedPtrAccessChainKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseType.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..element.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUntypedPtrAccessChainKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUntypedPtrAccessChainKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseType, IdRef baseId, IdRef element, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseType) + buffer.GetWordLength(baseId) + buffer.GetWordLength(element) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUntypedPtrAccessChainKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseType.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..element.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpUntypedInBoundsPtrAccessChainKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseType, IdRef baseId, IdRef element, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseType) + buffer.GetWordLength(baseId) + buffer.GetWordLength(element) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUntypedInBoundsPtrAccessChainKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseType.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..element.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUntypedInBoundsPtrAccessChainKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUntypedInBoundsPtrAccessChainKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseType, IdRef baseId, IdRef element, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseType) + buffer.GetWordLength(baseId) + buffer.GetWordLength(element) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUntypedInBoundsPtrAccessChainKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseType.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..element.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpUntypedArrayLengthKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef structure, IdRef pointer, LiteralInteger arraymember)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(structure) + buffer.GetWordLength(pointer) + buffer.GetWordLength(arraymember);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUntypedArrayLengthKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..structure.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..arraymember.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUntypedArrayLengthKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUntypedArrayLengthKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef structure, IdRef pointer, LiteralInteger arraymember)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(structure) + buffer.GetWordLength(pointer) + buffer.GetWordLength(arraymember);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUntypedArrayLengthKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..structure.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..arraymember.AsSpirvSpan()]);
    }

    public static Instruction AddOpUntypedPrefetchKHR(this SpirvBuffer buffer, IdRef pointerType, IdRef numBytes, IdRef? rW, IdRef? locality, IdRef? cacheType)
    {
        var wordLength = 1 + buffer.GetWordLength(pointerType) + buffer.GetWordLength(numBytes) + buffer.GetWordLength(rW) + buffer.GetWordLength(locality) + buffer.GetWordLength(cacheType);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUntypedPrefetchKHR, ..pointerType.AsSpirvSpan(), ..numBytes.AsSpirvSpan(), ..rW.AsSpirvSpan(), ..locality.AsSpirvSpan(), ..cacheType.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUntypedPrefetchKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUntypedPrefetchKHR(this SpirvBuffer buffer, int position, IdRef pointerType, IdRef numBytes, IdRef? rW, IdRef? locality, IdRef? cacheType)
    {
        var wordLength = 1 + buffer.GetWordLength(pointerType) + buffer.GetWordLength(numBytes) + buffer.GetWordLength(rW) + buffer.GetWordLength(locality) + buffer.GetWordLength(cacheType);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUntypedPrefetchKHR, ..pointerType.AsSpirvSpan(), ..numBytes.AsSpirvSpan(), ..rW.AsSpirvSpan(), ..locality.AsSpirvSpan(), ..cacheType.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAllKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAllKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupAllKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAllKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAllKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAnyKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAnyKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupAnyKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAnyKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAnyKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAllEqualKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAllEqualKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupAllEqualKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAllEqualKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAllEqualKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformRotateKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef delta, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(delta) + buffer.GetWordLength(clusterSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformRotateKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..delta.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformRotateKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformRotateKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, IdRef value, IdRef delta, IdRef? clusterSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(value) + buffer.GetWordLength(delta) + buffer.GetWordLength(clusterSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformRotateKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..value.AsSpirvSpan(), ..delta.AsSpirvSpan(), ..clusterSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupReadInvocationKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef value, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value) + buffer.GetWordLength(index);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupReadInvocationKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupReadInvocationKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupReadInvocationKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef value, IdRef index)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value) + buffer.GetWordLength(index);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupReadInvocationKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan(), ..index.AsSpirvSpan()]);
    }

    public static Instruction AddOpExtInstWithForwardRefsKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef set, LiteralInteger instruction, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(set) + buffer.GetWordLength(instruction) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExtInstWithForwardRefsKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..set.AsSpirvSpan(), ..instruction.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExtInstWithForwardRefsKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpExtInstWithForwardRefsKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef set, LiteralInteger instruction, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(set) + buffer.GetWordLength(instruction) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExtInstWithForwardRefsKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..set.AsSpirvSpan(), ..instruction.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpTraceRayKHR(this SpirvBuffer buffer, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef sBTOffset, IdRef sBTStride, IdRef missIndex, IdRef rayOrigin, IdRef rayTmin, IdRef rayDirection, IdRef rayTmax, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(sBTOffset) + buffer.GetWordLength(sBTStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTmin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTmax) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTraceRayKHR, ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..sBTOffset.AsSpirvSpan(), ..sBTStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTmin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTmax.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTraceRayKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTraceRayKHR(this SpirvBuffer buffer, int position, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef sBTOffset, IdRef sBTStride, IdRef missIndex, IdRef rayOrigin, IdRef rayTmin, IdRef rayDirection, IdRef rayTmax, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(sBTOffset) + buffer.GetWordLength(sBTStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTmin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTmax) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTraceRayKHR, ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..sBTOffset.AsSpirvSpan(), ..sBTStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTmin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTmax.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpExecuteCallableKHR(this SpirvBuffer buffer, IdRef sBTIndex, IdRef callableData)
    {
        var wordLength = 1 + buffer.GetWordLength(sBTIndex) + buffer.GetWordLength(callableData);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExecuteCallableKHR, ..sBTIndex.AsSpirvSpan(), ..callableData.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExecuteCallableKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpExecuteCallableKHR(this SpirvBuffer buffer, int position, IdRef sBTIndex, IdRef callableData)
    {
        var wordLength = 1 + buffer.GetWordLength(sBTIndex) + buffer.GetWordLength(callableData);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExecuteCallableKHR, ..sBTIndex.AsSpirvSpan(), ..callableData.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertUToAccelerationStructureKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef accel)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(accel);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertUToAccelerationStructureKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..accel.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertUToAccelerationStructureKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertUToAccelerationStructureKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef accel)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(accel);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertUToAccelerationStructureKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..accel.AsSpirvSpan()]);
    }

    public static Instruction AddOpIgnoreIntersectionKHR(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpIgnoreIntersectionKHR]);
    }

    /// <summary>
    /// <para><c>OpIgnoreIntersectionKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpIgnoreIntersectionKHR(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpIgnoreIntersectionKHR]);
    }

    public static Instruction AddOpTerminateRayKHR(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpTerminateRayKHR]);
    }

    /// <summary>
    /// <para><c>OpTerminateRayKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTerminateRayKHR(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpTerminateRayKHR]);
    }

    public static Instruction AddOpSDot(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSDot (OpSDotKHR)</c></para>
    /// <para>Signed integer dot product of Vector 1 and Vector 2.</para>
    /// <para>Result Type must be an integer type whose Width must be greater than or equal to that of the components of Vector 1 and Vector 2.</para>
    /// <para>Vector 1 and Vector 2 must have the same type.</para>
    /// <para>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the DotProductInput4x8BitPacked capability) or vectors of integer type (enabled by the DotProductInput4x8Bit or DotProductInputAll capability).</para>
    /// <para>When Vector 1 and Vector 2 are scalar integer types, Packed Vector Format must be specified to select how the integers are to be interpreted as vectors.</para>
    /// <para>All components of the input vectors are sign-extended to the bit width of the result’s type. The sign-extended input vectors are then multiplied component-wise and all components of the vector resulting from the component-wise multiplication are added together. The resulting value will equal the low-order N bits of the correct result R, where N is the result width and R is computed with enough precision to avoid overflow and underflow.</para>
    /// </summary>
    public static Instruction InsertOpSDot(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    public static Instruction AddOpUDot(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUDot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUDot (OpUDotKHR)</c></para>
    /// <para>Unsigned integer dot product of Vector 1 and Vector 2.</para>
    /// <para>Result Type must be an integer type with Signedness of 0 whose Width must be greater than or equal to that of the components of Vector 1 and Vector 2.</para>
    /// <para>Vector 1 and Vector 2 must have the same type.</para>
    /// <para>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the DotProductInput4x8BitPacked capability) or vectors of integer type with Signedness of 0 (enabled by the DotProductInput4x8Bit or DotProductInputAll capability).</para>
    /// <para>When Vector 1 and Vector 2 are scalar integer types, Packed Vector Format must be specified to select how the integers are to be interpreted as vectors.</para>
    /// <para>All components of the input vectors are zero-extended to the bit width of the result’s type. The zero-extended input vectors are then multiplied component-wise and all components of the vector resulting from the component-wise multiplication are added together. The resulting value will equal the low-order N bits of the correct result R, where N is the result width and R is computed with enough precision to avoid overflow and underflow.</para>
    /// </summary>
    public static Instruction InsertOpUDot(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUDot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    public static Instruction AddOpSUDot(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSUDot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSUDot (OpSUDotKHR)</c></para>
    /// <para>Mixed-signedness integer dot product of Vector 1 and Vector 2. Components of Vector 1 are treated as signed, components of Vector 2 are treated as unsigned.</para>
    /// <para>Result Type must be an integer type whose Width must be greater than or equal to that of the components of Vector 1 and Vector 2.</para>
    /// <para>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the DotProductInput4x8BitPacked capability) or vectors of integer type with the same number of components and same component Width (enabled by the DotProductInput4x8Bit or DotProductInputAll capability). When Vector 1 and Vector 2 are vectors, the components of Vector 2 must have a Signedness of 0.</para>
    /// <para>When Vector 1 and Vector 2 are scalar integer types, Packed Vector Format must be specified to select how the integers are to be interpreted as vectors.</para>
    /// <para>All components of Vector 1 are sign-extended to the bit width of the result’s type. All components of Vector 2 are zero-extended to the bit width of the result’s type. The sign- or zero-extended input vectors are then multiplied component-wise and all components of the vector resulting from the component-wise multiplication are added together. The resulting value will equal the low-order N bits of the correct result R, where N is the result width and R is computed with enough precision to avoid overflow and underflow.</para>
    /// </summary>
    public static Instruction InsertOpSUDot(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSUDot, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    public static Instruction AddOpSDotAccSat(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, IdRef accumulator, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(accumulator) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSDotAccSat, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..accumulator.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSDotAccSat (OpSDotAccSatKHR)</c></para>
    /// <para>Signed integer dot product of Vector 1 and Vector 2 and signed saturating addition of the result with Accumulator.</para>
    /// <para>Result Type must be an integer type whose Width must be greater than or equal to that of the components of Vector 1 and Vector 2.</para>
    /// <para>Vector 1 and Vector 2 must have the same type.</para>
    /// <para>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the DotProductInput4x8BitPacked capability) or vectors of integer type (enabled by the DotProductInput4x8Bit or DotProductInputAll capability).</para>
    /// <para>The type of Accumulator must be the same as Result Type.</para>
    /// <para>When Vector 1 and Vector 2 are scalar integer types, Packed Vector Format must be specified to select how the integers are to be interpreted as vectors.</para>
    /// <para>All components of the input vectors are sign-extended to the bit width of the result’s type. The sign-extended input vectors are then multiplied component-wise and all components of the vector resulting from the component-wise multiplication are added together. Finally, the resulting sum is added to the input accumulator. This final addition is saturating.</para>
    /// <para>If any of the multiplications or additions, with the exception of the final accumulation, overflow or underflow, the result of the instruction is undefined.</para>
    /// </summary>
    public static Instruction InsertOpSDotAccSat(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, IdRef accumulator, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(accumulator) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSDotAccSat, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..accumulator.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    public static Instruction AddOpUDotAccSat(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, IdRef accumulator, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(accumulator) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUDotAccSat, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..accumulator.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUDotAccSat (OpUDotAccSatKHR)</c></para>
    /// <para>Unsigned integer dot product of Vector 1 and Vector 2 and unsigned saturating addition of the result with Accumulator.</para>
    /// <para>Result Type must be an integer type with Signedness of 0 whose Width must be greater than or equal to that of the components of Vector 1 and Vector 2.</para>
    /// <para>Vector 1 and Vector 2 must have the same type.</para>
    /// <para>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the DotProductInput4x8BitPacked capability) or vectors of integer type with Signedness of 0 (enabled by the DotProductInput4x8Bit or DotProductInputAll capability).</para>
    /// <para>The type of Accumulator must be the same as Result Type.</para>
    /// <para>When Vector 1 and Vector 2 are scalar integer types, Packed Vector Format must be specified to select how the integers are to be interpreted as vectors.</para>
    /// <para>All components of the input vectors are zero-extended to the bit width of the result’s type. The zero-extended input vectors are then multiplied component-wise and all components of the vector resulting from the component-wise multiplication are added together. Finally, the resulting sum is added to the input accumulator. This final addition is saturating.</para>
    /// <para>If any of the multiplications or additions, with the exception of the final accumulation, overflow or underflow, the result of the instruction is undefined.</para>
    /// </summary>
    public static Instruction InsertOpUDotAccSat(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, IdRef accumulator, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(accumulator) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUDotAccSat, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..accumulator.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    public static Instruction AddOpSUDotAccSat(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, IdRef accumulator, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(accumulator) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSUDotAccSat, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..accumulator.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSUDotAccSat (OpSUDotAccSatKHR)</c></para>
    /// <para>Mixed-signedness integer dot product of Vector 1 and Vector 2 and signed saturating addition of the result with Accumulator. Components of Vector 1 are treated as signed, components of Vector 2 are treated as unsigned.</para>
    /// <para>Result Type must be an integer type whose Width must be greater than or equal to that of the components of Vector 1 and Vector 2.</para>
    /// <para>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the DotProductInput4x8BitPacked capability) or vectors of integer type with the same number of components and same component Width (enabled by the DotProductInput4x8Bit or DotProductInputAll capability). When Vector 1 and Vector 2 are vectors, the components of Vector 2 must have a Signedness of 0.</para>
    /// <para>The type of Accumulator must be the same as Result Type.</para>
    /// <para>When Vector 1 and Vector 2 are scalar integer types, Packed Vector Format must be specified to select how the integers are to be interpreted as vectors.</para>
    /// <para>All components of Vector 1 are sign-extended to the bit width of the result’s type. All components of Vector 2 are zero-extended to the bit width of the result’s type. The sign- or zero-extended input vectors are then multiplied component-wise and all components of the vector resulting from the component-wise multiplication are added together. Finally, the resulting sum is added to the input accumulator. This final addition is saturating.</para>
    /// <para>If any of the multiplications or additions, with the exception of the final accumulation, overflow or underflow, the result of the instruction is undefined.</para>
    /// </summary>
    public static Instruction InsertOpSUDotAccSat(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef vector1, IdRef vector2, IdRef accumulator, PackedVectorFormat? packedVectorFormat)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(vector1) + buffer.GetWordLength(vector2) + buffer.GetWordLength(accumulator) + buffer.GetWordLength(packedVectorFormat);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSUDotAccSat, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..vector1.AsSpirvSpan(), ..vector2.AsSpirvSpan(), ..accumulator.AsSpirvSpan(), ..packedVectorFormat.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeCooperativeMatrixKHR(this SpirvBuffer buffer, IdResult resultId, IdRef componentType, IdScope scope, IdRef rows, IdRef columns, IdRef use)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(componentType) + buffer.GetWordLength(scope) + buffer.GetWordLength(rows) + buffer.GetWordLength(columns) + buffer.GetWordLength(use);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeCooperativeMatrixKHR, ..resultId.AsSpirvSpan(), ..componentType.AsSpirvSpan(), ..scope.AsSpirvSpan(), ..rows.AsSpirvSpan(), ..columns.AsSpirvSpan(), ..use.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeCooperativeMatrixKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeCooperativeMatrixKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdRef componentType, IdScope scope, IdRef rows, IdRef columns, IdRef use)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(componentType) + buffer.GetWordLength(scope) + buffer.GetWordLength(rows) + buffer.GetWordLength(columns) + buffer.GetWordLength(use);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeCooperativeMatrixKHR, ..resultId.AsSpirvSpan(), ..componentType.AsSpirvSpan(), ..scope.AsSpirvSpan(), ..rows.AsSpirvSpan(), ..columns.AsSpirvSpan(), ..use.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixLoadKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdRef memoryLayout, IdRef? stride, MemoryAccessMask? memoryOperand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memoryLayout) + buffer.GetWordLength(stride) + buffer.GetWordLength(memoryOperand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLoadKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memoryLayout.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..memoryOperand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixLoadKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixLoadKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdRef memoryLayout, IdRef? stride, MemoryAccessMask? memoryOperand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memoryLayout) + buffer.GetWordLength(stride) + buffer.GetWordLength(memoryOperand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLoadKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memoryLayout.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..memoryOperand.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixStoreKHR(this SpirvBuffer buffer, IdRef pointer, IdRef objectId, IdRef memoryLayout, IdRef? stride, MemoryAccessMask? memoryOperand)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(memoryLayout) + buffer.GetWordLength(stride) + buffer.GetWordLength(memoryOperand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixStoreKHR, ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..memoryLayout.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..memoryOperand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixStoreKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixStoreKHR(this SpirvBuffer buffer, int position, IdRef pointer, IdRef objectId, IdRef memoryLayout, IdRef? stride, MemoryAccessMask? memoryOperand)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(memoryLayout) + buffer.GetWordLength(stride) + buffer.GetWordLength(memoryOperand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixStoreKHR, ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..memoryLayout.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..memoryOperand.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixMulAddKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, IdRef b, IdRef c, CooperativeMatrixOperandsMask? cooperativeMatrixOperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(b) + buffer.GetWordLength(c) + buffer.GetWordLength(cooperativeMatrixOperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixMulAddKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..b.AsSpirvSpan(), ..c.AsSpirvSpan(), ..cooperativeMatrixOperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixMulAddKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixMulAddKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, IdRef b, IdRef c, CooperativeMatrixOperandsMask? cooperativeMatrixOperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(b) + buffer.GetWordLength(c) + buffer.GetWordLength(cooperativeMatrixOperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixMulAddKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..b.AsSpirvSpan(), ..c.AsSpirvSpan(), ..cooperativeMatrixOperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixLengthKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef type)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(type);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLengthKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..type.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixLengthKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixLengthKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef type)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(type);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLengthKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..type.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantCompositeReplicateEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantCompositeReplicateEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantCompositeReplicateEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConstantCompositeReplicateEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantCompositeReplicateEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpSpecConstantCompositeReplicateEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSpecConstantCompositeReplicateEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSpecConstantCompositeReplicateEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSpecConstantCompositeReplicateEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSpecConstantCompositeReplicateEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpCompositeConstructReplicateEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCompositeConstructReplicateEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCompositeConstructReplicateEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCompositeConstructReplicateEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCompositeConstructReplicateEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeRayQueryKHR(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeRayQueryKHR, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeRayQueryKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeRayQueryKHR(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeRayQueryKHR, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryInitializeKHR(this SpirvBuffer buffer, IdRef rayQuery, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef rayOrigin, IdRef rayTMin, IdRef rayDirection, IdRef rayTMax)
    {
        var wordLength = 1 + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTMin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTMax);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryInitializeKHR, ..rayQuery.AsSpirvSpan(), ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTMin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTMax.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryInitializeKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryInitializeKHR(this SpirvBuffer buffer, int position, IdRef rayQuery, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef rayOrigin, IdRef rayTMin, IdRef rayDirection, IdRef rayTMax)
    {
        var wordLength = 1 + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTMin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTMax);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryInitializeKHR, ..rayQuery.AsSpirvSpan(), ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTMin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTMax.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryTerminateKHR(this SpirvBuffer buffer, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(rayQuery);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryTerminateKHR, ..rayQuery.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryTerminateKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryTerminateKHR(this SpirvBuffer buffer, int position, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(rayQuery);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryTerminateKHR, ..rayQuery.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGenerateIntersectionKHR(this SpirvBuffer buffer, IdRef rayQuery, IdRef hitT)
    {
        var wordLength = 1 + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(hitT);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGenerateIntersectionKHR, ..rayQuery.AsSpirvSpan(), ..hitT.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGenerateIntersectionKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGenerateIntersectionKHR(this SpirvBuffer buffer, int position, IdRef rayQuery, IdRef hitT)
    {
        var wordLength = 1 + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(hitT);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGenerateIntersectionKHR, ..rayQuery.AsSpirvSpan(), ..hitT.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryConfirmIntersectionKHR(this SpirvBuffer buffer, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(rayQuery);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryConfirmIntersectionKHR, ..rayQuery.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryConfirmIntersectionKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryConfirmIntersectionKHR(this SpirvBuffer buffer, int position, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(rayQuery);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryConfirmIntersectionKHR, ..rayQuery.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryProceedKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryProceedKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryProceedKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryProceedKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryProceedKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionTypeKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionTypeKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionTypeKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionTypeKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionTypeKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleWeightedQCOM(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef texture, IdRef coordinates, IdRef weights)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(texture) + buffer.GetWordLength(coordinates) + buffer.GetWordLength(weights);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleWeightedQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..texture.AsSpirvSpan(), ..coordinates.AsSpirvSpan(), ..weights.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleWeightedQCOM</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleWeightedQCOM(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef texture, IdRef coordinates, IdRef weights)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(texture) + buffer.GetWordLength(coordinates) + buffer.GetWordLength(weights);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleWeightedQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..texture.AsSpirvSpan(), ..coordinates.AsSpirvSpan(), ..weights.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageBoxFilterQCOM(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef texture, IdRef coordinates, IdRef boxSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(texture) + buffer.GetWordLength(coordinates) + buffer.GetWordLength(boxSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageBoxFilterQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..texture.AsSpirvSpan(), ..coordinates.AsSpirvSpan(), ..boxSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageBoxFilterQCOM</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageBoxFilterQCOM(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef texture, IdRef coordinates, IdRef boxSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(texture) + buffer.GetWordLength(coordinates) + buffer.GetWordLength(boxSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageBoxFilterQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..texture.AsSpirvSpan(), ..coordinates.AsSpirvSpan(), ..boxSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageBlockMatchSSDQCOM(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef target, IdRef targetCoordinates, IdRef reference, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(target) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(reference) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageBlockMatchSSDQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..target.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..reference.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageBlockMatchSSDQCOM</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageBlockMatchSSDQCOM(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef target, IdRef targetCoordinates, IdRef reference, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(target) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(reference) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageBlockMatchSSDQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..target.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..reference.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageBlockMatchSADQCOM(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef target, IdRef targetCoordinates, IdRef reference, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(target) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(reference) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageBlockMatchSADQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..target.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..reference.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageBlockMatchSADQCOM</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageBlockMatchSADQCOM(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef target, IdRef targetCoordinates, IdRef reference, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(target) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(reference) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageBlockMatchSADQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..target.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..reference.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageBlockMatchWindowSSDQCOM(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef targetSampledImage, IdRef targetCoordinates, IdRef referenceSampledImage, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(targetSampledImage) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(referenceSampledImage) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageBlockMatchWindowSSDQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..targetSampledImage.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..referenceSampledImage.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageBlockMatchWindowSSDQCOM</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageBlockMatchWindowSSDQCOM(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef targetSampledImage, IdRef targetCoordinates, IdRef referenceSampledImage, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(targetSampledImage) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(referenceSampledImage) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageBlockMatchWindowSSDQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..targetSampledImage.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..referenceSampledImage.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageBlockMatchWindowSADQCOM(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef targetSampledImage, IdRef targetCoordinates, IdRef referenceSampledImage, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(targetSampledImage) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(referenceSampledImage) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageBlockMatchWindowSADQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..targetSampledImage.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..referenceSampledImage.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageBlockMatchWindowSADQCOM</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageBlockMatchWindowSADQCOM(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef targetSampledImage, IdRef targetCoordinates, IdRef referenceSampledImage, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(targetSampledImage) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(referenceSampledImage) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageBlockMatchWindowSADQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..targetSampledImage.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..referenceSampledImage.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageBlockMatchGatherSSDQCOM(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef targetSampledImage, IdRef targetCoordinates, IdRef referenceSampledImage, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(targetSampledImage) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(referenceSampledImage) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageBlockMatchGatherSSDQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..targetSampledImage.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..referenceSampledImage.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageBlockMatchGatherSSDQCOM</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageBlockMatchGatherSSDQCOM(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef targetSampledImage, IdRef targetCoordinates, IdRef referenceSampledImage, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(targetSampledImage) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(referenceSampledImage) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageBlockMatchGatherSSDQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..targetSampledImage.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..referenceSampledImage.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageBlockMatchGatherSADQCOM(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef targetSampledImage, IdRef targetCoordinates, IdRef referenceSampledImage, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(targetSampledImage) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(referenceSampledImage) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageBlockMatchGatherSADQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..targetSampledImage.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..referenceSampledImage.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageBlockMatchGatherSADQCOM</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageBlockMatchGatherSADQCOM(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef targetSampledImage, IdRef targetCoordinates, IdRef referenceSampledImage, IdRef referenceCoordinates, IdRef blockSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(targetSampledImage) + buffer.GetWordLength(targetCoordinates) + buffer.GetWordLength(referenceSampledImage) + buffer.GetWordLength(referenceCoordinates) + buffer.GetWordLength(blockSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageBlockMatchGatherSADQCOM, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..targetSampledImage.AsSpirvSpan(), ..targetCoordinates.AsSpirvSpan(), ..referenceSampledImage.AsSpirvSpan(), ..referenceCoordinates.AsSpirvSpan(), ..blockSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupIAddNonUniformAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupIAddNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupIAddNonUniformAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupIAddNonUniformAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupIAddNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupFAddNonUniformAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupFAddNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupFAddNonUniformAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupFAddNonUniformAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupFAddNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupFMinNonUniformAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupFMinNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupFMinNonUniformAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupFMinNonUniformAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupFMinNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupUMinNonUniformAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupUMinNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupUMinNonUniformAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupUMinNonUniformAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupUMinNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupSMinNonUniformAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupSMinNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupSMinNonUniformAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupSMinNonUniformAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupSMinNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupFMaxNonUniformAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupFMaxNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupFMaxNonUniformAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupFMaxNonUniformAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupFMaxNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupUMaxNonUniformAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupUMaxNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupUMaxNonUniformAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupUMaxNonUniformAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupUMaxNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupSMaxNonUniformAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupSMaxNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupSMaxNonUniformAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupSMaxNonUniformAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupSMaxNonUniformAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpFragmentMaskFetchAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFragmentMaskFetchAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFragmentMaskFetchAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFragmentMaskFetchAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFragmentMaskFetchAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan()]);
    }

    public static Instruction AddOpFragmentFetchAMD(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, IdRef fragmentIndex)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(fragmentIndex);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFragmentFetchAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..fragmentIndex.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFragmentFetchAMD</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFragmentFetchAMD(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, IdRef fragmentIndex)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(fragmentIndex);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFragmentFetchAMD, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..fragmentIndex.AsSpirvSpan()]);
    }

    public static Instruction AddOpReadClockKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope scope)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(scope);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReadClockKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..scope.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReadClockKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpReadClockKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope scope)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(scope);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReadClockKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..scope.AsSpirvSpan()]);
    }

    public static Instruction AddOpAllocateNodePayloadsAMDX(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope visibility, IdRef payloadCount, IdRef nodeIndex)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(visibility) + buffer.GetWordLength(payloadCount) + buffer.GetWordLength(nodeIndex);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAllocateNodePayloadsAMDX, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..visibility.AsSpirvSpan(), ..payloadCount.AsSpirvSpan(), ..nodeIndex.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAllocateNodePayloadsAMDX</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAllocateNodePayloadsAMDX(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope visibility, IdRef payloadCount, IdRef nodeIndex)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(visibility) + buffer.GetWordLength(payloadCount) + buffer.GetWordLength(nodeIndex);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAllocateNodePayloadsAMDX, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..visibility.AsSpirvSpan(), ..payloadCount.AsSpirvSpan(), ..nodeIndex.AsSpirvSpan()]);
    }

    public static Instruction AddOpEnqueueNodePayloadsAMDX(this SpirvBuffer buffer, IdRef payloadArray)
    {
        var wordLength = 1 + buffer.GetWordLength(payloadArray);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpEnqueueNodePayloadsAMDX, ..payloadArray.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpEnqueueNodePayloadsAMDX</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpEnqueueNodePayloadsAMDX(this SpirvBuffer buffer, int position, IdRef payloadArray)
    {
        var wordLength = 1 + buffer.GetWordLength(payloadArray);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpEnqueueNodePayloadsAMDX, ..payloadArray.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeNodePayloadArrayAMDX(this SpirvBuffer buffer, IdResult resultId, IdRef payloadType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(payloadType);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeNodePayloadArrayAMDX, ..resultId.AsSpirvSpan(), ..payloadType.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeNodePayloadArrayAMDX</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeNodePayloadArrayAMDX(this SpirvBuffer buffer, int position, IdResult resultId, IdRef payloadType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(payloadType);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeNodePayloadArrayAMDX, ..resultId.AsSpirvSpan(), ..payloadType.AsSpirvSpan()]);
    }

    public static Instruction AddOpFinishWritingNodePayloadAMDX(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFinishWritingNodePayloadAMDX, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFinishWritingNodePayloadAMDX</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFinishWritingNodePayloadAMDX(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFinishWritingNodePayloadAMDX, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpNodePayloadArrayLengthAMDX(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payloadArray)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payloadArray);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpNodePayloadArrayLengthAMDX, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payloadArray.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpNodePayloadArrayLengthAMDX</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpNodePayloadArrayLengthAMDX(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payloadArray)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payloadArray);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpNodePayloadArrayLengthAMDX, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payloadArray.AsSpirvSpan()]);
    }

    public static Instruction AddOpIsNodePayloadValidAMDX(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payloadType, IdRef nodeIndex)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payloadType) + buffer.GetWordLength(nodeIndex);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIsNodePayloadValidAMDX, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payloadType.AsSpirvSpan(), ..nodeIndex.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIsNodePayloadValidAMDX</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpIsNodePayloadValidAMDX(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payloadType, IdRef nodeIndex)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payloadType) + buffer.GetWordLength(nodeIndex);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIsNodePayloadValidAMDX, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payloadType.AsSpirvSpan(), ..nodeIndex.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantStringAMDX(this SpirvBuffer buffer, IdResult resultId, LiteralString literalString)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(literalString);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantStringAMDX, ..resultId.AsSpirvSpan(), ..literalString.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantStringAMDX</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConstantStringAMDX(this SpirvBuffer buffer, int position, IdResult resultId, LiteralString literalString)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(literalString);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantStringAMDX, ..resultId.AsSpirvSpan(), ..literalString.AsSpirvSpan()]);
    }

    public static Instruction AddOpSpecConstantStringAMDX(this SpirvBuffer buffer, IdResult resultId, LiteralString literalString)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(literalString);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSpecConstantStringAMDX, ..resultId.AsSpirvSpan(), ..literalString.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSpecConstantStringAMDX</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSpecConstantStringAMDX(this SpirvBuffer buffer, int position, IdResult resultId, LiteralString literalString)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(literalString);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSpecConstantStringAMDX, ..resultId.AsSpirvSpan(), ..literalString.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformQuadAllKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformQuadAllKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformQuadAllKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformQuadAllKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformQuadAllKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformQuadAnyKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformQuadAnyKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformQuadAnyKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformQuadAnyKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef predicate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(predicate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformQuadAnyKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..predicate.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectRecordHitMotionNV(this SpirvBuffer buffer, IdRef hitObject, IdRef accelerationStructure, IdRef instanceId, IdRef primitiveId, IdRef geometryIndex, IdRef hitKind, IdRef sBTRecordOffset, IdRef sBTRecordStride, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef currentTime, IdRef hitObjectAttributes)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(primitiveId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(hitKind) + buffer.GetWordLength(sBTRecordOffset) + buffer.GetWordLength(sBTRecordStride) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(currentTime) + buffer.GetWordLength(hitObjectAttributes);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectRecordHitMotionNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..primitiveId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..hitKind.AsSpirvSpan(), ..sBTRecordOffset.AsSpirvSpan(), ..sBTRecordStride.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..currentTime.AsSpirvSpan(), ..hitObjectAttributes.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectRecordHitMotionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectRecordHitMotionNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef accelerationStructure, IdRef instanceId, IdRef primitiveId, IdRef geometryIndex, IdRef hitKind, IdRef sBTRecordOffset, IdRef sBTRecordStride, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef currentTime, IdRef hitObjectAttributes)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(primitiveId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(hitKind) + buffer.GetWordLength(sBTRecordOffset) + buffer.GetWordLength(sBTRecordStride) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(currentTime) + buffer.GetWordLength(hitObjectAttributes);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectRecordHitMotionNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..primitiveId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..hitKind.AsSpirvSpan(), ..sBTRecordOffset.AsSpirvSpan(), ..sBTRecordStride.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..currentTime.AsSpirvSpan(), ..hitObjectAttributes.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectRecordHitWithIndexMotionNV(this SpirvBuffer buffer, IdRef hitObject, IdRef accelerationStructure, IdRef instanceId, IdRef primitiveId, IdRef geometryIndex, IdRef hitKind, IdRef sBTRecordIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef currentTime, IdRef hitObjectAttributes)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(primitiveId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(hitKind) + buffer.GetWordLength(sBTRecordIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(currentTime) + buffer.GetWordLength(hitObjectAttributes);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectRecordHitWithIndexMotionNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..primitiveId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..hitKind.AsSpirvSpan(), ..sBTRecordIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..currentTime.AsSpirvSpan(), ..hitObjectAttributes.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectRecordHitWithIndexMotionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectRecordHitWithIndexMotionNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef accelerationStructure, IdRef instanceId, IdRef primitiveId, IdRef geometryIndex, IdRef hitKind, IdRef sBTRecordIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef currentTime, IdRef hitObjectAttributes)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(primitiveId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(hitKind) + buffer.GetWordLength(sBTRecordIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(currentTime) + buffer.GetWordLength(hitObjectAttributes);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectRecordHitWithIndexMotionNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..primitiveId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..hitKind.AsSpirvSpan(), ..sBTRecordIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..currentTime.AsSpirvSpan(), ..hitObjectAttributes.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectRecordMissMotionNV(this SpirvBuffer buffer, IdRef hitObject, IdRef sBTIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef currentTime)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(sBTIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(currentTime);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectRecordMissMotionNV, ..hitObject.AsSpirvSpan(), ..sBTIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..currentTime.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectRecordMissMotionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectRecordMissMotionNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef sBTIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef currentTime)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(sBTIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(currentTime);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectRecordMissMotionNV, ..hitObject.AsSpirvSpan(), ..sBTIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..currentTime.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetWorldToObjectNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetWorldToObjectNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetWorldToObjectNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetWorldToObjectNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetWorldToObjectNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetObjectToWorldNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetObjectToWorldNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetObjectToWorldNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetObjectToWorldNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetObjectToWorldNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetObjectRayDirectionNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetObjectRayDirectionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetObjectRayDirectionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetObjectRayDirectionNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetObjectRayDirectionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetObjectRayOriginNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetObjectRayOriginNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetObjectRayOriginNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetObjectRayOriginNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetObjectRayOriginNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectTraceRayMotionNV(this SpirvBuffer buffer, IdRef hitObject, IdRef accelerationStructure, IdRef rayFlags, IdRef cullmask, IdRef sBTRecordOffset, IdRef sBTRecordStride, IdRef missIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef time, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullmask) + buffer.GetWordLength(sBTRecordOffset) + buffer.GetWordLength(sBTRecordStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(time) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectTraceRayMotionNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullmask.AsSpirvSpan(), ..sBTRecordOffset.AsSpirvSpan(), ..sBTRecordStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..time.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectTraceRayMotionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectTraceRayMotionNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef accelerationStructure, IdRef rayFlags, IdRef cullmask, IdRef sBTRecordOffset, IdRef sBTRecordStride, IdRef missIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef time, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullmask) + buffer.GetWordLength(sBTRecordOffset) + buffer.GetWordLength(sBTRecordStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(time) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectTraceRayMotionNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullmask.AsSpirvSpan(), ..sBTRecordOffset.AsSpirvSpan(), ..sBTRecordStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..time.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetShaderRecordBufferHandleNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetShaderRecordBufferHandleNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetShaderRecordBufferHandleNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetShaderRecordBufferHandleNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetShaderRecordBufferHandleNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetShaderBindingTableRecordIndexNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetShaderBindingTableRecordIndexNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetShaderBindingTableRecordIndexNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetShaderBindingTableRecordIndexNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetShaderBindingTableRecordIndexNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectRecordEmptyNV(this SpirvBuffer buffer, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectRecordEmptyNV, ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectRecordEmptyNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectRecordEmptyNV(this SpirvBuffer buffer, int position, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectRecordEmptyNV, ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectTraceRayNV(this SpirvBuffer buffer, IdRef hitObject, IdRef accelerationStructure, IdRef rayFlags, IdRef cullmask, IdRef sBTRecordOffset, IdRef sBTRecordStride, IdRef missIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullmask) + buffer.GetWordLength(sBTRecordOffset) + buffer.GetWordLength(sBTRecordStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectTraceRayNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullmask.AsSpirvSpan(), ..sBTRecordOffset.AsSpirvSpan(), ..sBTRecordStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectTraceRayNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectTraceRayNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef accelerationStructure, IdRef rayFlags, IdRef cullmask, IdRef sBTRecordOffset, IdRef sBTRecordStride, IdRef missIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullmask) + buffer.GetWordLength(sBTRecordOffset) + buffer.GetWordLength(sBTRecordStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectTraceRayNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullmask.AsSpirvSpan(), ..sBTRecordOffset.AsSpirvSpan(), ..sBTRecordStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectRecordHitNV(this SpirvBuffer buffer, IdRef hitObject, IdRef accelerationStructure, IdRef instanceId, IdRef primitiveId, IdRef geometryIndex, IdRef hitKind, IdRef sBTRecordOffset, IdRef sBTRecordStride, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef hitObjectAttributes)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(primitiveId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(hitKind) + buffer.GetWordLength(sBTRecordOffset) + buffer.GetWordLength(sBTRecordStride) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(hitObjectAttributes);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectRecordHitNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..primitiveId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..hitKind.AsSpirvSpan(), ..sBTRecordOffset.AsSpirvSpan(), ..sBTRecordStride.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..hitObjectAttributes.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectRecordHitNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectRecordHitNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef accelerationStructure, IdRef instanceId, IdRef primitiveId, IdRef geometryIndex, IdRef hitKind, IdRef sBTRecordOffset, IdRef sBTRecordStride, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef hitObjectAttributes)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(primitiveId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(hitKind) + buffer.GetWordLength(sBTRecordOffset) + buffer.GetWordLength(sBTRecordStride) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(hitObjectAttributes);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectRecordHitNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..primitiveId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..hitKind.AsSpirvSpan(), ..sBTRecordOffset.AsSpirvSpan(), ..sBTRecordStride.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..hitObjectAttributes.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectRecordHitWithIndexNV(this SpirvBuffer buffer, IdRef hitObject, IdRef accelerationStructure, IdRef instanceId, IdRef primitiveId, IdRef geometryIndex, IdRef hitKind, IdRef sBTRecordIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef hitObjectAttributes)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(primitiveId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(hitKind) + buffer.GetWordLength(sBTRecordIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(hitObjectAttributes);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectRecordHitWithIndexNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..primitiveId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..hitKind.AsSpirvSpan(), ..sBTRecordIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..hitObjectAttributes.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectRecordHitWithIndexNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectRecordHitWithIndexNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef accelerationStructure, IdRef instanceId, IdRef primitiveId, IdRef geometryIndex, IdRef hitKind, IdRef sBTRecordIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax, IdRef hitObjectAttributes)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(accelerationStructure) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(primitiveId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(hitKind) + buffer.GetWordLength(sBTRecordIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax) + buffer.GetWordLength(hitObjectAttributes);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectRecordHitWithIndexNV, ..hitObject.AsSpirvSpan(), ..accelerationStructure.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..primitiveId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..hitKind.AsSpirvSpan(), ..sBTRecordIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan(), ..hitObjectAttributes.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectRecordMissNV(this SpirvBuffer buffer, IdRef hitObject, IdRef sBTIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(sBTIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectRecordMissNV, ..hitObject.AsSpirvSpan(), ..sBTIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectRecordMissNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectRecordMissNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef sBTIndex, IdRef origin, IdRef tMin, IdRef direction, IdRef tMax)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(sBTIndex) + buffer.GetWordLength(origin) + buffer.GetWordLength(tMin) + buffer.GetWordLength(direction) + buffer.GetWordLength(tMax);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectRecordMissNV, ..hitObject.AsSpirvSpan(), ..sBTIndex.AsSpirvSpan(), ..origin.AsSpirvSpan(), ..tMin.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..tMax.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectExecuteShaderNV(this SpirvBuffer buffer, IdRef hitObject, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectExecuteShaderNV, ..hitObject.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectExecuteShaderNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectExecuteShaderNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectExecuteShaderNV, ..hitObject.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetCurrentTimeNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetCurrentTimeNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetCurrentTimeNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetCurrentTimeNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetCurrentTimeNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetAttributesNV(this SpirvBuffer buffer, IdRef hitObject, IdRef hitObjectAttribute)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(hitObjectAttribute);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetAttributesNV, ..hitObject.AsSpirvSpan(), ..hitObjectAttribute.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetAttributesNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetAttributesNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef hitObjectAttribute)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(hitObjectAttribute);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetAttributesNV, ..hitObject.AsSpirvSpan(), ..hitObjectAttribute.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetHitKindNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetHitKindNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetHitKindNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetHitKindNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetHitKindNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetPrimitiveIndexNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetPrimitiveIndexNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetPrimitiveIndexNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetPrimitiveIndexNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetPrimitiveIndexNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetGeometryIndexNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetGeometryIndexNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetGeometryIndexNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetGeometryIndexNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetGeometryIndexNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetInstanceIdNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetInstanceIdNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetInstanceIdNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetInstanceIdNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetInstanceIdNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetInstanceCustomIndexNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetInstanceCustomIndexNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetInstanceCustomIndexNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetInstanceCustomIndexNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetInstanceCustomIndexNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetWorldRayDirectionNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetWorldRayDirectionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetWorldRayDirectionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetWorldRayDirectionNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetWorldRayDirectionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetWorldRayOriginNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetWorldRayOriginNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetWorldRayOriginNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetWorldRayOriginNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetWorldRayOriginNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetRayTMaxNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetRayTMaxNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetRayTMaxNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetRayTMaxNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetRayTMaxNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectGetRayTMinNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectGetRayTMinNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectGetRayTMinNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectGetRayTMinNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectGetRayTMinNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectIsEmptyNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectIsEmptyNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectIsEmptyNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectIsEmptyNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectIsEmptyNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectIsHitNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectIsHitNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectIsHitNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectIsHitNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectIsHitNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpHitObjectIsMissNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpHitObjectIsMissNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpHitObjectIsMissNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpHitObjectIsMissNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hitObject)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hitObject);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpHitObjectIsMissNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hitObject.AsSpirvSpan()]);
    }

    public static Instruction AddOpReorderThreadWithHitObjectNV(this SpirvBuffer buffer, IdRef hitObject, IdRef? hint, IdRef? bits)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(hint) + buffer.GetWordLength(bits);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReorderThreadWithHitObjectNV, ..hitObject.AsSpirvSpan(), ..hint.AsSpirvSpan(), ..bits.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReorderThreadWithHitObjectNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpReorderThreadWithHitObjectNV(this SpirvBuffer buffer, int position, IdRef hitObject, IdRef? hint, IdRef? bits)
    {
        var wordLength = 1 + buffer.GetWordLength(hitObject) + buffer.GetWordLength(hint) + buffer.GetWordLength(bits);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReorderThreadWithHitObjectNV, ..hitObject.AsSpirvSpan(), ..hint.AsSpirvSpan(), ..bits.AsSpirvSpan()]);
    }

    public static Instruction AddOpReorderThreadWithHintNV(this SpirvBuffer buffer, IdRef hint, IdRef bits)
    {
        var wordLength = 1 + buffer.GetWordLength(hint) + buffer.GetWordLength(bits);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReorderThreadWithHintNV, ..hint.AsSpirvSpan(), ..bits.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReorderThreadWithHintNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpReorderThreadWithHintNV(this SpirvBuffer buffer, int position, IdRef hint, IdRef bits)
    {
        var wordLength = 1 + buffer.GetWordLength(hint) + buffer.GetWordLength(bits);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReorderThreadWithHintNV, ..hint.AsSpirvSpan(), ..bits.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeHitObjectNV(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeHitObjectNV, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeHitObjectNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeHitObjectNV(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeHitObjectNV, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpImageSampleFootprintNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef granularity, IdRef coarse, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(granularity) + buffer.GetWordLength(coarse) + buffer.GetWordLength(imageoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpImageSampleFootprintNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..granularity.AsSpirvSpan(), ..coarse.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpImageSampleFootprintNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpImageSampleFootprintNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sampledImage, IdRef coordinate, IdRef granularity, IdRef coarse, ImageOperandsMask? imageoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sampledImage) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(granularity) + buffer.GetWordLength(coarse) + buffer.GetWordLength(imageoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpImageSampleFootprintNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sampledImage.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..granularity.AsSpirvSpan(), ..coarse.AsSpirvSpan(), ..imageoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixConvertNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef matrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixConvertNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixConvertNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixConvertNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef matrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixConvertNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan()]);
    }

    public static Instruction AddOpEmitMeshTasksEXT(this SpirvBuffer buffer, IdRef groupCountX, IdRef groupCountY, IdRef groupCountZ, IdRef? payload)
    {
        var wordLength = 1 + buffer.GetWordLength(groupCountX) + buffer.GetWordLength(groupCountY) + buffer.GetWordLength(groupCountZ) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpEmitMeshTasksEXT, ..groupCountX.AsSpirvSpan(), ..groupCountY.AsSpirvSpan(), ..groupCountZ.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpEmitMeshTasksEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpEmitMeshTasksEXT(this SpirvBuffer buffer, int position, IdRef groupCountX, IdRef groupCountY, IdRef groupCountZ, IdRef? payload)
    {
        var wordLength = 1 + buffer.GetWordLength(groupCountX) + buffer.GetWordLength(groupCountY) + buffer.GetWordLength(groupCountZ) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpEmitMeshTasksEXT, ..groupCountX.AsSpirvSpan(), ..groupCountY.AsSpirvSpan(), ..groupCountZ.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSetMeshOutputsEXT(this SpirvBuffer buffer, IdRef vertexCount, IdRef primitiveCount)
    {
        var wordLength = 1 + buffer.GetWordLength(vertexCount) + buffer.GetWordLength(primitiveCount);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSetMeshOutputsEXT, ..vertexCount.AsSpirvSpan(), ..primitiveCount.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSetMeshOutputsEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSetMeshOutputsEXT(this SpirvBuffer buffer, int position, IdRef vertexCount, IdRef primitiveCount)
    {
        var wordLength = 1 + buffer.GetWordLength(vertexCount) + buffer.GetWordLength(primitiveCount);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSetMeshOutputsEXT, ..vertexCount.AsSpirvSpan(), ..primitiveCount.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupNonUniformPartitionNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupNonUniformPartitionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupNonUniformPartitionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupNonUniformPartitionNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupNonUniformPartitionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpWritePackedPrimitiveIndices4x8NV(this SpirvBuffer buffer, IdRef indexOffset, IdRef packedIndices)
    {
        var wordLength = 1 + buffer.GetWordLength(indexOffset) + buffer.GetWordLength(packedIndices);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpWritePackedPrimitiveIndices4x8NV, ..indexOffset.AsSpirvSpan(), ..packedIndices.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpWritePackedPrimitiveIndices4x8NV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpWritePackedPrimitiveIndices4x8NV(this SpirvBuffer buffer, int position, IdRef indexOffset, IdRef packedIndices)
    {
        var wordLength = 1 + buffer.GetWordLength(indexOffset) + buffer.GetWordLength(packedIndices);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpWritePackedPrimitiveIndices4x8NV, ..indexOffset.AsSpirvSpan(), ..packedIndices.AsSpirvSpan()]);
    }

    public static Instruction AddOpFetchMicroTriangleVertexPositionNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef accel, IdRef instanceId, IdRef geometryIndex, IdRef primitiveIndex, IdRef barycentric)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(accel) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(primitiveIndex) + buffer.GetWordLength(barycentric);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFetchMicroTriangleVertexPositionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..accel.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..primitiveIndex.AsSpirvSpan(), ..barycentric.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFetchMicroTriangleVertexPositionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFetchMicroTriangleVertexPositionNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef accel, IdRef instanceId, IdRef geometryIndex, IdRef primitiveIndex, IdRef barycentric)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(accel) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(primitiveIndex) + buffer.GetWordLength(barycentric);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFetchMicroTriangleVertexPositionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..accel.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..primitiveIndex.AsSpirvSpan(), ..barycentric.AsSpirvSpan()]);
    }

    public static Instruction AddOpFetchMicroTriangleVertexBarycentricNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef accel, IdRef instanceId, IdRef geometryIndex, IdRef primitiveIndex, IdRef barycentric)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(accel) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(primitiveIndex) + buffer.GetWordLength(barycentric);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFetchMicroTriangleVertexBarycentricNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..accel.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..primitiveIndex.AsSpirvSpan(), ..barycentric.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFetchMicroTriangleVertexBarycentricNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFetchMicroTriangleVertexBarycentricNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef accel, IdRef instanceId, IdRef geometryIndex, IdRef primitiveIndex, IdRef barycentric)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(accel) + buffer.GetWordLength(instanceId) + buffer.GetWordLength(geometryIndex) + buffer.GetWordLength(primitiveIndex) + buffer.GetWordLength(barycentric);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFetchMicroTriangleVertexBarycentricNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..accel.AsSpirvSpan(), ..instanceId.AsSpirvSpan(), ..geometryIndex.AsSpirvSpan(), ..primitiveIndex.AsSpirvSpan(), ..barycentric.AsSpirvSpan()]);
    }

    public static Instruction AddOpReportIntersectionKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef hit, IdRef hitKind)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hit) + buffer.GetWordLength(hitKind);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReportIntersectionKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hit.AsSpirvSpan(), ..hitKind.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReportIntersectionKHR (OpReportIntersectionNV)</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpReportIntersectionKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef hit, IdRef hitKind)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(hit) + buffer.GetWordLength(hitKind);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReportIntersectionKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..hit.AsSpirvSpan(), ..hitKind.AsSpirvSpan()]);
    }

    public static Instruction AddOpIgnoreIntersectionNV(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpIgnoreIntersectionNV]);
    }

    /// <summary>
    /// <para><c>OpIgnoreIntersectionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpIgnoreIntersectionNV(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpIgnoreIntersectionNV]);
    }

    public static Instruction AddOpTerminateRayNV(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpTerminateRayNV]);
    }

    /// <summary>
    /// <para><c>OpTerminateRayNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTerminateRayNV(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpTerminateRayNV]);
    }

    public static Instruction AddOpTraceNV(this SpirvBuffer buffer, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef sBTOffset, IdRef sBTStride, IdRef missIndex, IdRef rayOrigin, IdRef rayTmin, IdRef rayDirection, IdRef rayTmax, IdRef payloadId)
    {
        var wordLength = 1 + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(sBTOffset) + buffer.GetWordLength(sBTStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTmin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTmax) + buffer.GetWordLength(payloadId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTraceNV, ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..sBTOffset.AsSpirvSpan(), ..sBTStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTmin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTmax.AsSpirvSpan(), ..payloadId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTraceNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTraceNV(this SpirvBuffer buffer, int position, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef sBTOffset, IdRef sBTStride, IdRef missIndex, IdRef rayOrigin, IdRef rayTmin, IdRef rayDirection, IdRef rayTmax, IdRef payloadId)
    {
        var wordLength = 1 + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(sBTOffset) + buffer.GetWordLength(sBTStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTmin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTmax) + buffer.GetWordLength(payloadId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTraceNV, ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..sBTOffset.AsSpirvSpan(), ..sBTStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTmin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTmax.AsSpirvSpan(), ..payloadId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTraceMotionNV(this SpirvBuffer buffer, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef sBTOffset, IdRef sBTStride, IdRef missIndex, IdRef rayOrigin, IdRef rayTmin, IdRef rayDirection, IdRef rayTmax, IdRef time, IdRef payloadId)
    {
        var wordLength = 1 + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(sBTOffset) + buffer.GetWordLength(sBTStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTmin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTmax) + buffer.GetWordLength(time) + buffer.GetWordLength(payloadId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTraceMotionNV, ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..sBTOffset.AsSpirvSpan(), ..sBTStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTmin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTmax.AsSpirvSpan(), ..time.AsSpirvSpan(), ..payloadId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTraceMotionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTraceMotionNV(this SpirvBuffer buffer, int position, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef sBTOffset, IdRef sBTStride, IdRef missIndex, IdRef rayOrigin, IdRef rayTmin, IdRef rayDirection, IdRef rayTmax, IdRef time, IdRef payloadId)
    {
        var wordLength = 1 + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(sBTOffset) + buffer.GetWordLength(sBTStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTmin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTmax) + buffer.GetWordLength(time) + buffer.GetWordLength(payloadId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTraceMotionNV, ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..sBTOffset.AsSpirvSpan(), ..sBTStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTmin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTmax.AsSpirvSpan(), ..time.AsSpirvSpan(), ..payloadId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTraceRayMotionNV(this SpirvBuffer buffer, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef sBTOffset, IdRef sBTStride, IdRef missIndex, IdRef rayOrigin, IdRef rayTmin, IdRef rayDirection, IdRef rayTmax, IdRef time, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(sBTOffset) + buffer.GetWordLength(sBTStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTmin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTmax) + buffer.GetWordLength(time) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTraceRayMotionNV, ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..sBTOffset.AsSpirvSpan(), ..sBTStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTmin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTmax.AsSpirvSpan(), ..time.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTraceRayMotionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTraceRayMotionNV(this SpirvBuffer buffer, int position, IdRef accel, IdRef rayFlags, IdRef cullMask, IdRef sBTOffset, IdRef sBTStride, IdRef missIndex, IdRef rayOrigin, IdRef rayTmin, IdRef rayDirection, IdRef rayTmax, IdRef time, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(accel) + buffer.GetWordLength(rayFlags) + buffer.GetWordLength(cullMask) + buffer.GetWordLength(sBTOffset) + buffer.GetWordLength(sBTStride) + buffer.GetWordLength(missIndex) + buffer.GetWordLength(rayOrigin) + buffer.GetWordLength(rayTmin) + buffer.GetWordLength(rayDirection) + buffer.GetWordLength(rayTmax) + buffer.GetWordLength(time) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTraceRayMotionNV, ..accel.AsSpirvSpan(), ..rayFlags.AsSpirvSpan(), ..cullMask.AsSpirvSpan(), ..sBTOffset.AsSpirvSpan(), ..sBTStride.AsSpirvSpan(), ..missIndex.AsSpirvSpan(), ..rayOrigin.AsSpirvSpan(), ..rayTmin.AsSpirvSpan(), ..rayDirection.AsSpirvSpan(), ..rayTmax.AsSpirvSpan(), ..time.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionTriangleVertexPositionsKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionTriangleVertexPositionsKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionTriangleVertexPositionsKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionTriangleVertexPositionsKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionTriangleVertexPositionsKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAccelerationStructureKHR(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAccelerationStructureKHR, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeAccelerationStructureKHR (OpTypeAccelerationStructureNV)</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeAccelerationStructureKHR(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAccelerationStructureKHR, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpExecuteCallableNV(this SpirvBuffer buffer, IdRef sBTIndex, IdRef callableDataId)
    {
        var wordLength = 1 + buffer.GetWordLength(sBTIndex) + buffer.GetWordLength(callableDataId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExecuteCallableNV, ..sBTIndex.AsSpirvSpan(), ..callableDataId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExecuteCallableNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpExecuteCallableNV(this SpirvBuffer buffer, int position, IdRef sBTIndex, IdRef callableDataId)
    {
        var wordLength = 1 + buffer.GetWordLength(sBTIndex) + buffer.GetWordLength(callableDataId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExecuteCallableNV, ..sBTIndex.AsSpirvSpan(), ..callableDataId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeCooperativeMatrixNV(this SpirvBuffer buffer, IdResult resultId, IdRef componentType, IdScope execution, IdRef rows, IdRef columns)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(componentType) + buffer.GetWordLength(execution) + buffer.GetWordLength(rows) + buffer.GetWordLength(columns);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeCooperativeMatrixNV, ..resultId.AsSpirvSpan(), ..componentType.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..rows.AsSpirvSpan(), ..columns.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeCooperativeMatrixNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeCooperativeMatrixNV(this SpirvBuffer buffer, int position, IdResult resultId, IdRef componentType, IdScope execution, IdRef rows, IdRef columns)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(componentType) + buffer.GetWordLength(execution) + buffer.GetWordLength(rows) + buffer.GetWordLength(columns);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeCooperativeMatrixNV, ..resultId.AsSpirvSpan(), ..componentType.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..rows.AsSpirvSpan(), ..columns.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixLoadNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdRef stride, IdRef columnMajor, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(stride) + buffer.GetWordLength(columnMajor) + buffer.GetWordLength(memoryaccess);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLoadNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..columnMajor.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixLoadNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixLoadNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdRef stride, IdRef columnMajor, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(stride) + buffer.GetWordLength(columnMajor) + buffer.GetWordLength(memoryaccess);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLoadNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..columnMajor.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixStoreNV(this SpirvBuffer buffer, IdRef pointer, IdRef objectId, IdRef stride, IdRef columnMajor, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(stride) + buffer.GetWordLength(columnMajor) + buffer.GetWordLength(memoryaccess);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixStoreNV, ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..columnMajor.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixStoreNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixStoreNV(this SpirvBuffer buffer, int position, IdRef pointer, IdRef objectId, IdRef stride, IdRef columnMajor, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(stride) + buffer.GetWordLength(columnMajor) + buffer.GetWordLength(memoryaccess);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixStoreNV, ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..stride.AsSpirvSpan(), ..columnMajor.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixMulAddNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, IdRef b, IdRef c)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(b) + buffer.GetWordLength(c);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixMulAddNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..b.AsSpirvSpan(), ..c.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixMulAddNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixMulAddNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, IdRef b, IdRef c)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(b) + buffer.GetWordLength(c);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixMulAddNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..b.AsSpirvSpan(), ..c.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixLengthNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef type)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(type);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLengthNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..type.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixLengthNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixLengthNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef type)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(type);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLengthNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..type.AsSpirvSpan()]);
    }

    public static Instruction AddOpBeginInvocationInterlockEXT(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpBeginInvocationInterlockEXT]);
    }

    /// <summary>
    /// <para><c>OpBeginInvocationInterlockEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpBeginInvocationInterlockEXT(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpBeginInvocationInterlockEXT]);
    }

    public static Instruction AddOpEndInvocationInterlockEXT(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpEndInvocationInterlockEXT]);
    }

    /// <summary>
    /// <para><c>OpEndInvocationInterlockEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpEndInvocationInterlockEXT(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpEndInvocationInterlockEXT]);
    }

    public static Instruction AddOpCooperativeMatrixReduceNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef matrix, CooperativeMatrixReduceMask reduce, IdRef combineFunc)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix) + buffer.GetWordLength(reduce) + buffer.GetWordLength(combineFunc);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixReduceNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan(), ..reduce.AsSpirvSpan(), ..combineFunc.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixReduceNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixReduceNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef matrix, CooperativeMatrixReduceMask reduce, IdRef combineFunc)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix) + buffer.GetWordLength(reduce) + buffer.GetWordLength(combineFunc);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixReduceNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan(), ..reduce.AsSpirvSpan(), ..combineFunc.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixLoadTensorNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdRef objectId, IdRef tensorLayout, MemoryAccessMask memoryOperand, TensorAddressingOperandsMask tensorAddressingOperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(memoryOperand) + buffer.GetWordLength(tensorAddressingOperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLoadTensorNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..memoryOperand.AsSpirvSpan(), ..tensorAddressingOperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixLoadTensorNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixLoadTensorNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdRef objectId, IdRef tensorLayout, MemoryAccessMask memoryOperand, TensorAddressingOperandsMask tensorAddressingOperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(memoryOperand) + buffer.GetWordLength(tensorAddressingOperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixLoadTensorNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..memoryOperand.AsSpirvSpan(), ..tensorAddressingOperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixStoreTensorNV(this SpirvBuffer buffer, IdRef pointer, IdRef objectId, IdRef tensorLayout, MemoryAccessMask memoryOperand, TensorAddressingOperandsMask tensorAddressingOperands)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(memoryOperand) + buffer.GetWordLength(tensorAddressingOperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixStoreTensorNV, ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..memoryOperand.AsSpirvSpan(), ..tensorAddressingOperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixStoreTensorNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixStoreTensorNV(this SpirvBuffer buffer, int position, IdRef pointer, IdRef objectId, IdRef tensorLayout, MemoryAccessMask memoryOperand, TensorAddressingOperandsMask tensorAddressingOperands)
    {
        var wordLength = 1 + buffer.GetWordLength(pointer) + buffer.GetWordLength(objectId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(memoryOperand) + buffer.GetWordLength(tensorAddressingOperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixStoreTensorNV, ..pointer.AsSpirvSpan(), ..objectId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..memoryOperand.AsSpirvSpan(), ..tensorAddressingOperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixPerElementOpNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef matrix, IdRef func, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix) + buffer.GetWordLength(func) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixPerElementOpNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan(), ..func.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixPerElementOpNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixPerElementOpNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef matrix, IdRef func, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix) + buffer.GetWordLength(func) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixPerElementOpNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan(), ..func.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeTensorLayoutNV(this SpirvBuffer buffer, IdResult resultId, IdRef dim, IdRef clampMode)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(dim) + buffer.GetWordLength(clampMode);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeTensorLayoutNV, ..resultId.AsSpirvSpan(), ..dim.AsSpirvSpan(), ..clampMode.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeTensorLayoutNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeTensorLayoutNV(this SpirvBuffer buffer, int position, IdResult resultId, IdRef dim, IdRef clampMode)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(dim) + buffer.GetWordLength(clampMode);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeTensorLayoutNV, ..resultId.AsSpirvSpan(), ..dim.AsSpirvSpan(), ..clampMode.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeTensorViewNV(this SpirvBuffer buffer, IdResult resultId, IdRef dim, IdRef hasDimensions, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(dim) + buffer.GetWordLength(hasDimensions) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeTensorViewNV, ..resultId.AsSpirvSpan(), ..dim.AsSpirvSpan(), ..hasDimensions.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeTensorViewNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeTensorViewNV(this SpirvBuffer buffer, int position, IdResult resultId, IdRef dim, IdRef hasDimensions, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(dim) + buffer.GetWordLength(hasDimensions) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeTensorViewNV, ..resultId.AsSpirvSpan(), ..dim.AsSpirvSpan(), ..hasDimensions.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpCreateTensorLayoutNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCreateTensorLayoutNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCreateTensorLayoutNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCreateTensorLayoutNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCreateTensorLayoutNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTensorLayoutSetDimensionNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef tensorLayout, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTensorLayoutSetDimensionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTensorLayoutSetDimensionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTensorLayoutSetDimensionNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef tensorLayout, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTensorLayoutSetDimensionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpTensorLayoutSetStrideNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef tensorLayout, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTensorLayoutSetStrideNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTensorLayoutSetStrideNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTensorLayoutSetStrideNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef tensorLayout, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTensorLayoutSetStrideNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpTensorLayoutSliceNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef tensorLayout, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTensorLayoutSliceNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTensorLayoutSliceNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTensorLayoutSliceNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef tensorLayout, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTensorLayoutSliceNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpTensorLayoutSetClampValueNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef tensorLayout, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTensorLayoutSetClampValueNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTensorLayoutSetClampValueNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTensorLayoutSetClampValueNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef tensorLayout, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTensorLayoutSetClampValueNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpCreateTensorViewNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCreateTensorViewNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCreateTensorViewNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCreateTensorViewNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCreateTensorViewNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTensorViewSetDimensionNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef tensorView, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorView) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTensorViewSetDimensionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorView.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTensorViewSetDimensionNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTensorViewSetDimensionNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef tensorView, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorView) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTensorViewSetDimensionNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorView.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpTensorViewSetStrideNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef tensorView, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorView) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTensorViewSetStrideNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorView.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTensorViewSetStrideNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTensorViewSetStrideNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef tensorView, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorView) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTensorViewSetStrideNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorView.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpDemoteToHelperInvocation(this SpirvBuffer buffer)
    {
        return buffer.Add([1 << 16 | (int)SDSLOp.OpDemoteToHelperInvocation]);
    }

    /// <summary>
    /// <para><c>OpDemoteToHelperInvocation (OpDemoteToHelperInvocationEXT)</c></para>
    /// <para>Demote this fragment shader invocation to a helper invocation. Any stores to memory after this instruction are suppressed and the fragment does not write outputs to the framebuffer.</para>
    /// <para>Unlike the OpTerminateInvocation instruction, this does not necessarily terminate the invocation which might be needed for derivative calculations. It is not considered a flow control instruction (flow control does not become non-uniform) and does not terminate the block. The implementation may terminate helper invocations before the end of the shader as an optimization, but doing so must not affect derivative calculations and does not make control flow non-uniform.</para>
    /// <para>After an invocation executes this instruction, any subsequent load of HelperInvocation  within that invocation will load an undefined value unless the HelperInvocation built-in variable is decorated with Volatile or the load included Volatile in its Memory Operands</para>
    /// <para>This instruction is only valid in the Fragment Execution Model.</para>
    /// </summary>
    public static Instruction InsertOpDemoteToHelperInvocation(this SpirvBuffer buffer, int position)
    {
        return buffer.Insert(position, [1 << 16 | (int)SDSLOp.OpDemoteToHelperInvocation]);
    }

    public static Instruction AddOpIsHelperInvocationEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIsHelperInvocationEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIsHelperInvocationEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpIsHelperInvocationEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIsHelperInvocationEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTensorViewSetClipNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef tensorView, IdRef clipRowOffset, IdRef clipRowSpan, IdRef clipColOffset, IdRef clipColSpan)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorView) + buffer.GetWordLength(clipRowOffset) + buffer.GetWordLength(clipRowSpan) + buffer.GetWordLength(clipColOffset) + buffer.GetWordLength(clipColSpan);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTensorViewSetClipNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorView.AsSpirvSpan(), ..clipRowOffset.AsSpirvSpan(), ..clipRowSpan.AsSpirvSpan(), ..clipColOffset.AsSpirvSpan(), ..clipColSpan.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTensorViewSetClipNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTensorViewSetClipNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef tensorView, IdRef clipRowOffset, IdRef clipRowSpan, IdRef clipColOffset, IdRef clipColSpan)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorView) + buffer.GetWordLength(clipRowOffset) + buffer.GetWordLength(clipRowSpan) + buffer.GetWordLength(clipColOffset) + buffer.GetWordLength(clipColSpan);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTensorViewSetClipNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorView.AsSpirvSpan(), ..clipRowOffset.AsSpirvSpan(), ..clipRowSpan.AsSpirvSpan(), ..clipColOffset.AsSpirvSpan(), ..clipColSpan.AsSpirvSpan()]);
    }

    public static Instruction AddOpTensorLayoutSetBlockSizeNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef tensorLayout, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTensorLayoutSetBlockSizeNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTensorLayoutSetBlockSizeNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTensorLayoutSetBlockSizeNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef tensorLayout, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(tensorLayout) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTensorLayoutSetBlockSizeNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..tensorLayout.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpCooperativeMatrixTransposeNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef matrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixTransposeNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCooperativeMatrixTransposeNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCooperativeMatrixTransposeNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef matrix)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(matrix);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCooperativeMatrixTransposeNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..matrix.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertUToImageNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertUToImageNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertUToImageNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertUToImageNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertUToImageNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertUToSamplerNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertUToSamplerNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertUToSamplerNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertUToSamplerNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertUToSamplerNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertImageToUNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertImageToUNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertImageToUNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertImageToUNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertImageToUNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertSamplerToUNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertSamplerToUNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertSamplerToUNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertSamplerToUNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertSamplerToUNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertUToSampledImageNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertUToSampledImageNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertUToSampledImageNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertUToSampledImageNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertUToSampledImageNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertSampledImageToUNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertSampledImageToUNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertSampledImageToUNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertSampledImageToUNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertSampledImageToUNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpSamplerImageAddressingModeNV(this SpirvBuffer buffer, LiteralInteger bitWidth)
    {
        var wordLength = 1 + buffer.GetWordLength(bitWidth);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSamplerImageAddressingModeNV, ..bitWidth.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSamplerImageAddressingModeNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSamplerImageAddressingModeNV(this SpirvBuffer buffer, int position, LiteralInteger bitWidth)
    {
        var wordLength = 1 + buffer.GetWordLength(bitWidth);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSamplerImageAddressingModeNV, ..bitWidth.AsSpirvSpan()]);
    }

    public static Instruction AddOpRawAccessChainNV(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef bytestride, IdRef elementindex, IdRef byteoffset, RawAccessChainOperandsMask? rawaccesschainoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(bytestride) + buffer.GetWordLength(elementindex) + buffer.GetWordLength(byteoffset) + buffer.GetWordLength(rawaccesschainoperands);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRawAccessChainNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..bytestride.AsSpirvSpan(), ..elementindex.AsSpirvSpan(), ..byteoffset.AsSpirvSpan(), ..rawaccesschainoperands.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRawAccessChainNV</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRawAccessChainNV(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef baseId, IdRef bytestride, IdRef elementindex, IdRef byteoffset, RawAccessChainOperandsMask? rawaccesschainoperands)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(baseId) + buffer.GetWordLength(bytestride) + buffer.GetWordLength(elementindex) + buffer.GetWordLength(byteoffset) + buffer.GetWordLength(rawaccesschainoperands);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRawAccessChainNV, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..baseId.AsSpirvSpan(), ..bytestride.AsSpirvSpan(), ..elementindex.AsSpirvSpan(), ..byteoffset.AsSpirvSpan(), ..rawaccesschainoperands.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupShuffleINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef data, IdRef invocationId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(data) + buffer.GetWordLength(invocationId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupShuffleINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..data.AsSpirvSpan(), ..invocationId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupShuffleINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupShuffleINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef data, IdRef invocationId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(data) + buffer.GetWordLength(invocationId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupShuffleINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..data.AsSpirvSpan(), ..invocationId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupShuffleDownINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef current, IdRef next, IdRef delta)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(current) + buffer.GetWordLength(next) + buffer.GetWordLength(delta);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupShuffleDownINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..current.AsSpirvSpan(), ..next.AsSpirvSpan(), ..delta.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupShuffleDownINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupShuffleDownINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef current, IdRef next, IdRef delta)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(current) + buffer.GetWordLength(next) + buffer.GetWordLength(delta);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupShuffleDownINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..current.AsSpirvSpan(), ..next.AsSpirvSpan(), ..delta.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupShuffleUpINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef previous, IdRef current, IdRef delta)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(previous) + buffer.GetWordLength(current) + buffer.GetWordLength(delta);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupShuffleUpINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..previous.AsSpirvSpan(), ..current.AsSpirvSpan(), ..delta.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupShuffleUpINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupShuffleUpINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef previous, IdRef current, IdRef delta)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(previous) + buffer.GetWordLength(current) + buffer.GetWordLength(delta);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupShuffleUpINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..previous.AsSpirvSpan(), ..current.AsSpirvSpan(), ..delta.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupShuffleXorINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef data, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(data) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupShuffleXorINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..data.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupShuffleXorINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupShuffleXorINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef data, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(data) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupShuffleXorINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..data.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupBlockReadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef ptr)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(ptr);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupBlockReadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..ptr.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupBlockReadINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupBlockReadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef ptr)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(ptr);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupBlockReadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..ptr.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupBlockWriteINTEL(this SpirvBuffer buffer, IdRef ptr, IdRef data)
    {
        var wordLength = 1 + buffer.GetWordLength(ptr) + buffer.GetWordLength(data);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupBlockWriteINTEL, ..ptr.AsSpirvSpan(), ..data.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupBlockWriteINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupBlockWriteINTEL(this SpirvBuffer buffer, int position, IdRef ptr, IdRef data)
    {
        var wordLength = 1 + buffer.GetWordLength(ptr) + buffer.GetWordLength(data);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupBlockWriteINTEL, ..ptr.AsSpirvSpan(), ..data.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupImageBlockReadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupImageBlockReadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupImageBlockReadINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupImageBlockReadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupImageBlockReadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupImageBlockWriteINTEL(this SpirvBuffer buffer, IdRef image, IdRef coordinate, IdRef data)
    {
        var wordLength = 1 + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(data);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupImageBlockWriteINTEL, ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..data.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupImageBlockWriteINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupImageBlockWriteINTEL(this SpirvBuffer buffer, int position, IdRef image, IdRef coordinate, IdRef data)
    {
        var wordLength = 1 + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(data);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupImageBlockWriteINTEL, ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..data.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupImageMediaBlockReadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, IdRef width, IdRef height)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(width) + buffer.GetWordLength(height);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupImageMediaBlockReadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..width.AsSpirvSpan(), ..height.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupImageMediaBlockReadINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupImageMediaBlockReadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef image, IdRef coordinate, IdRef width, IdRef height)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(width) + buffer.GetWordLength(height);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupImageMediaBlockReadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..width.AsSpirvSpan(), ..height.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupImageMediaBlockWriteINTEL(this SpirvBuffer buffer, IdRef image, IdRef coordinate, IdRef width, IdRef height, IdRef data)
    {
        var wordLength = 1 + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(width) + buffer.GetWordLength(height) + buffer.GetWordLength(data);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupImageMediaBlockWriteINTEL, ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..width.AsSpirvSpan(), ..height.AsSpirvSpan(), ..data.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupImageMediaBlockWriteINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupImageMediaBlockWriteINTEL(this SpirvBuffer buffer, int position, IdRef image, IdRef coordinate, IdRef width, IdRef height, IdRef data)
    {
        var wordLength = 1 + buffer.GetWordLength(image) + buffer.GetWordLength(coordinate) + buffer.GetWordLength(width) + buffer.GetWordLength(height) + buffer.GetWordLength(data);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupImageMediaBlockWriteINTEL, ..image.AsSpirvSpan(), ..coordinate.AsSpirvSpan(), ..width.AsSpirvSpan(), ..height.AsSpirvSpan(), ..data.AsSpirvSpan()]);
    }

    public static Instruction AddOpUCountLeadingZerosINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUCountLeadingZerosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUCountLeadingZerosINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUCountLeadingZerosINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUCountLeadingZerosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpUCountTrailingZerosINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUCountTrailingZerosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUCountTrailingZerosINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUCountTrailingZerosINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUCountTrailingZerosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand.AsSpirvSpan()]);
    }

    public static Instruction AddOpAbsISubINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAbsISubINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAbsISubINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAbsISubINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAbsISubINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpAbsUSubINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAbsUSubINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAbsUSubINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAbsUSubINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAbsUSubINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpIAddSatINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIAddSatINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIAddSatINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpIAddSatINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIAddSatINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUAddSatINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUAddSatINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUAddSatINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUAddSatINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUAddSatINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpIAverageINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIAverageINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIAverageINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpIAverageINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIAverageINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUAverageINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUAverageINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUAverageINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUAverageINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUAverageINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpIAverageRoundedINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIAverageRoundedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIAverageRoundedINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpIAverageRoundedINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIAverageRoundedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUAverageRoundedINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUAverageRoundedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUAverageRoundedINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUAverageRoundedINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUAverageRoundedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpISubSatINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpISubSatINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpISubSatINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpISubSatINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpISubSatINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUSubSatINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUSubSatINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUSubSatINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUSubSatINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUSubSatINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpIMul32x16INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpIMul32x16INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpIMul32x16INTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpIMul32x16INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpIMul32x16INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpUMul32x16INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpUMul32x16INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUMul32x16INTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpUMul32x16INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef operand1, IdRef operand2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(operand1) + buffer.GetWordLength(operand2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpUMul32x16INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..operand1.AsSpirvSpan(), ..operand2.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantFunctionPointerINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef function)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(function);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantFunctionPointerINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..function.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUMul32x16INTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConstantFunctionPointerINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef function)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(function);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantFunctionPointerINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..function.AsSpirvSpan()]);
    }

    public static Instruction AddOpFunctionPointerCallINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFunctionPointerCallINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUMul32x16INTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFunctionPointerCallINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFunctionPointerCallINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpAsmTargetINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, LiteralString asmtarget)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(asmtarget);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAsmTargetINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..asmtarget.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUMul32x16INTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAsmTargetINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, LiteralString asmtarget)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(asmtarget);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAsmTargetINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..asmtarget.AsSpirvSpan()]);
    }

    public static Instruction AddOpAsmINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef asmtype, IdRef target, LiteralString asminstructions, LiteralString constraints)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(asmtype) + buffer.GetWordLength(target) + buffer.GetWordLength(asminstructions) + buffer.GetWordLength(constraints);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAsmINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..asmtype.AsSpirvSpan(), ..target.AsSpirvSpan(), ..asminstructions.AsSpirvSpan(), ..constraints.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUMul32x16INTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAsmINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef asmtype, IdRef target, LiteralString asminstructions, LiteralString constraints)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(asmtype) + buffer.GetWordLength(target) + buffer.GetWordLength(asminstructions) + buffer.GetWordLength(constraints);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAsmINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..asmtype.AsSpirvSpan(), ..target.AsSpirvSpan(), ..asminstructions.AsSpirvSpan(), ..constraints.AsSpirvSpan()]);
    }

    public static Instruction AddOpAsmCallINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef asm, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(asm) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAsmCallINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..asm.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpUMul32x16INTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAsmCallINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef asm, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(asm) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAsmCallINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..asm.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicFMinEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicFMinEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicFMinEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAtomicFMinEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicFMinEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicFMaxEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicFMaxEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicFMaxEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAtomicFMaxEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicFMaxEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpAssumeTrueKHR(this SpirvBuffer buffer, IdRef condition)
    {
        var wordLength = 1 + buffer.GetWordLength(condition);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAssumeTrueKHR, ..condition.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAssumeTrueKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAssumeTrueKHR(this SpirvBuffer buffer, int position, IdRef condition)
    {
        var wordLength = 1 + buffer.GetWordLength(condition);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAssumeTrueKHR, ..condition.AsSpirvSpan()]);
    }

    public static Instruction AddOpExpectKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef value, IdRef expectedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value) + buffer.GetWordLength(expectedValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpExpectKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan(), ..expectedValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpExpectKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpExpectKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef value, IdRef expectedValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(value) + buffer.GetWordLength(expectedValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpExpectKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..value.AsSpirvSpan(), ..expectedValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpDecorateString(this SpirvBuffer buffer, IdRef target, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpDecorate, target, ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpDecorateString (OpDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to another <c>id</c>.</para>
    /// <para>Target is the <c>id</c> to decorate.  It can potentially be any <c>id</c> that is a forward reference,  except it must not be the <c>id</c> of an OpDecorationGroup.</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpDecorateString(this SpirvBuffer buffer, int position, IdRef target, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(target) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpDecorate, target, ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    public static Instruction AddOpMemberDecorateString(this SpirvBuffer buffer, IdRef structureType, LiteralInteger member, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(structureType) + buffer.GetWordLength(member) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMemberDecorate, ..structureType.AsSpirvSpan(), ..member.AsSpirvSpan(), ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpMemberDecorateString(this SpirvBuffer buffer, int position, IdRef structureType, LiteralInteger member, Decoration decoration, int? additional1 = null, int? additional2 = null, string? additionalString = null)
    {
        var wordLength = 1 + buffer.GetWordLength(structureType) + buffer.GetWordLength(member) + buffer.GetWordLength(decoration) + buffer.GetWordLength(additional1) + buffer.GetWordLength(additional2) + buffer.GetWordLength(additionalString);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMemberDecorate, ..structureType.AsSpirvSpan(), ..member.AsSpirvSpan(), ..decoration.AsSpirvSpan(), ..additional1.AsSpirvSpan(), ..additional2.AsSpirvSpan(), ..additionalString.AsSpirvSpan()]);
    }

    public static Instruction AddOpVmeImageINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef imageType, IdRef sampler)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(imageType) + buffer.GetWordLength(sampler);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpVmeImageINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..imageType.AsSpirvSpan(), ..sampler.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpVmeImageINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef imageType, IdRef sampler)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(imageType) + buffer.GetWordLength(sampler);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpVmeImageINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..imageType.AsSpirvSpan(), ..sampler.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeVmeImageINTEL(this SpirvBuffer buffer, IdResult resultId, IdRef imageType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(imageType);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeVmeImageINTEL, ..resultId.AsSpirvSpan(), ..imageType.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeVmeImageINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdRef imageType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(imageType);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeVmeImageINTEL, ..resultId.AsSpirvSpan(), ..imageType.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcImePayloadINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcImePayloadINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcImePayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcImePayloadINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcRefPayloadINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcRefPayloadINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcRefPayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcRefPayloadINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcSicPayloadINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcSicPayloadINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcSicPayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcSicPayloadINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcMcePayloadINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcMcePayloadINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcMcePayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcMcePayloadINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcMceResultINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcMceResultINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcMceResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcMceResultINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcImeResultINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcImeResultINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcImeResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcImeResultINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcImeResultSingleReferenceStreamoutINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcImeResultSingleReferenceStreamoutINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcImeResultSingleReferenceStreamoutINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcImeResultSingleReferenceStreamoutINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcImeResultDualReferenceStreamoutINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcImeResultDualReferenceStreamoutINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcImeResultDualReferenceStreamoutINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcImeResultDualReferenceStreamoutINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcImeSingleReferenceStreaminINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcImeSingleReferenceStreaminINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcImeSingleReferenceStreaminINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcImeSingleReferenceStreaminINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcImeDualReferenceStreaminINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcImeDualReferenceStreaminINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcImeDualReferenceStreaminINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcImeDualReferenceStreaminINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcRefResultINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcRefResultINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcRefResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcRefResultINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeAvcSicResultINTEL(this SpirvBuffer buffer, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeAvcSicResultINTEL, ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpTypeAvcSicResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeAvcSicResultINTEL, ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef referenceBasePenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(referenceBasePenalty) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..referenceBasePenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef referenceBasePenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(referenceBasePenalty) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..referenceBasePenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceSetInterShapePenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef packedShapePenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedShapePenalty) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetInterShapePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedShapePenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceSetInterShapePenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef packedShapePenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedShapePenalty) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetInterShapePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedShapePenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceSetInterDirectionPenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef directionCost, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(directionCost) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..directionCost.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceSetInterDirectionPenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef directionCost, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(directionCost) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..directionCost.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef packedCostCenterDelta, IdRef packedCostTable, IdRef costPrecision, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedCostCenterDelta) + buffer.GetWordLength(packedCostTable) + buffer.GetWordLength(costPrecision) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedCostCenterDelta.AsSpirvSpan(), ..packedCostTable.AsSpirvSpan(), ..costPrecision.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef packedCostCenterDelta, IdRef packedCostTable, IdRef costPrecision, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedCostCenterDelta) + buffer.GetWordLength(packedCostTable) + buffer.GetWordLength(costPrecision) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedCostCenterDelta.AsSpirvSpan(), ..packedCostTable.AsSpirvSpan(), ..costPrecision.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sliceType, IdRef qp)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sliceType) + buffer.GetWordLength(qp);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sliceType.AsSpirvSpan(), ..qp.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceSetAcOnlyHaarINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetAcOnlyHaarINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceSetAcOnlyHaarINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetAcOnlyHaarINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef sourceFieldPolarity, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sourceFieldPolarity) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sourceFieldPolarity.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef sourceFieldPolarity, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(sourceFieldPolarity) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..sourceFieldPolarity.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef referenceFieldPolarity, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(referenceFieldPolarity) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..referenceFieldPolarity.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef referenceFieldPolarity, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(referenceFieldPolarity) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..referenceFieldPolarity.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef forwardReferenceFieldPolarity, IdRef backwardReferenceFieldPolarity, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(forwardReferenceFieldPolarity) + buffer.GetWordLength(backwardReferenceFieldPolarity) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..forwardReferenceFieldPolarity.AsSpirvSpan(), ..backwardReferenceFieldPolarity.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef forwardReferenceFieldPolarity, IdRef backwardReferenceFieldPolarity, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(forwardReferenceFieldPolarity) + buffer.GetWordLength(backwardReferenceFieldPolarity) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..forwardReferenceFieldPolarity.AsSpirvSpan(), ..backwardReferenceFieldPolarity.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceConvertToImePayloadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToImePayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceConvertToImePayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToImePayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceConvertToImeResultINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToImeResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceConvertToImeResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToImeResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceConvertToRefPayloadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToRefPayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceConvertToRefPayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToRefPayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceConvertToRefResultINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToRefResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceConvertToRefResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToRefResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceConvertToSicPayloadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToSicPayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceConvertToSicPayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToSicPayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceConvertToSicResultINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToSicResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceConvertToSicResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceConvertToSicResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetMotionVectorsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetMotionVectorsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetMotionVectorsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetMotionVectorsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetInterDistortionsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterDistortionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetInterDistortionsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterDistortionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetBestInterDistortionsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetBestInterDistortionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetBestInterDistortionsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetBestInterDistortionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetInterMajorShapeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterMajorShapeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetInterMajorShapeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterMajorShapeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetInterMinorShapeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterMinorShapeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetInterMinorShapeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterMinorShapeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetInterDirectionsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterDirectionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetInterDirectionsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterDirectionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetInterMotionVectorCountINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterMotionVectorCountINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetInterMotionVectorCountINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterMotionVectorCountINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetInterReferenceIdsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterReferenceIdsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetInterReferenceIdsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterReferenceIdsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef packedReferenceIds, IdRef packedReferenceParameterFieldPolarities, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(packedReferenceParameterFieldPolarities) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..packedReferenceParameterFieldPolarities.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef packedReferenceIds, IdRef packedReferenceParameterFieldPolarities, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(packedReferenceParameterFieldPolarities) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..packedReferenceParameterFieldPolarities.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeInitializeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcCoord, IdRef partitionMask, IdRef sADAdjustment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcCoord) + buffer.GetWordLength(partitionMask) + buffer.GetWordLength(sADAdjustment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeInitializeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcCoord.AsSpirvSpan(), ..partitionMask.AsSpirvSpan(), ..sADAdjustment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeInitializeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcCoord, IdRef partitionMask, IdRef sADAdjustment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcCoord) + buffer.GetWordLength(partitionMask) + buffer.GetWordLength(sADAdjustment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeInitializeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcCoord.AsSpirvSpan(), ..partitionMask.AsSpirvSpan(), ..sADAdjustment.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeSetSingleReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef refOffset, IdRef searchWindowConfig, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(refOffset) + buffer.GetWordLength(searchWindowConfig) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetSingleReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..refOffset.AsSpirvSpan(), ..searchWindowConfig.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeSetSingleReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef refOffset, IdRef searchWindowConfig, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(refOffset) + buffer.GetWordLength(searchWindowConfig) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetSingleReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..refOffset.AsSpirvSpan(), ..searchWindowConfig.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeSetDualReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef fwdRefOffset, IdRef bwdRefOffset, IdRef idSearchWindowConfig, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(fwdRefOffset) + buffer.GetWordLength(bwdRefOffset) + buffer.GetWordLength(idSearchWindowConfig) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetDualReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..fwdRefOffset.AsSpirvSpan(), ..bwdRefOffset.AsSpirvSpan(), ..idSearchWindowConfig.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeSetDualReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef fwdRefOffset, IdRef bwdRefOffset, IdRef idSearchWindowConfig, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(fwdRefOffset) + buffer.GetWordLength(bwdRefOffset) + buffer.GetWordLength(idSearchWindowConfig) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetDualReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..fwdRefOffset.AsSpirvSpan(), ..bwdRefOffset.AsSpirvSpan(), ..idSearchWindowConfig.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeRefWindowSizeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef searchWindowConfig, IdRef dualRef)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(searchWindowConfig) + buffer.GetWordLength(dualRef);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeRefWindowSizeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..searchWindowConfig.AsSpirvSpan(), ..dualRef.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeRefWindowSizeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef searchWindowConfig, IdRef dualRef)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(searchWindowConfig) + buffer.GetWordLength(dualRef);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeRefWindowSizeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..searchWindowConfig.AsSpirvSpan(), ..dualRef.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeAdjustRefOffsetINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef refOffset, IdRef srcCoord, IdRef refWindowSize, IdRef imageSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(refOffset) + buffer.GetWordLength(srcCoord) + buffer.GetWordLength(refWindowSize) + buffer.GetWordLength(imageSize);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeAdjustRefOffsetINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..refOffset.AsSpirvSpan(), ..srcCoord.AsSpirvSpan(), ..refWindowSize.AsSpirvSpan(), ..imageSize.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeAdjustRefOffsetINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef refOffset, IdRef srcCoord, IdRef refWindowSize, IdRef imageSize)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(refOffset) + buffer.GetWordLength(srcCoord) + buffer.GetWordLength(refWindowSize) + buffer.GetWordLength(imageSize);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeAdjustRefOffsetINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..refOffset.AsSpirvSpan(), ..srcCoord.AsSpirvSpan(), ..refWindowSize.AsSpirvSpan(), ..imageSize.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeConvertToMcePayloadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeConvertToMcePayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeConvertToMcePayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeConvertToMcePayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeSetMaxMotionVectorCountINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef maxMotionVectorCount, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(maxMotionVectorCount) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..maxMotionVectorCount.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeSetMaxMotionVectorCountINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef maxMotionVectorCount, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(maxMotionVectorCount) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..maxMotionVectorCount.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef threshold, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(threshold) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..threshold.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef threshold, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(threshold) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..threshold.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeSetWeightedSadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef packedSadWeights, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedSadWeights) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetWeightedSadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedSadWeights.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeSetWeightedSadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef packedSadWeights, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedSadWeights) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeSetWeightedSadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedSadWeights.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeEvaluateWithDualReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeEvaluateWithDualReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload, IdRef streaminComponents)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload) + buffer.GetWordLength(streaminComponents);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..streaminComponents.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload, IdRef streaminComponents)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload) + buffer.GetWordLength(streaminComponents);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..streaminComponents.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload, IdRef streaminComponents)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload) + buffer.GetWordLength(streaminComponents);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..streaminComponents.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload, IdRef streaminComponents)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload) + buffer.GetWordLength(streaminComponents);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..streaminComponents.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload, IdRef streaminComponents)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload) + buffer.GetWordLength(streaminComponents);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..streaminComponents.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload, IdRef streaminComponents)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload) + buffer.GetWordLength(streaminComponents);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..streaminComponents.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload, IdRef streaminComponents)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload) + buffer.GetWordLength(streaminComponents);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..streaminComponents.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload, IdRef streaminComponents)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload) + buffer.GetWordLength(streaminComponents);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..streaminComponents.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeConvertToMceResultINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeConvertToMceResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeConvertToMceResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeConvertToMceResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetSingleReferenceStreaminINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetSingleReferenceStreaminINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetDualReferenceStreaminINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetDualReferenceStreaminINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetDualReferenceStreaminINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetDualReferenceStreaminINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeStripDualReferenceStreamoutINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeStripDualReferenceStreamoutINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape) + buffer.GetWordLength(direction);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape) + buffer.GetWordLength(direction);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape) + buffer.GetWordLength(direction);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape) + buffer.GetWordLength(direction);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape) + buffer.GetWordLength(direction);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload, IdRef majorShape, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload) + buffer.GetWordLength(majorShape) + buffer.GetWordLength(direction);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan(), ..majorShape.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetBorderReachedINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef imageSelect, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(imageSelect) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetBorderReachedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..imageSelect.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetBorderReachedINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef imageSelect, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(imageSelect) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetBorderReachedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..imageSelect.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcFmeInitializeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcCoord, IdRef motionVectors, IdRef majorShapes, IdRef minorShapes, IdRef direction, IdRef pixelResolution, IdRef sadAdjustment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcCoord) + buffer.GetWordLength(motionVectors) + buffer.GetWordLength(majorShapes) + buffer.GetWordLength(minorShapes) + buffer.GetWordLength(direction) + buffer.GetWordLength(pixelResolution) + buffer.GetWordLength(sadAdjustment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcFmeInitializeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcCoord.AsSpirvSpan(), ..motionVectors.AsSpirvSpan(), ..majorShapes.AsSpirvSpan(), ..minorShapes.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..pixelResolution.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcFmeInitializeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcCoord, IdRef motionVectors, IdRef majorShapes, IdRef minorShapes, IdRef direction, IdRef pixelResolution, IdRef sadAdjustment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcCoord) + buffer.GetWordLength(motionVectors) + buffer.GetWordLength(majorShapes) + buffer.GetWordLength(minorShapes) + buffer.GetWordLength(direction) + buffer.GetWordLength(pixelResolution) + buffer.GetWordLength(sadAdjustment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcFmeInitializeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcCoord.AsSpirvSpan(), ..motionVectors.AsSpirvSpan(), ..majorShapes.AsSpirvSpan(), ..minorShapes.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..pixelResolution.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcBmeInitializeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcCoord, IdRef motionVectors, IdRef majorShapes, IdRef minorShapes, IdRef direction, IdRef pixelResolution, IdRef bidirectionalWeight, IdRef sadAdjustment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcCoord) + buffer.GetWordLength(motionVectors) + buffer.GetWordLength(majorShapes) + buffer.GetWordLength(minorShapes) + buffer.GetWordLength(direction) + buffer.GetWordLength(pixelResolution) + buffer.GetWordLength(bidirectionalWeight) + buffer.GetWordLength(sadAdjustment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcBmeInitializeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcCoord.AsSpirvSpan(), ..motionVectors.AsSpirvSpan(), ..majorShapes.AsSpirvSpan(), ..minorShapes.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..pixelResolution.AsSpirvSpan(), ..bidirectionalWeight.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcBmeInitializeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcCoord, IdRef motionVectors, IdRef majorShapes, IdRef minorShapes, IdRef direction, IdRef pixelResolution, IdRef bidirectionalWeight, IdRef sadAdjustment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcCoord) + buffer.GetWordLength(motionVectors) + buffer.GetWordLength(majorShapes) + buffer.GetWordLength(minorShapes) + buffer.GetWordLength(direction) + buffer.GetWordLength(pixelResolution) + buffer.GetWordLength(bidirectionalWeight) + buffer.GetWordLength(sadAdjustment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcBmeInitializeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcCoord.AsSpirvSpan(), ..motionVectors.AsSpirvSpan(), ..majorShapes.AsSpirvSpan(), ..minorShapes.AsSpirvSpan(), ..direction.AsSpirvSpan(), ..pixelResolution.AsSpirvSpan(), ..bidirectionalWeight.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcRefConvertToMcePayloadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefConvertToMcePayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcRefConvertToMcePayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefConvertToMcePayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcRefSetBidirectionalMixDisableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcRefSetBidirectionalMixDisableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcRefSetBilinearFilterEnableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefSetBilinearFilterEnableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcRefSetBilinearFilterEnableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefSetBilinearFilterEnableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcRefEvaluateWithDualReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcRefEvaluateWithDualReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef packedReferenceIds, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef packedReferenceIds, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef packedReferenceIds, IdRef packedReferenceFieldPolarities, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(packedReferenceFieldPolarities) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..packedReferenceFieldPolarities.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef packedReferenceIds, IdRef packedReferenceFieldPolarities, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(packedReferenceFieldPolarities) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..packedReferenceFieldPolarities.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcRefConvertToMceResultINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefConvertToMceResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcRefConvertToMceResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcRefConvertToMceResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicInitializeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcCoord)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcCoord);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicInitializeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcCoord.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicInitializeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcCoord)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcCoord);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicInitializeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcCoord.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicConfigureSkcINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef skipBlockPartitionType, IdRef skipMotionVectorMask, IdRef motionVectors, IdRef bidirectionalWeight, IdRef sadAdjustment, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(skipBlockPartitionType) + buffer.GetWordLength(skipMotionVectorMask) + buffer.GetWordLength(motionVectors) + buffer.GetWordLength(bidirectionalWeight) + buffer.GetWordLength(sadAdjustment) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConfigureSkcINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..skipBlockPartitionType.AsSpirvSpan(), ..skipMotionVectorMask.AsSpirvSpan(), ..motionVectors.AsSpirvSpan(), ..bidirectionalWeight.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicConfigureSkcINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef skipBlockPartitionType, IdRef skipMotionVectorMask, IdRef motionVectors, IdRef bidirectionalWeight, IdRef sadAdjustment, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(skipBlockPartitionType) + buffer.GetWordLength(skipMotionVectorMask) + buffer.GetWordLength(motionVectors) + buffer.GetWordLength(bidirectionalWeight) + buffer.GetWordLength(sadAdjustment) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConfigureSkcINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..skipBlockPartitionType.AsSpirvSpan(), ..skipMotionVectorMask.AsSpirvSpan(), ..motionVectors.AsSpirvSpan(), ..bidirectionalWeight.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicConfigureIpeLumaINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef lumaIntraPartitionMask, IdRef intraNeighbourAvailabilty, IdRef leftEdgeLumaPixels, IdRef upperLeftCornerLumaPixel, IdRef upperEdgeLumaPixels, IdRef upperRightEdgeLumaPixels, IdRef sadAdjustment, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(lumaIntraPartitionMask) + buffer.GetWordLength(intraNeighbourAvailabilty) + buffer.GetWordLength(leftEdgeLumaPixels) + buffer.GetWordLength(upperLeftCornerLumaPixel) + buffer.GetWordLength(upperEdgeLumaPixels) + buffer.GetWordLength(upperRightEdgeLumaPixels) + buffer.GetWordLength(sadAdjustment) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConfigureIpeLumaINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..lumaIntraPartitionMask.AsSpirvSpan(), ..intraNeighbourAvailabilty.AsSpirvSpan(), ..leftEdgeLumaPixels.AsSpirvSpan(), ..upperLeftCornerLumaPixel.AsSpirvSpan(), ..upperEdgeLumaPixels.AsSpirvSpan(), ..upperRightEdgeLumaPixels.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicConfigureIpeLumaINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef lumaIntraPartitionMask, IdRef intraNeighbourAvailabilty, IdRef leftEdgeLumaPixels, IdRef upperLeftCornerLumaPixel, IdRef upperEdgeLumaPixels, IdRef upperRightEdgeLumaPixels, IdRef sadAdjustment, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(lumaIntraPartitionMask) + buffer.GetWordLength(intraNeighbourAvailabilty) + buffer.GetWordLength(leftEdgeLumaPixels) + buffer.GetWordLength(upperLeftCornerLumaPixel) + buffer.GetWordLength(upperEdgeLumaPixels) + buffer.GetWordLength(upperRightEdgeLumaPixels) + buffer.GetWordLength(sadAdjustment) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConfigureIpeLumaINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..lumaIntraPartitionMask.AsSpirvSpan(), ..intraNeighbourAvailabilty.AsSpirvSpan(), ..leftEdgeLumaPixels.AsSpirvSpan(), ..upperLeftCornerLumaPixel.AsSpirvSpan(), ..upperEdgeLumaPixels.AsSpirvSpan(), ..upperRightEdgeLumaPixels.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicConfigureIpeLumaChromaINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef lumaIntraPartitionMask, IdRef intraNeighbourAvailabilty, IdRef leftEdgeLumaPixels, IdRef upperLeftCornerLumaPixel, IdRef upperEdgeLumaPixels, IdRef upperRightEdgeLumaPixels, IdRef leftEdgeChromaPixels, IdRef upperLeftCornerChromaPixel, IdRef upperEdgeChromaPixels, IdRef sadAdjustment, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(lumaIntraPartitionMask) + buffer.GetWordLength(intraNeighbourAvailabilty) + buffer.GetWordLength(leftEdgeLumaPixels) + buffer.GetWordLength(upperLeftCornerLumaPixel) + buffer.GetWordLength(upperEdgeLumaPixels) + buffer.GetWordLength(upperRightEdgeLumaPixels) + buffer.GetWordLength(leftEdgeChromaPixels) + buffer.GetWordLength(upperLeftCornerChromaPixel) + buffer.GetWordLength(upperEdgeChromaPixels) + buffer.GetWordLength(sadAdjustment) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..lumaIntraPartitionMask.AsSpirvSpan(), ..intraNeighbourAvailabilty.AsSpirvSpan(), ..leftEdgeLumaPixels.AsSpirvSpan(), ..upperLeftCornerLumaPixel.AsSpirvSpan(), ..upperEdgeLumaPixels.AsSpirvSpan(), ..upperRightEdgeLumaPixels.AsSpirvSpan(), ..leftEdgeChromaPixels.AsSpirvSpan(), ..upperLeftCornerChromaPixel.AsSpirvSpan(), ..upperEdgeChromaPixels.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicConfigureIpeLumaChromaINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef lumaIntraPartitionMask, IdRef intraNeighbourAvailabilty, IdRef leftEdgeLumaPixels, IdRef upperLeftCornerLumaPixel, IdRef upperEdgeLumaPixels, IdRef upperRightEdgeLumaPixels, IdRef leftEdgeChromaPixels, IdRef upperLeftCornerChromaPixel, IdRef upperEdgeChromaPixels, IdRef sadAdjustment, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(lumaIntraPartitionMask) + buffer.GetWordLength(intraNeighbourAvailabilty) + buffer.GetWordLength(leftEdgeLumaPixels) + buffer.GetWordLength(upperLeftCornerLumaPixel) + buffer.GetWordLength(upperEdgeLumaPixels) + buffer.GetWordLength(upperRightEdgeLumaPixels) + buffer.GetWordLength(leftEdgeChromaPixels) + buffer.GetWordLength(upperLeftCornerChromaPixel) + buffer.GetWordLength(upperEdgeChromaPixels) + buffer.GetWordLength(sadAdjustment) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..lumaIntraPartitionMask.AsSpirvSpan(), ..intraNeighbourAvailabilty.AsSpirvSpan(), ..leftEdgeLumaPixels.AsSpirvSpan(), ..upperLeftCornerLumaPixel.AsSpirvSpan(), ..upperEdgeLumaPixels.AsSpirvSpan(), ..upperRightEdgeLumaPixels.AsSpirvSpan(), ..leftEdgeChromaPixels.AsSpirvSpan(), ..upperLeftCornerChromaPixel.AsSpirvSpan(), ..upperEdgeChromaPixels.AsSpirvSpan(), ..sadAdjustment.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetMotionVectorMaskINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef skipBlockPartitionType, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(skipBlockPartitionType) + buffer.GetWordLength(direction);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetMotionVectorMaskINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..skipBlockPartitionType.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetMotionVectorMaskINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef skipBlockPartitionType, IdRef direction)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(skipBlockPartitionType) + buffer.GetWordLength(direction);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetMotionVectorMaskINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..skipBlockPartitionType.AsSpirvSpan(), ..direction.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicConvertToMcePayloadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConvertToMcePayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicConvertToMcePayloadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConvertToMcePayloadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef packedShapePenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedShapePenalty) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedShapePenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef packedShapePenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedShapePenalty) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedShapePenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef lumaModePenalty, IdRef lumaPackedNeighborModes, IdRef lumaPackedNonDcPenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(lumaModePenalty) + buffer.GetWordLength(lumaPackedNeighborModes) + buffer.GetWordLength(lumaPackedNonDcPenalty) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..lumaModePenalty.AsSpirvSpan(), ..lumaPackedNeighborModes.AsSpirvSpan(), ..lumaPackedNonDcPenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef lumaModePenalty, IdRef lumaPackedNeighborModes, IdRef lumaPackedNonDcPenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(lumaModePenalty) + buffer.GetWordLength(lumaPackedNeighborModes) + buffer.GetWordLength(lumaPackedNonDcPenalty) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..lumaModePenalty.AsSpirvSpan(), ..lumaPackedNeighborModes.AsSpirvSpan(), ..lumaPackedNonDcPenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef chromaModeBasePenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(chromaModeBasePenalty) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..chromaModeBasePenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef chromaModeBasePenalty, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(chromaModeBasePenalty) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..chromaModeBasePenalty.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicSetBilinearFilterEnableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetBilinearFilterEnableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicSetBilinearFilterEnableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetBilinearFilterEnableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef packedSadCoefficients, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedSadCoefficients) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedSadCoefficients.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef packedSadCoefficients, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packedSadCoefficients) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packedSadCoefficients.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef blockBasedSkipType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(blockBasedSkipType) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..blockBasedSkipType.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef blockBasedSkipType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(blockBasedSkipType) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..blockBasedSkipType.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicEvaluateIpeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateIpeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicEvaluateIpeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateIpeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef refImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(refImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..refImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicEvaluateWithDualReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicEvaluateWithDualReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef fwdRefImage, IdRef bwdRefImage, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(fwdRefImage) + buffer.GetWordLength(bwdRefImage) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..fwdRefImage.AsSpirvSpan(), ..bwdRefImage.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef packedReferenceIds, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef packedReferenceIds, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef packedReferenceIds, IdRef packedReferenceFieldPolarities, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(packedReferenceFieldPolarities) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..packedReferenceFieldPolarities.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef srcImage, IdRef packedReferenceIds, IdRef packedReferenceFieldPolarities, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(srcImage) + buffer.GetWordLength(packedReferenceIds) + buffer.GetWordLength(packedReferenceFieldPolarities) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..srcImage.AsSpirvSpan(), ..packedReferenceIds.AsSpirvSpan(), ..packedReferenceFieldPolarities.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicConvertToMceResultINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConvertToMceResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicConvertToMceResultINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicConvertToMceResultINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetIpeLumaShapeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetIpeLumaShapeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetIpeLumaShapeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetIpeLumaShapeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetPackedIpeLumaModesINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetPackedIpeLumaModesINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetIpeChromaModeINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetIpeChromaModeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetIpeChromaModeINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetIpeChromaModeINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupAvcSicGetInterRawSadsINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetInterRawSadsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupAvcSicGetInterRawSadsINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef payload)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(payload);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupAvcSicGetInterRawSadsINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..payload.AsSpirvSpan()]);
    }

    public static Instruction AddOpVariableLengthArrayINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef lenght)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(lenght);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpVariableLengthArrayINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..lenght.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpVariableLengthArrayINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef lenght)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(lenght);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpVariableLengthArrayINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..lenght.AsSpirvSpan()]);
    }

    public static Instruction AddOpSaveMemoryINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSaveMemoryINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpSaveMemoryINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSaveMemoryINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan()]);
    }

    public static Instruction AddOpRestoreMemoryINTEL(this SpirvBuffer buffer, IdRef ptr)
    {
        var wordLength = 1 + buffer.GetWordLength(ptr);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRestoreMemoryINTEL, ..ptr.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpRestoreMemoryINTEL(this SpirvBuffer buffer, int position, IdRef ptr)
    {
        var wordLength = 1 + buffer.GetWordLength(ptr);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRestoreMemoryINTEL, ..ptr.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatSinCosPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger fromSign, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(fromSign) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSinCosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..fromSign.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatSinCosPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger fromSign, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(fromSign) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSinCosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..fromSign.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatCastINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCastINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatCastINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCastINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatCastFromIntINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger mout, LiteralInteger fromSign, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(mout) + buffer.GetWordLength(fromSign) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCastFromIntINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..fromSign.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatCastFromIntINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger mout, LiteralInteger fromSign, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(mout) + buffer.GetWordLength(fromSign) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCastFromIntINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..fromSign.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatCastToIntINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCastToIntINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatCastToIntINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCastToIntINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatAddINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatAddINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatAddINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatAddINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatSubINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSubINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatSubINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSubINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatMulINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatMulINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatMulINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatMulINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatDivINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatDivINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatDivINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatDivINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatGTINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatGTINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatGTINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatGTINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatGEINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatGEINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatGEINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatGEINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatLTINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLTINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatLTINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLTINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatLEINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLEINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatLEINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLEINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatEQINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatEQINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatEQINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatEQINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatRecipINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatRecipINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatRecipINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatRecipINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatRSqrtINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatRSqrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatRSqrtINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatRSqrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatCbrtINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCbrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatCbrtINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCbrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatHypotINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatHypotINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatHypotINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatHypotINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatSqrtINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSqrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatSqrtINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSqrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatLogINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLogINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatLogINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLogINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatLog2INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLog2INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatLog2INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLog2INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatLog10INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLog10INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatLog10INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLog10INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatLog1pINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLog1pINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatLog1pINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatLog1pINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatExpINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatExpINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatExpINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatExpINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatExp2INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatExp2INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatExp2INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatExp2INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatExp10INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatExp10INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatExp10INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatExp10INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatExpm1INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatExpm1INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatExpm1INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatExpm1INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatSinINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSinINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatSinINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSinINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatCosINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatCosINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatSinCosINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSinCosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatSinCosINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSinCosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatSinPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSinPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatSinPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatSinPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatCosPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatCosPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatCosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatASinINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatASinINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatASinINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatASinINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatASinPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatASinPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatASinPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatASinPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatACosINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatACosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatACosINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatACosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatACosPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatACosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatACosPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatACosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatATanINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatATanINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatATanINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatATanINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatATanPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatATanPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatATanPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatATanPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatATan2INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatATan2INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatATan2INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatATan2INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatPowINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatPowINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatPowINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatPowINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatPowRINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatPowRINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatPowRINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(m2) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatPowRINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..m2.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpArbitraryFloatPowNINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArbitraryFloatPowNINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMemberDecorateString (OpMemberDecorateStringGOOGLE)</c></para>
    /// <para>Add a string Decoration to a member of a structure type.</para>
    /// <para>Structure Type is the <c>id</c> of an OpTypeStruct.</para>
    /// <para>Member is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, …​</para>
    /// <para>Decoration is a decoration that takes at least one Literal operand, and has only Literal string operands.</para>
    /// </summary>
    public static Instruction InsertOpArbitraryFloatPowNINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef a, LiteralInteger m1, IdRef b, LiteralInteger mout, LiteralInteger enableSubnormals, LiteralInteger roundingMode, LiteralInteger roundingAccuracy)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(a) + buffer.GetWordLength(m1) + buffer.GetWordLength(b) + buffer.GetWordLength(mout) + buffer.GetWordLength(enableSubnormals) + buffer.GetWordLength(roundingMode) + buffer.GetWordLength(roundingAccuracy);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArbitraryFloatPowNINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..a.AsSpirvSpan(), ..m1.AsSpirvSpan(), ..b.AsSpirvSpan(), ..mout.AsSpirvSpan(), ..enableSubnormals.AsSpirvSpan(), ..roundingMode.AsSpirvSpan(), ..roundingAccuracy.AsSpirvSpan()]);
    }

    public static Instruction AddOpLoopControlINTEL(this SpirvBuffer buffer, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpLoopControlINTEL, ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpLoopControlINTEL(this SpirvBuffer buffer, int position, Span<LiteralInteger> values)
    {
        var wordLength = 1 + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpLoopControlINTEL, ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpAliasDomainDeclINTEL(this SpirvBuffer buffer, IdResult resultId, IdRef? name)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(name);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAliasDomainDeclINTEL, ..resultId.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAliasDomainDeclINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdRef? name)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(name);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAliasDomainDeclINTEL, ..resultId.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction AddOpAliasScopeDeclINTEL(this SpirvBuffer buffer, IdResult resultId, IdRef aliasDomain, IdRef? name)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(aliasDomain) + buffer.GetWordLength(name);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAliasScopeDeclINTEL, ..resultId.AsSpirvSpan(), ..aliasDomain.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAliasScopeDeclINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdRef aliasDomain, IdRef? name)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(aliasDomain) + buffer.GetWordLength(name);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAliasScopeDeclINTEL, ..resultId.AsSpirvSpan(), ..aliasDomain.AsSpirvSpan(), ..name.AsSpirvSpan()]);
    }

    public static Instruction AddOpAliasScopeListDeclINTEL(this SpirvBuffer buffer, IdResult resultId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAliasScopeListDeclINTEL, ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAliasScopeListDeclINTEL(this SpirvBuffer buffer, int position, IdResult resultId, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAliasScopeListDeclINTEL, ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedSqrtINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedSqrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedSqrtINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedSqrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedRecipINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedRecipINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedRecipINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedRecipINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedRsqrtINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedRsqrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedRsqrtINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedRsqrtINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedSinINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedSinINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedSinINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedSinINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedCosINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedCosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedCosINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedCosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedSinCosINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedSinCosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedSinCosINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedSinCosINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedSinPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedSinPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedSinPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedSinPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedCosPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedCosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedCosPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedCosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedSinCosPiINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedSinCosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedSinCosPiINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedSinCosPiINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedLogINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedLogINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedLogINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedLogINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpFixedExpINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFixedExpINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFixedExpINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef inputType, IdRef input, LiteralInteger s, LiteralInteger i, LiteralInteger rI, LiteralInteger q, LiteralInteger o)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(inputType) + buffer.GetWordLength(input) + buffer.GetWordLength(s) + buffer.GetWordLength(i) + buffer.GetWordLength(rI) + buffer.GetWordLength(q) + buffer.GetWordLength(o);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFixedExpINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..inputType.AsSpirvSpan(), ..input.AsSpirvSpan(), ..s.AsSpirvSpan(), ..i.AsSpirvSpan(), ..rI.AsSpirvSpan(), ..q.AsSpirvSpan(), ..o.AsSpirvSpan()]);
    }

    public static Instruction AddOpPtrCastToCrossWorkgroupINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpPtrCastToCrossWorkgroupINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpPtrCastToCrossWorkgroupINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpPtrCastToCrossWorkgroupINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    public static Instruction AddOpCrossWorkgroupCastToPtrINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCrossWorkgroupCastToPtrINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpLoopControlINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCrossWorkgroupCastToPtrINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCrossWorkgroupCastToPtrINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan()]);
    }

    public static Instruction AddOpReadPipeBlockingINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpReadPipeBlockingINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpReadPipeBlockingINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpReadPipeBlockingINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpReadPipeBlockingINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpWritePipeBlockingINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpWritePipeBlockingINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpWritePipeBlockingINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpWritePipeBlockingINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef packetSize, IdRef packetAlignment)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(packetSize) + buffer.GetWordLength(packetAlignment);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpWritePipeBlockingINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..packetSize.AsSpirvSpan(), ..packetAlignment.AsSpirvSpan()]);
    }

    public static Instruction AddOpFPGARegINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef result, IdRef input)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(result) + buffer.GetWordLength(input);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpFPGARegINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..result.AsSpirvSpan(), ..input.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpFPGARegINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpFPGARegINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef result, IdRef input)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(result) + buffer.GetWordLength(input);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpFPGARegINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..result.AsSpirvSpan(), ..input.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetRayTMinKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetRayTMinKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetRayTMinKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetRayTMinKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetRayTMinKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetRayFlagsKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetRayFlagsKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetRayFlagsKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetRayFlagsKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetRayFlagsKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionTKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionTKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionTKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionTKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionTKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionInstanceCustomIndexKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionInstanceCustomIndexKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionInstanceCustomIndexKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionInstanceCustomIndexKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionInstanceCustomIndexKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionInstanceIdKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionInstanceIdKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionInstanceIdKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionInstanceIdKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionInstanceIdKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionGeometryIndexKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionGeometryIndexKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionGeometryIndexKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionGeometryIndexKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionGeometryIndexKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionPrimitiveIndexKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionPrimitiveIndexKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionPrimitiveIndexKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionPrimitiveIndexKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionPrimitiveIndexKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionBarycentricsKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionBarycentricsKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionBarycentricsKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionBarycentricsKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionBarycentricsKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionFrontFaceKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionFrontFaceKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionFrontFaceKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionFrontFaceKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionFrontFaceKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionCandidateAABBOpaqueKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionCandidateAABBOpaqueKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionCandidateAABBOpaqueKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionObjectRayDirectionKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionObjectRayDirectionKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionObjectRayDirectionKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionObjectRayDirectionKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionObjectRayDirectionKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionObjectRayOriginKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionObjectRayOriginKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionObjectRayOriginKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionObjectRayOriginKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionObjectRayOriginKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetWorldRayDirectionKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetWorldRayDirectionKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetWorldRayDirectionKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetWorldRayDirectionKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetWorldRayDirectionKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetWorldRayOriginKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetWorldRayOriginKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetWorldRayOriginKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetWorldRayOriginKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetWorldRayOriginKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionObjectToWorldKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionObjectToWorldKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionObjectToWorldKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionObjectToWorldKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionObjectToWorldKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpRayQueryGetIntersectionWorldToObjectKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionWorldToObjectKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpRayQueryGetIntersectionWorldToObjectKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpRayQueryGetIntersectionWorldToObjectKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef rayQuery, IdRef intersection)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(rayQuery) + buffer.GetWordLength(intersection);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpRayQueryGetIntersectionWorldToObjectKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..rayQuery.AsSpirvSpan(), ..intersection.AsSpirvSpan()]);
    }

    public static Instruction AddOpAtomicFAddEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpAtomicFAddEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpAtomicFAddEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpAtomicFAddEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef pointer, IdScope memory, IdMemorySemantics semantics, IdRef value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(pointer) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics) + buffer.GetWordLength(value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpAtomicFAddEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..pointer.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan(), ..value.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeBufferSurfaceINTEL(this SpirvBuffer buffer, IdResult resultId, AccessQualifier accessQualifier)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(accessQualifier);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeBufferSurfaceINTEL, ..resultId.AsSpirvSpan(), ..accessQualifier.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeBufferSurfaceINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeBufferSurfaceINTEL(this SpirvBuffer buffer, int position, IdResult resultId, AccessQualifier accessQualifier)
    {
        var wordLength = 1 + buffer.GetWordLength(resultId) + buffer.GetWordLength(accessQualifier);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeBufferSurfaceINTEL, ..resultId.AsSpirvSpan(), ..accessQualifier.AsSpirvSpan()]);
    }

    public static Instruction AddOpTypeStructContinuedINTEL(this SpirvBuffer buffer, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpTypeStructContinuedINTEL, ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpTypeStructContinuedINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpTypeStructContinuedINTEL(this SpirvBuffer buffer, int position, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpTypeStructContinuedINTEL, ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpConstantCompositeContinuedINTEL(this SpirvBuffer buffer, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConstantCompositeContinuedINTEL, ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConstantCompositeContinuedINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConstantCompositeContinuedINTEL(this SpirvBuffer buffer, int position, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConstantCompositeContinuedINTEL, ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpSpecConstantCompositeContinuedINTEL(this SpirvBuffer buffer, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSpecConstantCompositeContinuedINTEL, ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSpecConstantCompositeContinuedINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSpecConstantCompositeContinuedINTEL(this SpirvBuffer buffer, int position, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSpecConstantCompositeContinuedINTEL, ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpCompositeConstructContinuedINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpCompositeConstructContinuedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpCompositeConstructContinuedINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpCompositeConstructContinuedINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, Span<IdRef> values)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(values);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpCompositeConstructContinuedINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..values.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertFToBF16INTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef floatValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(floatValue);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertFToBF16INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..floatValue.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertFToBF16INTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertFToBF16INTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef floatValue)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(floatValue);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertFToBF16INTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..floatValue.AsSpirvSpan()]);
    }

    public static Instruction AddOpConvertBF16ToFINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef bFloat16Value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(bFloat16Value);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpConvertBF16ToFINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..bFloat16Value.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpConvertBF16ToFINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpConvertBF16ToFINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef bFloat16Value)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(bFloat16Value);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpConvertBF16ToFINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..bFloat16Value.AsSpirvSpan()]);
    }

    public static Instruction AddOpControlBarrierArriveINTEL(this SpirvBuffer buffer, IdScope execution, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpControlBarrierArriveINTEL, ..execution.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpControlBarrierArriveINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpControlBarrierArriveINTEL(this SpirvBuffer buffer, int position, IdScope execution, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpControlBarrierArriveINTEL, ..execution.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpControlBarrierWaitINTEL(this SpirvBuffer buffer, IdScope execution, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpControlBarrierWaitINTEL, ..execution.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpControlBarrierWaitINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpControlBarrierWaitINTEL(this SpirvBuffer buffer, int position, IdScope execution, IdScope memory, IdMemorySemantics semantics)
    {
        var wordLength = 1 + buffer.GetWordLength(execution) + buffer.GetWordLength(memory) + buffer.GetWordLength(semantics);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpControlBarrierWaitINTEL, ..execution.AsSpirvSpan(), ..memory.AsSpirvSpan(), ..semantics.AsSpirvSpan()]);
    }

    public static Instruction AddOpArithmeticFenceEXT(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef target)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(target);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpArithmeticFenceEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..target.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpArithmeticFenceEXT</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpArithmeticFenceEXT(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef target)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(target);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpArithmeticFenceEXT, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..target.AsSpirvSpan()]);
    }

    public static Instruction AddOpSubgroupBlockPrefetchINTEL(this SpirvBuffer buffer, IdRef ptr, IdRef numBytes, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(ptr) + buffer.GetWordLength(numBytes) + buffer.GetWordLength(memoryaccess);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpSubgroupBlockPrefetchINTEL, ..ptr.AsSpirvSpan(), ..numBytes.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpSubgroupBlockPrefetchINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpSubgroupBlockPrefetchINTEL(this SpirvBuffer buffer, int position, IdRef ptr, IdRef numBytes, MemoryAccessMask? memoryaccess)
    {
        var wordLength = 1 + buffer.GetWordLength(ptr) + buffer.GetWordLength(numBytes) + buffer.GetWordLength(memoryaccess);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpSubgroupBlockPrefetchINTEL, ..ptr.AsSpirvSpan(), ..numBytes.AsSpirvSpan(), ..memoryaccess.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupIMulKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupIMulKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupIMulKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupIMulKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupIMulKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupFMulKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupFMulKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupFMulKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupFMulKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupFMulKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupBitwiseAndKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupBitwiseAndKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupBitwiseAndKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupBitwiseAndKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupBitwiseAndKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupBitwiseOrKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupBitwiseOrKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupBitwiseOrKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupBitwiseOrKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupBitwiseOrKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupBitwiseXorKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupBitwiseXorKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupBitwiseXorKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupBitwiseXorKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupBitwiseXorKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupLogicalAndKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupLogicalAndKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupLogicalAndKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupLogicalAndKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupLogicalAndKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupLogicalOrKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupLogicalOrKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupLogicalOrKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupLogicalOrKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupLogicalOrKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpGroupLogicalXorKHR(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpGroupLogicalXorKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpGroupLogicalXorKHR</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpGroupLogicalXorKHR(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdScope execution, GroupOperation operation, IdRef x)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(execution) + buffer.GetWordLength(operation) + buffer.GetWordLength(x);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpGroupLogicalXorKHR, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..execution.AsSpirvSpan(), ..operation.AsSpirvSpan(), ..x.AsSpirvSpan()]);
    }

    public static Instruction AddOpMaskedGatherINTEL(this SpirvBuffer buffer, IdResult resultId, IdResultType resultType, IdRef ptrVector, LiteralInteger alignment, IdRef mask, IdRef fillEmpty)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(ptrVector) + buffer.GetWordLength(alignment) + buffer.GetWordLength(mask) + buffer.GetWordLength(fillEmpty);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMaskedGatherINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..ptrVector.AsSpirvSpan(), ..alignment.AsSpirvSpan(), ..mask.AsSpirvSpan(), ..fillEmpty.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMaskedGatherINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpMaskedGatherINTEL(this SpirvBuffer buffer, int position, IdResult resultId, IdResultType resultType, IdRef ptrVector, LiteralInteger alignment, IdRef mask, IdRef fillEmpty)
    {
        var wordLength = 1 + buffer.GetWordLength(resultType) + buffer.GetWordLength(resultId) + buffer.GetWordLength(ptrVector) + buffer.GetWordLength(alignment) + buffer.GetWordLength(mask) + buffer.GetWordLength(fillEmpty);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMaskedGatherINTEL, ..resultType.AsSpirvSpan(), ..resultId.AsSpirvSpan(), ..ptrVector.AsSpirvSpan(), ..alignment.AsSpirvSpan(), ..mask.AsSpirvSpan(), ..fillEmpty.AsSpirvSpan()]);
    }

    public static Instruction AddOpMaskedScatterINTEL(this SpirvBuffer buffer, IdRef inputVector, IdRef ptrVector, LiteralInteger alignment, IdRef mask)
    {
        var wordLength = 1 + buffer.GetWordLength(inputVector) + buffer.GetWordLength(ptrVector) + buffer.GetWordLength(alignment) + buffer.GetWordLength(mask);
        return buffer.Add([wordLength << 16 | (int)SDSLOp.OpMaskedScatterINTEL, ..inputVector.AsSpirvSpan(), ..ptrVector.AsSpirvSpan(), ..alignment.AsSpirvSpan(), ..mask.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertOpMaskedScatterINTEL(this SpirvBuffer buffer, int position, IdRef inputVector, IdRef ptrVector, LiteralInteger alignment, IdRef mask)
    {
        var wordLength = 1 + buffer.GetWordLength(inputVector) + buffer.GetWordLength(ptrVector) + buffer.GetWordLength(alignment) + buffer.GetWordLength(mask);
        return buffer.Insert(position, [wordLength << 16 | (int)SDSLOp.OpMaskedScatterINTEL, ..inputVector.AsSpirvSpan(), ..ptrVector.AsSpirvSpan(), ..alignment.AsSpirvSpan(), ..mask.AsSpirvSpan()]);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLRound(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 1, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLRound(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 1, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLRoundEven(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 2, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLRoundEven(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 2, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLTrunc(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 3, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLTrunc(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 3, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFAbs(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 4, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFAbs(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 4, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSAbs(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 5, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSAbs(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 5, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFSign(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 6, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFSign(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 6, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSSign(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 7, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSSign(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 7, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFloor(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 8, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFloor(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 8, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLCeil(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 9, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLCeil(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 9, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFract(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 10, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFract(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 10, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLRadians(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef degrees, int set)
    {
        Span<IdRef> refs = [degrees];
        return buffer.AddOpExtInst(set, 11, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLRadians(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef degrees, int set)
    {
        Span<IdRef> refs = [degrees];
        return buffer.InsertOpExtInst(position, set, 11, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLDegrees(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef radians, int set)
    {
        Span<IdRef> refs = [radians];
        return buffer.AddOpExtInst(set, 12, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLDegrees(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef radians, int set)
    {
        Span<IdRef> refs = [radians];
        return buffer.InsertOpExtInst(position, set, 12, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSin(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 13, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSin(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 13, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLCos(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 14, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLCos(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 14, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLTan(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 15, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLTan(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 15, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLAsin(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 16, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLAsin(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 16, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLAcos(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 17, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLAcos(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 17, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLAtan(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef y_over_x, int set)
    {
        Span<IdRef> refs = [y_over_x];
        return buffer.AddOpExtInst(set, 18, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLAtan(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef y_over_x, int set)
    {
        Span<IdRef> refs = [y_over_x];
        return buffer.InsertOpExtInst(position, set, 18, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSinh(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 19, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSinh(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 19, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLCosh(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 20, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLCosh(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 20, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLTanh(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 21, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLTanh(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 21, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLAsinh(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 22, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLAsinh(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 22, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLAcosh(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 23, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLAcosh(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 23, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLAtanh(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 24, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLAtanh(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 24, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLAtan2(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef y, IdRef x, int set)
    {
        Span<IdRef> refs = [y, x];
        return buffer.AddOpExtInst(set, 25, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLAtan2(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef y, IdRef x, int set)
    {
        Span<IdRef> refs = [y, x];
        return buffer.InsertOpExtInst(position, set, 25, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLPow(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 26, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLPow(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 26, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLExp(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 27, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLExp(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 27, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLLog(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 28, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLLog(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 28, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLExp2(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 29, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLExp2(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 29, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLLog2(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 30, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLLog2(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 30, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSqrt(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 31, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSqrt(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 31, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLInverseSqrt(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 32, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLInverseSqrt(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 32, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLDeterminant(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 33, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLDeterminant(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 33, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLMatrixInverse(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 34, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLMatrixInverse(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 34, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLModf(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef i, int set)
    {
        Span<IdRef> refs = [x, i];
        return buffer.AddOpExtInst(set, 35, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLModf(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef i, int set)
    {
        Span<IdRef> refs = [x, i];
        return buffer.InsertOpExtInst(position, set, 35, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLModfStruct(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 36, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLModfStruct(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 36, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFMin(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 37, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFMin(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 37, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUMin(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 38, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUMin(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 38, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSMin(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 39, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSMin(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 39, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFMax(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 40, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFMax(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 40, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUMax(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 41, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUMax(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 41, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSMax(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 42, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSMax(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 42, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFClamp(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef minVal, IdRef maxVal, int set)
    {
        Span<IdRef> refs = [x, minVal, maxVal];
        return buffer.AddOpExtInst(set, 43, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFClamp(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef minVal, IdRef maxVal, int set)
    {
        Span<IdRef> refs = [x, minVal, maxVal];
        return buffer.InsertOpExtInst(position, set, 43, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUClamp(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef minVal, IdRef maxVal, int set)
    {
        Span<IdRef> refs = [x, minVal, maxVal];
        return buffer.AddOpExtInst(set, 44, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUClamp(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef minVal, IdRef maxVal, int set)
    {
        Span<IdRef> refs = [x, minVal, maxVal];
        return buffer.InsertOpExtInst(position, set, 44, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSClamp(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef minVal, IdRef maxVal, int set)
    {
        Span<IdRef> refs = [x, minVal, maxVal];
        return buffer.AddOpExtInst(set, 45, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSClamp(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef minVal, IdRef maxVal, int set)
    {
        Span<IdRef> refs = [x, minVal, maxVal];
        return buffer.InsertOpExtInst(position, set, 45, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFMix(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, IdRef a, int set)
    {
        Span<IdRef> refs = [x, y, a];
        return buffer.AddOpExtInst(set, 46, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFMix(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, IdRef a, int set)
    {
        Span<IdRef> refs = [x, y, a];
        return buffer.InsertOpExtInst(position, set, 46, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLIMix(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, IdRef a, int set)
    {
        Span<IdRef> refs = [x, y, a];
        return buffer.AddOpExtInst(set, 47, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLIMix(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, IdRef a, int set)
    {
        Span<IdRef> refs = [x, y, a];
        return buffer.InsertOpExtInst(position, set, 47, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLStep(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef edge, IdRef x, int set)
    {
        Span<IdRef> refs = [edge, x];
        return buffer.AddOpExtInst(set, 48, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLStep(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef edge, IdRef x, int set)
    {
        Span<IdRef> refs = [edge, x];
        return buffer.InsertOpExtInst(position, set, 48, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLSmoothStep(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef edge0, IdRef edge1, IdRef x, int set)
    {
        Span<IdRef> refs = [edge0, edge1, x];
        return buffer.AddOpExtInst(set, 49, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLSmoothStep(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef edge0, IdRef edge1, IdRef x, int set)
    {
        Span<IdRef> refs = [edge0, edge1, x];
        return buffer.InsertOpExtInst(position, set, 49, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFma(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef a, IdRef b, IdRef c, int set)
    {
        Span<IdRef> refs = [a, b, c];
        return buffer.AddOpExtInst(set, 50, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFma(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef a, IdRef b, IdRef c, int set)
    {
        Span<IdRef> refs = [a, b, c];
        return buffer.InsertOpExtInst(position, set, 50, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFrexp(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef exp, int set)
    {
        Span<IdRef> refs = [x, exp];
        return buffer.AddOpExtInst(set, 51, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFrexp(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef exp, int set)
    {
        Span<IdRef> refs = [x, exp];
        return buffer.InsertOpExtInst(position, set, 51, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFrexpStruct(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 52, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFrexpStruct(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 52, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLLdexp(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef exp, int set)
    {
        Span<IdRef> refs = [x, exp];
        return buffer.AddOpExtInst(set, 53, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLLdexp(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef exp, int set)
    {
        Span<IdRef> refs = [x, exp];
        return buffer.InsertOpExtInst(position, set, 53, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLPackSnorm4x8(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.AddOpExtInst(set, 54, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLPackSnorm4x8(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.InsertOpExtInst(position, set, 54, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLPackUnorm4x8(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.AddOpExtInst(set, 55, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLPackUnorm4x8(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.InsertOpExtInst(position, set, 55, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLPackSnorm2x16(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.AddOpExtInst(set, 56, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLPackSnorm2x16(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.InsertOpExtInst(position, set, 56, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLPackUnorm2x16(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.AddOpExtInst(set, 57, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLPackUnorm2x16(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.InsertOpExtInst(position, set, 57, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLPackHalf2x16(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.AddOpExtInst(set, 58, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLPackHalf2x16(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.InsertOpExtInst(position, set, 58, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLPackDouble2x32(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.AddOpExtInst(set, 59, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLPackDouble2x32(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.InsertOpExtInst(position, set, 59, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUnpackSnorm2x16(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef p, int set)
    {
        Span<IdRef> refs = [p];
        return buffer.AddOpExtInst(set, 60, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUnpackSnorm2x16(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef p, int set)
    {
        Span<IdRef> refs = [p];
        return buffer.InsertOpExtInst(position, set, 60, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUnpackUnorm2x16(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef p, int set)
    {
        Span<IdRef> refs = [p];
        return buffer.AddOpExtInst(set, 61, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUnpackUnorm2x16(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef p, int set)
    {
        Span<IdRef> refs = [p];
        return buffer.InsertOpExtInst(position, set, 61, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUnpackHalf2x16(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.AddOpExtInst(set, 62, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUnpackHalf2x16(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.InsertOpExtInst(position, set, 62, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUnpackSnorm4x8(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef p, int set)
    {
        Span<IdRef> refs = [p];
        return buffer.AddOpExtInst(set, 63, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUnpackSnorm4x8(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef p, int set)
    {
        Span<IdRef> refs = [p];
        return buffer.InsertOpExtInst(position, set, 63, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUnpackUnorm4x8(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef p, int set)
    {
        Span<IdRef> refs = [p];
        return buffer.AddOpExtInst(set, 64, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUnpackUnorm4x8(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef p, int set)
    {
        Span<IdRef> refs = [p];
        return buffer.InsertOpExtInst(position, set, 64, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLUnpackDouble2x32(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.AddOpExtInst(set, 65, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLUnpackDouble2x32(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef v, int set)
    {
        Span<IdRef> refs = [v];
        return buffer.InsertOpExtInst(position, set, 65, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLLength(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 66, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLLength(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 66, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLDistance(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef p0, IdRef p1, int set)
    {
        Span<IdRef> refs = [p0, p1];
        return buffer.AddOpExtInst(set, 67, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLDistance(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef p0, IdRef p1, int set)
    {
        Span<IdRef> refs = [p0, p1];
        return buffer.InsertOpExtInst(position, set, 67, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLCross(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 68, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLCross(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 68, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLNormalize(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.AddOpExtInst(set, 69, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLNormalize(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, int set)
    {
        Span<IdRef> refs = [x];
        return buffer.InsertOpExtInst(position, set, 69, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFaceForward(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef n, IdRef i, IdRef nref, int set)
    {
        Span<IdRef> refs = [n, i, nref];
        return buffer.AddOpExtInst(set, 70, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFaceForward(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef n, IdRef i, IdRef nref, int set)
    {
        Span<IdRef> refs = [n, i, nref];
        return buffer.InsertOpExtInst(position, set, 70, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLReflect(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef i, IdRef n, int set)
    {
        Span<IdRef> refs = [i, n];
        return buffer.AddOpExtInst(set, 71, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLReflect(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef i, IdRef n, int set)
    {
        Span<IdRef> refs = [i, n];
        return buffer.InsertOpExtInst(position, set, 71, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLRefract(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef i, IdRef n, IdRef eta, int set)
    {
        Span<IdRef> refs = [i, n, eta];
        return buffer.AddOpExtInst(set, 72, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLRefract(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef i, IdRef n, IdRef eta, int set)
    {
        Span<IdRef> refs = [i, n, eta];
        return buffer.InsertOpExtInst(position, set, 72, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFindILsb(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef value, int set)
    {
        Span<IdRef> refs = [value];
        return buffer.AddOpExtInst(set, 73, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFindILsb(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef value, int set)
    {
        Span<IdRef> refs = [value];
        return buffer.InsertOpExtInst(position, set, 73, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFindSMsb(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef value, int set)
    {
        Span<IdRef> refs = [value];
        return buffer.AddOpExtInst(set, 74, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFindSMsb(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef value, int set)
    {
        Span<IdRef> refs = [value];
        return buffer.InsertOpExtInst(position, set, 74, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLFindUMsb(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef value, int set)
    {
        Span<IdRef> refs = [value];
        return buffer.AddOpExtInst(set, 75, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLFindUMsb(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef value, int set)
    {
        Span<IdRef> refs = [value];
        return buffer.InsertOpExtInst(position, set, 75, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLInterpolateAtCentroid(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef interpolant, int set)
    {
        Span<IdRef> refs = [interpolant];
        return buffer.AddOpExtInst(set, 76, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLInterpolateAtCentroid(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef interpolant, int set)
    {
        Span<IdRef> refs = [interpolant];
        return buffer.InsertOpExtInst(position, set, 76, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLInterpolateAtSample(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef interpolant, IdRef sample, int set)
    {
        Span<IdRef> refs = [interpolant, sample];
        return buffer.AddOpExtInst(set, 77, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLInterpolateAtSample(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef interpolant, IdRef sample, int set)
    {
        Span<IdRef> refs = [interpolant, sample];
        return buffer.InsertOpExtInst(position, set, 77, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLInterpolateAtOffset(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef interpolant, IdRef offset, int set)
    {
        Span<IdRef> refs = [interpolant, offset];
        return buffer.AddOpExtInst(set, 78, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLInterpolateAtOffset(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef interpolant, IdRef offset, int set)
    {
        Span<IdRef> refs = [interpolant, offset];
        return buffer.InsertOpExtInst(position, set, 78, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLNMin(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 79, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLNMin(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 79, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLNMax(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.AddOpExtInst(set, 80, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLNMax(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef y, int set)
    {
        Span<IdRef> refs = [x, y];
        return buffer.InsertOpExtInst(position, set, 80, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction AddGLSLNClamp(this SpirvBuffer buffer, IdResultType resultType, int resultId, IdRef x, IdRef minVal, IdRef maxVal, int set)
    {
        Span<IdRef> refs = [x, minVal, maxVal];
        return buffer.AddOpExtInst(set, 81, resultId, resultType, refs);
    }

    /// <summary>
    /// <para><c>OpMaskedScatterINTEL</c></para>
    /// <para>Reserved.</para>
    /// </summary>
    public static Instruction InsertGLSLNClamp(this SpirvBuffer buffer, int position, IdResultType resultType, int resultId, IdRef x, IdRef minVal, IdRef maxVal, int set)
    {
        Span<IdRef> refs = [x, minVal, maxVal];
        return buffer.InsertOpExtInst(position, set, 81, resultId, resultType, refs);
    }
}